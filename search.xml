<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NodeJS-Cookie、Session]]></title>
    <url>%2F2018%2F01%2F02%2FNodeJS-CookieSession%2F</url>
    <content type="text"><![CDATA[紀錄Cookie、Session的差異，以及如何搭配使用。 COOKIE 與 SESSION 的比較與區別 Cookie-數據存放在客戶的瀏覽器上-用戶端的限制約4K-不存放機密資料，避免被他人解析，故僅存放 session id Session-數據放在伺服器上-session資料是 暫存 前端 Cookie寫入 Cookiedocument.cookie = &quot;myName=tom&quot;; 寫入 Cookie，並加入過期時間，document.cookie=&quot;username=bob; expires=Mon, 04 Dec 2017 08:18:32 GMT; path=/&quot;; GMT 時間new Date().toGMTString() 寫入 Cookie，設定 10 秒後失效document.cookie=&quot;username=bob; max-age=10; path=/&quot;; 後端 解析Cookie安裝語法 1$ npm install cookie-parser --save cookie-parser 範例(讀取、寫入) app.js引用cookie-parser模組12345var express = require('express')var cookieParser = require('cookie-parser') // 解析cookie模組var app = express()app.use(cookieParser()) //解析前端cookie routes/index.js123456789101112131415161718192021222324var express = require('express');var router = express.Router();router.get('/', function (req, res, next) &#123; //讀取前端的cookies(全部) console.log(req.cookies); //讀取前端的cookies(單個) console.log(req.cookies.userName); //後端寫入前端Cookies res.cookie('name', 'lulu', &#123; maxAge: 10000, // 只存在n秒，n秒後自動消失 httpOnly: true // 僅限後端存取，無法使用前端document.cookie取得 &#125;) res.render('index', &#123;title: 'Express'&#125;);&#125;);module.exports = router; 後端 session 儲存在伺服器的暫存資料，此暫存可放在記憶體或資料庫上 session可在cookie上儲存一筆辨識你是誰的 session id 概念 安裝語法 1$ npm install express-session --save express-session 範例 當User登入後，伺服器先提供一組session id給你，並紀錄在 客戶的瀏覽器的cookie app.js123456789101112131415var express = require('express')var parseurl = require('parseurl')var session = require('express-session')var app = express()//提供一組session idapp.use(session(&#123; secret: 'keyboard cat', resave: true, saveUninitialized: true, cookie:&#123; maxAge: 100*1000 //100秒後過期 &#125;&#125;)) 表單點擊送出後，會將User資料 post 至後端 html架構12345678910111213&lt;body&gt; &lt;!-- 顯示user資料 --&gt; &lt;h1&gt;&lt;%= userName %&gt; &lt;%= email %&gt;&lt;/h1&gt; &lt;!-- 表單填寫區 --&gt; &lt;form method="post" action="/"&gt; &lt;input type="text" name="username" value=""&gt; &lt;input type="text" name="email" value=""&gt; &lt;input type="submit" value="送出"&gt; &lt;/form&gt;&lt;/body&gt; 前端post資料後，會先將user資料寫入 session暫存，再將網址導回index，並且傳入資料供渲染畫面。 index.js12345678910111213141516171819202122232425var express = require('express');var router = express.Router();/* GET home page. */router.get('/', function(req, res, next) &#123; //將user資料傳入index.ejs供渲染畫面 res.render('index', &#123; userName: req.session.username, email: req.session.email &#125;);&#125;);//接收前端傳入的資料router.post('/',function(req,res)&#123; //取得前端資料，並寫入至後端session暫存 req.session.username = req.body.username; req.session.email = req.body.email; //轉址至首頁 res.redirect('/');&#125;)module.exports = router; 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS-Express+Firebase]]></title>
    <url>%2F2018%2F01%2F01%2FNodeJS-Express-Firebase%2F</url>
    <content type="text"><![CDATA[紀錄如何使用 express + Firebase 設計 RESTful API Todoist 取得Firebase Admin SDK 開啟 專案設定 → 服務帳號 設定方法 安裝NPM npm install firebase-admin --save 複製Admin SDK 設定程式碼片段，貼至 app.js 下載Firebase金鑰(json檔案)，並修改Firebase金鑰路徑 完成設定 once、set 讀取、寫入雖然之前介紹firebase讀取的方式有 once、on 二種，不過在後端的話，只能使用 once 方式，因為 on 在後端並不會有同步更新的效果。 讀取 once12345var fireData = admin.database(); //取得Firebase的databasefireData.ref('todos').once('value', function (snapshot) &#123; console.log(snapshot.val());&#125;) 寫入方式一樣可以使用 set、push 二種。 寫入 set、push123456789var fireData = admin.database(); //取得Firebase的database// 寫法1fireData.ref('todos').set(&#123;title: '待辦清單'&#125;)// 寫法2fireData.ref('todos').push(&#123; content: '要去看電影'&#125;) then 設計思維將資料新增至firebase後，可用 then 接著查看firebase的資料是否有成功新增。 12345678910var fireData = admin.database(); //取得Firebase的database//將資料新增至firebase後，可用 then 接著查看firebase的資料是否有成功新增。fireData.ref('todos').push(&#123;content: '要去看電影'&#125;).then(function () &#123; //讀取todos，查看資料是否有寫入？ fireData.ref('todos').once('value', function (snapshot) &#123; console.log(snapshot.val()); &#125;)&#125;) EJS 整合 Firebase用 todolist 為例，說明如何將firebase上的待辦事項與後端整合，並呈現於網頁上。 範例 firebase資料 取得Firebase的todos資料，並將資料傳入index。 res.render 要放進 firebase function裡面，因為是用AJAX取得資料，所以要確保取得資料後，才進行傳遞參數的動作。 app.js1234567891011121314var fireData = admin.database(); //取得Firebase的database//路由app.get('/', function (req, res) &#123; fireData.ref('todos').once('value', function (snapshot) &#123; // console.log(snapshot.val()); var data = snapshot.val(); //render 要放進firebase function裡面，因為是用AJAX取得資料，所以要確保取得資料後，才進行傳遞參數的動作。 res.render('index', &#123; "todolist": data &#125;); &#125;)&#125;) 取得傳入的資料 todolist，使用ejs的forloop寫法，將資料渲染成HTML。 index.ejs12345678910111213&lt;h1&gt;待辦清單&lt;/h1&gt;&lt;input type="text" id="content" value=""&gt;&lt;input type="submit" id="send" value="送出"&gt;&lt;ul id="list"&gt; &lt;!-- forloop寫法 --&gt; &lt;% for(item in todolist)&#123; %&gt; &lt;li&gt; &lt;%- todolist[item].content %&gt; &lt;input type="button" data-id="&lt;%- item %&gt;" name="" value="刪除"&gt; &lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt; 新增資料API前端畫面輸入 待辦事項 後，點擊 送出 按鈕，此時會將資料 post 給 addTodo 路由，後端處理完後，再將結果傳送給前端更新畫面。 範例 後端app.js1234567891011121314151617181920var fireData = admin.database(); //取得Firebase的database// 新增邏輯app.post('/addTodo', function (req, res) &#123; var content = req.body.content; // 取得前端的content欄位資料 var contentRef = fireData.ref('todos').push(); //先設定寫入的方法為push // 當資料寫入成功後，並使用 then 回傳資料，送至前端渲染畫面 contentRef.set(&#123;"content": content&#125;).then(function () &#123; fireData.ref('todos').once('value', function (snapshot) &#123; // console.log(snapshot.val()); res.send(&#123; "succes": true, "result": snapshot.val(), //todos的資料 "message": "資料新增成功" &#125;); &#125;) &#125;)&#125;) 官方：先設定push的寫法 HTML架構1234567891011121314151617&lt;body&gt; &lt;h1&gt;待辦清單&lt;/h1&gt; &lt;input type="text" id="content" value=""&gt; &lt;input type="submit" id="send" value="送出"&gt; &lt;ul id="list"&gt; &lt;!-- forloop寫法 --&gt; &lt;% for(item in todolist)&#123; %&gt; &lt;li&gt; &lt;%- todolist[item].content %&gt; &lt;input type="button" data-id="&lt;%- item %&gt;" name="" value="刪除"&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;script src="/js/all.js"&gt;&lt;/script&gt;&lt;/body&gt; 前端all.js123456789101112131415161718192021222324252627282930313233343536373839404142434445var send = document.querySelector('#send');var content = document.querySelector('#content');var list = document.querySelector('#list');//新增APIsend.addEventListener('click', function (e) &#123; e.preventDefault(); var xhr = new XMLHttpRequest(); xhr.open('post', '/addTodo'); // 新增資料API xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8'); //取得輸入 待辦事項 var str = content.value; content.value = ""; var todo = JSON.stringify(&#123;"content": str&#125;); // 轉換成字串 xhr.send(todo); //AJAX回傳後的結果 xhr.onload = function () &#123; var originData = JSON.parse(xhr.responseText); // console.log(originData); //重載todoList reloadList(originData); &#125;&#125;)//Reload todoListfunction reloadList(originData) &#123; if (originData.success === false) &#123; alert(originData.message); return; &#125; var data = originData.result; var str = ''; for (item in data) &#123; str += '&lt;li&gt;' + data[item].content + '&lt;input type="button" data-id="' + item + '" name="" value="刪除"&gt;' + '&lt;/li&gt;' &#125; list.innerHTML = str;&#125; 刪除資料API前端點擊 刪除 按鈕，此時會將刪除按鈕的 data-id 資料 post 給 removeTodo 路由，後端處理完後，再將結果傳送給前端更新畫面。 範例 後端app.js12345678910111213141516// 刪除邏輯app.post("/removeTodo", function (req, res) &#123; var _id = req.body.id; // 取得刪除按鈕的 data-id //刪除todos的資料成功後，並使用 then 回傳資料，送至前端渲染畫面 fireData.ref('todos').child(_id).remove().then(function () &#123; fireData.ref('todos').once('value', function (snapshot) &#123; // console.log(snapshot.val()); res.send(&#123; "succes": true, "result": snapshot.val(), "message": "資料刪除成功" &#125;); &#125;) &#125;)&#125;) 在每一個的INPUT(刪除按鈕)上，新增data-id屬性，紀錄firebase的Key值。 HTML架構1234567891011121314151617&lt;body&gt; &lt;h1&gt;待辦清單&lt;/h1&gt; &lt;input type="text" id="content" value=""&gt; &lt;input type="submit" id="send" value="送出"&gt; &lt;ul id="list"&gt; &lt;!-- forloop寫法 --&gt; &lt;% for(item in todolist)&#123; %&gt; &lt;li&gt; &lt;%- todolist[item].content %&gt; &lt;input type="button" data-id="&lt;%- item %&gt;" name="" value="刪除"&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;script src="/js/all.js"&gt;&lt;/script&gt;&lt;/body&gt; 下例 前端all.js ，是針對 ul 進行監聽，進而判斷點擊的元素是否為INPUT(刪除按鈕)，這樣就不用針對 n個的刪除按鈕 建立監聽事件，以達到優化的效果。 前端all.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var send = document.querySelector('#send');var content = document.querySelector('#content');var list = document.querySelector('#list');//刪除APIlist.addEventListener('click', function (e) &#123; //判斷元素是否為 INPUT(刪除按鈕) if (e.target.nodeName !== "INPUT") &#123; return; &#125; var xhr = new XMLHttpRequest(); xhr.open('post', '/removeTodo'); // 刪除API xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8'); //取得輸入 data-id 資料 var id = e.target.dataset.id; var todo = JSON.stringify(&#123;"id": id&#125;); // 轉成字串 xhr.send(todo); //AJAX回傳後的結果 xhr.onload = function () &#123; var originData = JSON.parse(xhr.responseText); // console.log(originData); //重載todoList reloadList(originData); &#125;&#125;)//Reload todoListfunction reloadList(originData) &#123; if (originData.success === false) &#123; alert(originData.message); return; &#125; var data = originData.result; var str = ''; for (item in data) &#123; str += '&lt;li&gt;' + data[item].content + '&lt;input type="button" data-id="' + item + '" name="" value="刪除"&gt;' + '&lt;/li&gt;' &#125; list.innerHTML = str;&#125; 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Firebase</tag>
        <tag>Express</tag>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-基礎用法]]></title>
    <url>%2F2017%2F12%2F30%2FJS-studynotes%2F</url>
    <content type="text"><![CDATA[Selector - 選擇元素 element = document.querySelector(selectors); element 是元素物件。 selectors 是以逗號分隔，包含一個或多個 CSS 選擇器的字串。 選擇單一元素 querySelector12//回傳第一個符合條件的元素var el = document.querySelector('#titleId'); 選擇多個元素 querySelectorAll12//回傳符合條件的元素var el = document.querySelectorAll('.titleClass'); Attribute - 增加標籤屬性 setAttribute 設定 設定 標籤屬性12var el = document.querySelector('.titleClass a');el.setAttribute('href','http://www.yahoo.com.tw'); getAttribute 取得 取得 標籤屬性12var el3 = document.querySelector('.titleClass a').getAttribute('href');console.log(el3); innerHTML - 插入HTML將元素內的html重新覆蓋寫入新的html。 插入HTML123var el = document.getElementById('main');var str = '&lt;h1 class="blue"&gt;1234&lt;/h1&gt;'el.innerHTML = str; createElement - 插入dom元素建立一個新的DOM元素，然後再使用 appendChild 新增子節點，並不會覆蓋原有的DOM元素。 新增dom元素1234567891011121314&lt;h1 class="title"&gt; &lt;em&gt;titile&lt;/em&gt;&lt;/h1&gt;&lt;script &gt; // 建立元素 var sonElement = document.createElement("a"); sonElement.setAttribute('href','www.facebook.com'); sonElement.textContent = '前往Facebook'; // 增加子節點 var fatherElement = document.querySelector('.title'); fatherElement.appendChild(sonElement);&lt;/script&gt; 更新後結果1234&lt;h1 class="title"&gt; &lt;em&gt;titile&lt;/em&gt;+ &lt;a href="www.facebook.com"&gt;前往Facebook&lt;/a&gt;&lt;/h1&gt; addEventListener - 事件氣泡、事件捕捉基本語法 element.addEventListener(event, function, useCapture) 第三個參數：可省略，預設為 false。 範例 可試試將第三個參數分別改成 true 、 false，各執行一次，會有什麼不一樣的結果。 html123&lt;div class="warp"&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/div&gt; 預設：事件氣泡-從指定元素往外找12345678910111213var el = document.querySelector('.box');el.addEventListener('click',function()&#123; alert('box'); console.log('box');&#125;,false);var elBody = document.querySelector('.body');elBody.addEventListener('click',function()&#123; alert('body'); console.log('body');&#125;,false);// false (事件氣泡 - event Bubbling) - 從指定元素往外找// true (事件捕捉 - event capturing) - 從最外面找到指定元素 See the Pen addEventListener - 事件氣泡、事件捕捉 by Kanboo (@Kanboo) on CodePen. stopPropagation - 中止冒泡行為依上例 addEventListener-事件氣泡 因素，有時只是想單純針對單一元素監聽，不想因為事件冒泡的行為，而去觸發到其他元素，這時就可利用 stopPropagation 來達成此需求。 123456var el = document.querySelector('.box');el.addEventListener('click',function(e)&#123;+ e.stopPropagation(); // 中止冒泡行為 alert('box'); console.log('box');&#125;,false); 事件監聽優化 &amp; e.target有時子元素可能要上千個，每個都要綁上監聽的話，效能不是很優，這時可從父節點下手，使用 e.target.nodeName 判斷是否為 想監聽的子元素，若是為想監聽的子元素，可再用 e.target.value 或是 e.target.textContent 取得 值。 e.target.nodeName 取得點擊元素的標籤名稱，如：UL、LI、INPUT… e.target.value 取得選取元素的值 範例 當有一個 ul 底下有多個 li 都要監聽的話，這時我們可以利用 addEventListener-事件氣泡 的原理，只要針對 ul 監聽，讓他往上冒泡，當到達 li 時，這時我們就可以針對 li 做事了。 原始寫法1234567891011//取得ul底下的所有li元素var list = document.querySelectorAll('.list li');//forloop，將每個li元素綁上監聽事件(N次)var len = list.length;for(var i = 0;len&gt;i;i++)&#123; list[i].addEventListener('click',checkName,false)&#125;function checkName(e)&#123; console.log(e.target.textContent);&#125; 優化寫法123456789//取得ul元素var list = document.querySelector('.list');//將ul元素綁上監事件(一次)list.addEventListener('click',checkName,false)function checkName(e)&#123; if(e.target.nodeName !== 'LI')&#123;return&#125;; // 判斷是否為li元素 console.log(e.target.textContent);&#125; preventDefault - 取消預設觸發行為比較常用在 a連結的href、Form表單的submit 上，有時可能只是想觸發呼叫Function，而不想使用到原生附與的功能的話，就可利用 preventDefault 達成此需求。 取消預設觸發行為123456var list = document.querySelector('a');list.addEventListener('click',function(e)&#123; e.preventDefault(); //取消預設觸發行為 /* 撰寫你的Code */&#125;) localStorage - 灠瀏器資料儲存基本語法 儲存1localStorage.setItem('countryItem',countryString); 讀取1localStorage.getItem('countryItem'); 範例 localstorage 只能保存 string 資料，所以當資料非字串型態的話，記得轉為字串string。 JSON.stringify() 將 array 轉為 stringJSON.parse() 將 string 轉為 array 1234567891011121314var country = [ &#123;farmer:'王農夫'&#125;];//儲存var countryString= JSON.stringify(country); // 轉字串console.log(countryString);localStorage.setItem('countryItem',countryString);//讀取var getData = localStorage.getItem('countryItem');var getDataAry = JSON.parse(getData); // 轉arrayconsole.log(getDataAry[0].farmer); 補充小知識var data = listData;var data2 = listData || []; //(建議寫法)console.log(‘沒有 []’, data); // 有可能取得資料或 undefinedconsole.log(‘加上 []’, data2); // 有可能 data-* - 透過 dataset 讀取自訂資料 名字絕對不能以 xml 起頭，無論是否用於 xml、 名字絕對不能包含分號（U+003A）、 名字絕對不能包含大寫 A 到大小 Z 的拉丁字母。 可透過 HTMLElement.dataset.testValue 或 HTMLElement.dataset[“testValue”] 訪問 1234567891011121314&lt;div id="user" data-id="1234567890" data-user="johndoe" data-date-of-birth&gt;John Doe&lt;/div&gt;let el = document.querySelector('#user');// el.id == 'user'// el.dataset.id === '1234567890'// el.dataset.user === 'johndoe'// el.dataset.dateOfBirth === ''el.dataset.dateOfBirth = '1960-10-03'; // set the DOB.// 'someDataAttr' in el.dataset === falseel.dataset.someDataAttr = 'mydata';// 'someDataAttr' in el.dataset === true AjAX屬性 readyState: ０：尚未讀取 １：讀取中 ２：已下載完畢 ３：資訊交換中 ４：處理完畢 Status:即HTTP協定的狀態碼 當 readyState == 4，代表有執行完成，但不一定是有正確撈到資料，要配合HTTP status == 200，才代表是正確撈到資料。 範例 利用AJAX傳送(POST)帳號、密碼資料至後端註冊會員帳號。 POST資料123456789101112131415161718192021222324252627282930313233343536373839var send = document.querySelector('.send');send.addEventListener('click',signup,false);function signup()&#123; var emailStr = document.querySelector('.account').value; var passwordStr = document.querySelector('.password').value; //資料丟到物件 var account = &#123;&#125;; account.email = emailStr; account.password = passwordStr; var xhr = new XMLHttpRequest(); xhr.open('post','https://hexschool-tutorial.herokuapp.com/api/signup',true); xhr.setRequestHeader('Content-type','application/json'); //宣告json格式 var data = JSON.stringify(account); //轉成字串 xhr.send(data); // 送出 //ajax完成後，執行此event xhr.onload = function()&#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // 萬事具備 var callbackData = JSON.parse(xhr.responseText); //接收回傳後資料 console.log(callbackData); var veriStr = callbackData.message; if(veriStr =="帳號註冊成功")&#123; alert('帳號註冊成功！！'); &#125;else&#123; alert("帳號註冊失敗！"); &#125; &#125; else &#123; // 似乎有點問題。 // 或許伺服器傳回了 404（查無此頁） // 或者 500（內部錯誤）什麼的。 alert ("伺服器處理錯誤"); &#125; &#125;&#125; ajax回傳的格式12345&#123; "success": true, "result": &#123;'結果'&#125;, "message": "登入成功"&#125; Asynchronous JavaScript And XML]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS-Express]]></title>
    <url>%2F2017%2F12%2F27%2FNodeJS-Express%2F</url>
    <content type="text"><![CDATA[基本語法下列語法為 express 的起手式，後面會慢慢新增功能。 後端app.js123456789101112131415161718192021var express = require('express'); //引用express模組var app = express();/* app.get參數說明 req 是 Request 物件，存放這此請求的所有資訊res 是 Response 物件，用來回應該請求*/// 首頁app.get('/',function(req,res)&#123; // res.send('1234'); res.send('&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hi!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;')&#125;)// 監聽 portvar port = process.env.PORT || 3000;app.listen(port); //執行 node app.js//網頁連結 http://127.0.0.1:3000/ params - 取得指定路徑透過 :name 這個變數，再配合 req.params 搭配使用，可取得路由的值。 PS：設定為變數的重點為前面加個冒號。 後端app.js1234567891011121314//http://127.0.0.1:3000/user/kanbooapp.get('/user/:name', function (req, res) &#123; console.log(req.params); var myName = req.params.name; console.log(myName); if ( myName !== 'kanboo')&#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;'+'查無此人'+'&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'); &#125;else&#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;'+myName+'&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'); &#125;&#125;) 下列範例為可設多個變數(:name、:data)，取得路由的值。 後端app.js12345678910//http://127.0.0.1:3000/user/kanboo/abcdapp.get('/user/:name/:data', function (req, res) &#123; console.log(req.params); var myName = req.params.name; // kanboo var myData = req.params.data; // abcd console.log(myName,myData); res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + myName + '&lt;br&gt;' + myData + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;) query - 取得網址參數以 http://127.0.0.1:3000/user/kanboo?limit=100&amp;q=張惠妹 這段網址為例，我要用從?(問號)切開，前段網址：http://127.0.0.1:3000/user/kanboo後段網址：limit=100&amp;q=張惠妹 要取得前段網址的資料可用 params ，若要取後段網址的資料就要用 query。 下列示範利用 req.query 取得 後段 網址的參數 後端app.js12345678910111213141516171819202122//網址：http://127.0.0.1:3000/user/kanboo?limit=100&amp;q=張惠妹app.get('/user/:name', function (req, res) &#123; console.log(req.params); console.log(req.query); var myName = req.params.name; var limit = req.query.limit; // limit = 100 var q = req.query.q; //q = 張惠妹 console.log(myName); console.log(limit); console.log(q); res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + 'myName:' + myName + '&lt;br&gt;' + '搜尋:' + q + '&lt;br&gt;' + '筆數：' + limit + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//http://127.0.0.1:3000/user/kanboo?limit=100&amp;q=張惠妹 Middleware - 中介層簡單來說，Middleware的功能就有點像卡控機制，例如：我要進去會員頁面時，Middleware可以幫我先確認是否已登入，再看要不要放行？ 範例 當我網址要切換至 http://127.0.0.1:3000/user 頁面時，此時可利用 app.use 先確認是否已登入，再決定是否使用 next() 放行，可讀取到 app.get。 後端app.js12345678910111213141516171819202122232425262728293031//網址：http://127.0.0.1:3000/user/* app.use參數說明 req 是 Request 物件，存放這此請求的所有資訊res 是 Response 物件，用來回應該請求next 用來控制流程，是否可繼續執行*/app.use(function (req, res, next) &#123; //這裡可以撰寫 驗證的Code var isVerification = true; if (isVerification === true) &#123; console.log('驗證成功!!'); next(); &#125;&#125;)/* 注意：使用 app.use 的話，要放在 app.get 的前面，否則就沒有作用！*/app.get('/user', function (req, res) &#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + 'user' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//http://127.0.0.1:3000/user 注意：使用 app.use 的話，要放在 app.get 的前面，否則就沒有作用！ Middleware - 404頁面假設user開到一個錯誤的網址 http://127.0.0.1:3000/alskdjlasdjf，而根本無此網頁的話，這時會客制一個404頁面回應給user知道無此網頁。 範例 利用 res.status(404) 判斷當無此頁面時，回應 抱歉，你的頁面找不到 的訊息給User知道。 後端app.js123456789// 網址：http://127.0.0.1:3000/alskdjlasdjf// 404頁面 app.use(function (req, res, next) &#123; res.status(404).send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + '抱歉，你的頁面找不到' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//http://127.0.0.1:3000/alskdjlasdjf Middleware - 錯誤頁面另一種情形是當user要進入某個頁面時，有可能是程式碼執行有誤，這時我們可以先將畫面切換至一個客制的錯誤頁面，告知User待修復，稍後嘗試。 範例 程式碼執行 cc() 這個Function出錯了，這時利用 app.use 的新參數 err ,接收程式碼的錯誤訊息，並回應User系統有誤待修復。 後端app.js12345678910111213141516// 錯誤程式碼的狀況app.use(function (req, res, next) &#123; cc(); // 執行不存在的Function next(); // 放人通行..&#125;)// 錯誤頁面 app.use(function (err, req, res, next) &#123; console.log(err.stack); res.status(500).send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + '程式有些問題，請稍後嘗試。' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;) Middleware - 中介function呼叫假設我們有很多頁面要進入時，都需要先確認user是否已登入，才能進入頁面的話，這時我們可以將 確認登入程式碼(isLogin) 包成一個 Function，然後在 app.get 插入 isLogin 進行確認。 範例 下列重點為 isLogin 插入的位置，app.get(‘/‘, isLogin, function (req, res){ 程式碼 }) 後端app.js12345678910111213141516171819202122232425262728293031323334353637383940var isLogin = function (req, res, next) &#123; //這裡可以撰寫 驗證的Code var _url = req.url; console.log(_url); console.log(_url !== '/'); if (_url === '/') &#123; console.log('登入成功!!'); next(); &#125; else &#123; console.log('登入失敗!!'); res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + '登入失敗' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'); &#125;&#125;// 開啟頁面前，先驗證 isLogin 是否成功app.get('/', isLogin, function (req, res) &#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + 'Hello' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)// 開啟頁面前，先驗證 isLogin 是否成功app.get('/user', isLogin, function (req, res) &#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + 'Hello' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//http://127.0.0.1:3000///http://127.0.0.1:3000/user static - 載入靜態檔案若我們在頁面需要提供「圖片、txt檔…」等檔案，如下列範例需使用到 img圖檔，我們要先利用 express.static 指定我們的目錄起點在哪，這樣img圖檔的路徑才能使用相對路徑取得資源。 範例 後端app.js12345678910111213141516171819202122var express = require('express');var app = express();//增加靜態檔案的路徑app.use(express.static('public')); // 設定 目錄起點位置app.get('/', function (req, res) &#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + '&lt;img src="/img/logo.png" &gt;'+ 'Hello' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//監聽portvar port = process.env.PORT || 3000;console.log(port);app.listen(port);//執行 node app.js//網頁連結 http://127.0.0.1:3000/ 示意圖 EJS - 樣板語言安裝語法1$ npm install ejs-locals --save 使用方法 宣告 樣板語言 使用 res.render 讀取哪個ejs檔案，如：res.render(‘index‘) 後端app.js1234567891011121314151617var express = require('express');var app = express();//增加靜態檔案的路徑app.use(express.static('public')); // 設定 目錄起點位置//宣告 樣板語言var engine = require('ejs-locals');app.engine('ejs',engine);app.set('views','./views'); // 設定「樣板程式碼」放在哪裡app.set('view engine','ejs'); // 設定「樣板語言」是用哪種？ejs、pug、handlebarsapp.get('/', function (req, res) &#123; res.render('index'); //渲染 index.ejs 的檔案&#125;)//http://127.0.0.1:3000/ 示意圖 EJS - 參數導入除了一般將.ejs檔案渲染成HTML外，有時也會因為條件的不同，要渲染出不一樣的HTML格式，這時就可以透過參數的傳遞，來達成此需求。 範例 下列範例示範 res.render，如何傳送參數以及ejs接收參數的寫法 傳送 參數12345678910app.get('/', function (req, res) &#123; res.render('index', &#123; 'title': '我是傳入的值', 'dog': '狗狗', 'html': '&lt;h1&gt;我是HTML&lt;/h1&gt;', 'show': true, 'course': ['html','js','css'], &#125;);&#125;)//http://127.0.0.1:3000/ ejs接收參數的寫法123456789101112131415161718192021222324&lt;!-- = 是 渲染成字串- 是 渲染成HTML--&gt;&lt;%= html %&gt;=&gt; &lt;h1&gt;我是HTML&lt;/h1&gt;&lt;%- html %&gt;=&gt; 我是HTML&lt;!-- if寫法 --&gt;&lt;% if(show)&#123; %&gt;&lt;h1&gt;條件成立，顯示222!!&lt;/h1&gt;&lt;% &#125; %&gt;&lt;!-- forloop寫法 --&gt;&lt;ul&gt; &lt;% for(var i=0;course.length&gt;i;i++)&#123; %&gt; &lt;li&gt; &lt;%- course[i] %&gt; &lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt; EJS - 設定layout當有很多頁面都有用到共同的元素(如：表頭、表尾…等)，這時我們可以將會一直重覆的區塊取出，撰寫在 layout.ejs，若有其他頁面需要表頭、表尾的部份，我只要將layout.ejs include在頁面即可。 範例 layout.ejs 將共用的部份撰寫在 layout.ejs 新增 &lt;%- body %&gt; 這段語法，代表要放置不同頁面各自的內容。 layout.ejs1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; 表頭共用的部份(logo、navbar...等) &lt;/header&gt; &lt;%- body %&gt; &lt;footer&gt; 表尾共用的部份(作者、版權信息或者相關鏈接...等) &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; search.ejs 在頁面寫入 &lt;% layout(&#39;layout&#39;) %&gt; 這段語法，代表載入共用HTML部份。 接著開始撰寫HTML內容，而撰寫好的HTML，就會放置在layout.ejs檔案裡的&lt;%- body %&gt;位置。 search.ejs搜尋頁面12345678910&lt;!-- 共用元素 --&gt;&lt;% layout('layout') %&gt;&lt;!-- 表單內容 --&gt;&lt;form action="/searchList" method="post" &gt; &lt;input type="text" name="content" id="content" value=""&gt; &lt;input type="submit" id="send" value="送出"&gt;&lt;/form&gt;&lt;script src="/js/all.js"&gt;&lt;/script&gt; body-parser - 取得表單資料(傳統表單)安裝語法 1$ npm install body-parser --save 範例 在search搜尋頁面的 searchText 輸入搜尋文字後，點擊送出按鈕 此時會將表單資料傳送(post)給/searchList 再透過後端 req.body 取得到表單資料，進行後續解析。 search搜尋頁面123456789&lt;form action="/searchList" method="post" &gt; &lt;input type="text" name="searchText" value=""&gt; &lt;input type="submit" value="送出"&gt; &lt;!-- 只有id的話，body-parser無法解析 --&gt; &lt;!-- &lt;input type="text" id="idflied" value=""&gt; --&gt;&lt;/form&gt; 後端app.js123456789101112131415161718192021222324var bodyParser = require('body-parser');// 增加 body 解析app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false&#125;))//搜尋頁面app.get('/search', function (req, res) &#123; res.render('search');&#125;)//http://127.0.0.1:3000/search//傳統表單app.post('/searchList', function (req, res) &#123; //所有body欄位資料 console.log(req.body); //取得某欄位資料 console.log(req.body.searchText); //轉址 res.redirect('search'); // 將畫面導回搜尋頁面&#125;) 搜尋頁面(search) 是使用 app.get接收表單頁面(searchList) 是使用 app.post在searchList處理完資料後，最後記得將畫面導回搜尋畫面 res.redirect(‘search’); body-parser - 取得表單資料(AJAX)若達到頁面不跳轉，就可回應相關訊息，此時就需要透過AJAX的方式，達到此需求。 範例 新增一路由 searchAJAX，用來處理搜尋的相關資料，最後回傳給前端。 後端app.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var express = require('express');var app = express();var bodyParser = require('body-parser');//增加靜態檔案的路徑app.use(express.static('public'));//宣告 樣板語言var engine = require('ejs-locals');app.engine('ejs', engine);app.set('views', './views'); // 樣板放在哪裡？app.set('view engine', 'ejs'); // 宣告樣板是用哪種語言？ejs、pug、handlebars// 增加 body 解析app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false&#125;))//搜尋頁面app.get('/search', function (req, res) &#123; res.render('search');&#125;)//http://127.0.0.1:3000/search//AJAXapp.post('/searchAJAX', function (req, res) &#123; //所有body欄位資料 console.log(req.body); console.log(req.body.list[1]); /* 這裡撰寫程式碼 */ //回傳結果 res.send('Hello!');&#125;)//監聽portvar port = process.env.PORT || 3000;console.log(port);app.listen(port);//執行 node app.js//網頁連結 http://127.0.0.1:3000/ 重點在於我們將原本在搜尋頁面的 send按鈕 要Submit的動作取消 e.preventDefault();，改用 AJAX 方式，將表單的內容資料，利用 post 給 searchAJAX。 前端all.js123456789101112131415161718192021222324252627282930313233var send = document.querySelector('#send');var content = document.querySelector('#content');send.addEventListener('click', function (e) &#123; e.preventDefault(); var str = content.value; console.log(str); var xhr = new XMLHttpRequest(); xhr.open('post', '/searchAJAX'); //發送給哪個路由 //組合表單資料(文字型態) // xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); // var data = 'content=' + str; // content=123&amp;title=abc //組合表單資料(json型態) xhr.setRequestHeader("Content-type", "application/json"); var searchlist = &#123; "content": str, "list": [1, 2, 3] &#125;; var data = JSON.stringify(searchlist); //轉成字串 //發送表單資料給後端app.js處理 xhr.send(data); //取得後端app.js回傳的資料 xhr.onload = function () &#123; console.log(xhr.responseText); &#125;&#125;) Router - 進階設定當我們網站有越來越多頁面的話，不可能把所有網頁的路由判斷在寫app.js裡，這樣會造成程式碼雜亂，導致後續維護不便，所以我們可以將同類型頁面分別包裝在不同js檔裡，並且使用 module(模組) 輸出，可供 app.js 分別載入，以達到程式碼的簡潔易懂。 範例 app.js 分別載入 user模組(個人資料)、cart模組(購物車) ，讓整個app.js變得簡潔易懂。 後端app.js1234567891011121314151617181920var express = require('express');var user = require('./routes/user.js') // 載入 user模組(個人資料)var user = require('./routes/cart.js') // 載入 cart模組(購物車)var app = express();//網址若為 http://127.0.0.1:3000/user/... 之類的話，就會進去user模組執行。app.use('/user',user);//網址若為 http://127.0.0.1:3000/cart/... 之類的話，就會進去cart模組執行。app.use('/cart',cart);//監聽portvar port = process.env.PORT || 3000;app.listen(port);//執行 node app.js//網頁連結 http://127.0.0.1:3000/ 以user模組(個人資料)為例，因外部引用此模組，語法設定為 app.use(‘/user‘,user);所以網址起頭從 http://127.0.0.1:3000//user/ 開始 user.js12345678910111213141516171819202122232425262728293031var express = require('express');var router = express.Router(); // 路由器//因外部引用此模組，語法為 app.use('/user',user);//所以網址起頭從 http://127.0.0.1:3000/user/ 開始router.get('/edit-porfile', function (req, res) &#123; //若網址為 http://127.0.0.1:3000/user/edit-porfile 進行此function console.log('porfile頁面'); res.send('porfile');&#125;)router.get('/photo', function (req, res) &#123; //若網址為 http://127.0.0.1:3000/user/photo 進行此function console.log('photo頁面'); res.send('photo');&#125;)router.get('/card', function (req, res) &#123; //若網址為 http://127.0.0.1:3000/user/card 進行此function console.log('card頁面'); res.send('card');&#125;)/* 原先都是使用 app.get ，要改用成 router.get*/module.exports = router; 注意 user.js，原先都是使用 app.get ，要改用成 router.get express-generator - 應用程式產生器經過上述種種的介紹，了解express各種的使用方式後，之後我們可以利用 Express應用程式產生器 ，自動幫我們生成一個專案的基本架構，就無須從頭到尾慢慢建構。 安裝語法 1$ npm install express-generator -g 建立語法 建立 express 專案資料 1$ express -e project 切換至專案目錄，並安裝 NPM 套件 12$ cd project$ npm install 運行專案 1$ npm start 專案網址：http://127.0.0.1:3000/ 官方：Express應用程式產生器 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Firebase-基礎用法]]></title>
    <url>%2F2017%2F12%2F26%2FFirebase-studynotes%2F</url>
    <content type="text"><![CDATA[ref(路徑)、set(新增)ref()：尋找資料庫路徑(預設：根目錄)set()：新增資料 新增資料：範例11firebase.database().ref().set('hi'); 結果 新增資料：範例2(物件)1234567891011121314// firebase 全部物件格式，不能陣列內容// 一個班級有兩個學生var school = &#123; student1: &#123; name: 'tom', num: '1' &#125;, student2: &#123; name: 'john', num: '2' &#125;&#125;firebase.database().ref().set(school); 結果 新增資料：範例3(階層式)123456//寫入資料firebase.database().ref('myName').set('kanboo');firebase.database().ref('yourName').set('alice');firebase.database().ref('allName/name01').set('aa');firebase.database().ref('allName/name02').set('bb');firebase.database().ref('allName/nameList/name01').set('cc'); 結果 once、on 讀取資料 once(讀取一次資料庫的資料) 僅向firebase取得一次性資料，所以當firebase資料有異動，需要再一次呼叫，才會取得更新後的資料。 123456var myNameRef = firebase.database().ref('allName/nameList/name01');// 快照myNameRef.once('value', function (snapshot) &#123; console.log(snapshot.val()); document.getElementById('title').textContent = snapshot.val();&#125;) on(隨時監聽) 當firebase資料有異動時，會即時回傳更新資料。 123456var myNameRef = firebase.database().ref('allName/nameList/name01');//on 隨時監聽myNameRef.on('value', function (snapshot) &#123; console.log(snapshot.val()); document.getElementById('title').textContent = snapshot.val();&#125;) push - 新增資料以 Todolist 為例，因為資料隨時會新增，不可能一次就能把所有資料打齊上傳至database，所以就需要借用 push 功能，將 新資料 加在 現有資料 裡。 Todolist：新增待辦123var todos = firebase.database().ref('todos');todos.push(&#123;content:'要去看電影'&#125;);todos.push(&#123;content:'要去看跑步'&#125;); 結果 child 子路徑、remove 移除以 Todolist 為例，當完成某項事件時，就要將它從待辦清單 移除。 Todolist：移除待辦123456// child 子路徑：移至根目錄下的 todos var todos = firebase.database().ref().child('todos');// remove 移除：移除todos下的 -L1H5cAAQnE9y72dCpJ7(要去看電影)todos.child('-L1H5cAAQnE9y72dCpJ7').remove(); 結果 在網頁即時顯示firebase資料可以用 on(隨時監聽) 的特性，隨時將firebase最新的資料回傳更新，這樣在開發時，就不用特地再開firebase的網頁觀看資料，節省切換頁面的時間。 HTML1&lt;pre id="content"&gt;&lt;/pre&gt; js12345// 在網頁即時顯示firebase資料var ref = firebase.database().ref();ref.on('value', function (snapshot) &#123; document.getElementById('content').textContent = JSON.stringify(snapshot.val(), null, 3);&#125;) JSON.stringify補充說明 orderbyForeach 排序從firebase取得有 排序 過後的資料，實作語法需要利用 orderByChild 和 forEach 二個函數搭配使用。 people物件資料1234567891011121314151617var people = &#123; "bob": &#123; "height": 178, "old": 18, "weight": 70 &#125;, "casper": &#123; "height": 180, "old": 13, "weight": 80 &#125;, "mike": &#123; "height": 162, "old": 15, "weight": 55 &#125;&#125;; 依「體重」排序12345678var peopleRef = firebase.database().ref('people');// 路徑&gt;&gt;排序('屬性')&gt;&gt;讀取&gt; forEach 依序撈出資料peopleRef.orderByChild('height').once('value', function (snapshot) &#123; // console.log(snapshot.val()); snapshot.forEach(function (item) &#123; console.log(item.val()); &#125;)&#125;) 延伸問題 firebase 只提供一種排序方式，並無 反向 排序的設定，所以若要達成反向排序，需借用 Array.reverse() 的幫忙。 反向範例123456789101112 var peopleRef = firebase.database().ref('people'); // 路徑&gt;&gt;排序('屬性')&gt;&gt;讀取&gt; forEach 依序撈出資料 peopleRef.orderByChild('height').once('value', function (snapshot) &#123; // console.log(snapshot.val());+ var dataArr = []; snapshot.forEach(function (item) &#123; console.log(item.val());+ dataArr.push(item.val()); &#125;) //反向排序+ console.log(dataArr.reverse()); &#125;) firebase排序規則Array.reverse() startAt、endAt、equalTo 過濾條件 過濾條件： startAt() 多少以上 endAt() 多少以下 equalTo() 相等 使用 過濾條件 時，一定要先 排序(orderByChild) 過資料 一個 過濾條件123456789var peopleRef = firebase.database().ref('people');// 將 重量 排序後，篩選出 4500 以上的資料peopleRef.orderByChild('weight').startAt(4500).once('value', function (snapshot) &#123; snapshot.forEach(function (item) &#123; console.log(item.key); console.log(item.val()); &#125;) // console.log(snapshot.val());&#125;) 多個 過濾條件123456789var peopleRef = firebase.database().ref('people');// 將 重量 排序後，篩選出 2500 ~ 3500 之間的資料peopleRef.orderByChild('weight').startAt(2500).endAt(3500).once('value', function (snapshot) &#123; snapshot.forEach(function (item) &#123; console.log(item.key); console.log(item.val()); &#125;) // console.log(snapshot.val());&#125;) limitToFirst、limitToLast 限制筆數 限制筆數： limitToFirst(n) 從 頭 取得 n 筆資料 limitToLast(n) 從 尾 取得 n 筆資料 取得第 1 筆資料12345678var peopleRef = firebase.database().ref('people');peopleRef.orderByChild('weight').limitToFirst(1).once('value', function (snapshot) &#123; snapshot.forEach(function (item) &#123; console.log(item.key); console.log(item.val()); &#125;) // console.log(snapshot.val());&#125;) 取得倒數 5 筆資料12345678var peopleRef = firebase.database().ref('people');peopleRef.orderByChild('weight').limitToLast(5).once('value', function (snapshot) &#123; snapshot.forEach(function (item) &#123; console.log(item.key); console.log(item.val()); &#125;) // console.log(snapshot.val());&#125;) 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>Firebase</category>
      </categories>
      <tags>
        <tag>Firebase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SASS-基礎用法]]></title>
    <url>%2F2017%2F12%2F25%2FSASS-studynotes%2F</url>
    <content type="text"><![CDATA[變數命名(前面加個 $ 字號)123456789101112131415//變數$font-color: bule;$font-m: 16px;$font-l: $font-m * 1.2;$font-s: $font-m * 0.8;.box01 &#123; color: $font-color; font-size: $font-l;&#125;.box02 &#123; color: $font-color; font-size: $font-s;&#125; @import常見的分類123@import mixin //放置所有Sass全域變數與Mixin@import reset //reset.css@import layout //共同框架(如：表頭、表尾) @mixin + @include建立：@mixin + 名稱 { 語法內容} ; 插入：@include + 名稱 ; 建立1234567//圓角效果@mixin circle($size,$bgcolor)&#123; border-radius: 50%; width: $size; height: $size; background-color: $bgcolor;&#125;// @mixin可搭配變數應用 插入123.circlebox&#123; @include circle(100px,red)&#125; @mixin + @content各種載具斷點123456789101112131415161718192021222324252627282930//iPad - 768px@mixin pad &#123; @media(max-width: 768px)&#123; @content; &#125;&#125;//iPad以下 - 767px@mixin mobile &#123; @media(max-width: 767px)&#123; @content; &#125;&#125;//iPhone 6 Plus - 414px (視專案族群)@mixin i6plue &#123; @media(max-width: 414px)&#123; @content; &#125;&#125;//iPhone 6 - 375px (視專案族群)@mixin i6 &#123; @media(max-width: 768px)&#123; @content; &#125;&#125;//iPhone 5、SE - 320px@mixin i5 &#123; @media(max-width: 320px)&#123; @content; &#125;&#125; 使用方式123456789.header&#123; width: 100px; height: 100px; //iPad - 768px @include pad()&#123; height: auto; &#125;&#125; Sass顏色函數常用函數12345678910111213$bg-color: #ff0000;.darken:hover &#123; background: darken($bg-color, 20%); //將紅色調暗10%&#125;.lighten:hover &#123; background: lighten($bg-color, 20%); //將紅色調亮10%&#125;.invert:hover &#123; background: invert($bg-color); //返回一個反相色&#125; 範例 See the Pen Sass-顏色函數 by Kanboo (@Kanboo) on CodePen. 參考文章30天掌握Sass語法SassMe顏色函數]]></content>
      <categories>
        <category>SASS</category>
      </categories>
      <tags>
        <tag>SASS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS-基礎觀念]]></title>
    <url>%2F2017%2F12%2F24%2FNodeJS-studynotes%2F</url>
    <content type="text"><![CDATA[node全域物件：global node的全域物件為 global ，就像網頁的全域物件為 window。 如下圖，在node環境下，不同js檔之間是區隔的，使用到相同的變數名稱是不會互相影響。 require、module exports由於node環境下，不同js檔之間是區隔的，所以若想要在js檔之間達到資料的傳遞的話，方法如下 app.js 引用語法12345//引用 模組var content = require('./data'); //設定預引用的js檔路徑，不用加副檔名console.log(content.data);console.log(content.bark()); 輸出語法有二種，可任意選擇喜歡的寫法，但不能二種寫法同時在同一個js檔裡，因為會互相覆蓋掉。 data.js 輸出語法1234567891011121314151617//第一種：輸出資料var data = 2;//輸出的資料module.exports = &#123; content: data, title: 'big'&#125;;//第二種：輸出資料exports.data = 2;exports.bark = function()&#123; return 'bark!!';&#125; Node核心模組-createServercreateServer的參數： request：接收User的行為，如：request.url 可取得目前網頁網址response：回應User的結果 123456789101112131415var http = require('http');http.createServer(function (request, response) &#123; // 輸出 純文字 // response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); //文字格式 // response.write('hello word!!'); //輸出 HTML response.writeHead(200, &#123;"Content-Type": "text/html"&#125;); //HTML格式 response.write('&lt;h1&gt;hello word!!&lt;/h1&gt;'); response.end();&#125;).listen(8080); //監聽 8080 port 常見的port：21 FTP80 http3389 遠端桌面 Node模組-Path__dirname：取得目前js檔的目錄路徑，如：/Users/kanboo/Desktop/project __filename：取得目前js檔的檔案路徑，如：/Users/kanboo/Desktop/project/app.js 123456789101112131415161718192021var path = require('path');//抓目錄路徑console.log(path.dirname('/xx/yy/zz.js'));//=&gt; /xx/yy//路徑合併console.log(path.join(__dirname,'/xx'));//=&gt; /Users/kanboo/Desktop/project/xx//抓檔名console.log(path.basename('xx/yy/zz.js'));//=&gt; zz.js//抓副檔名console.log(path.extname('xx/yy/zz.js'));//=&gt; .js//分析路徑console.log(path.parse('xx/yy/zz.js'));//=&gt; &#123; root: '', dir: 'xx/yy', base: 'zz.js', ext: '.js', name: 'zz' &#125; Node.js PATH API文件 NPM-nodemonnodemon是一個專為Node.js設計的模組，它的作用是持續監視著你的程式碼，一旦你修改後保存了，nodemon就會重新啟動你的Node.js程式，這樣你只要刷新你的瀏覽器就能看到改動。 安裝語法1npm install -g nodemon 啟動語法12345//原先啟動server的方法node index.js//改用此方法nodemon index.js nodemon 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-IcoMoon]]></title>
    <url>%2F2017%2F12%2F23%2FCSS-icomoon%2F</url>
    <content type="text"><![CDATA[IcoMoon 下載icons 挑選好想要的icons 修改部份設定 產生sass的css檔 修改引用的html語法預設語法為&lt;span class=&quot;icon-book&quot;&gt;&lt;/span&gt;，修改為&lt;i class=&quot;icon-book&quot;&gt;&lt;/i&gt; 下載字體 引入專案 將下載好檔案解壓縮，複製 fonts資料夾 和 style.scss、variables.scss 複製到專案的source資料夾底下 修改sass的檔名和內容 修改variables.scss內容，並更改檔名為 _icomoon_variables.scss 123 //第一行- $icomoon-font-path: "fonts" !default;+ $icomoon-font-path: "../fonts" !default; //fonts資料夾不是在css資料夾底下，所以需回上一層 修改style.scss內容，並更改檔名為 _icomoon.scss 123 //第一行- @import "variables";+ @import "_icomoon_variables"; 主頁 all.css 引入 _icomoon.scss 123 @import "bootstrap"; @import "font-awesome";+ @import "icomoon"; 使用icons語法 123&lt;i class="icon-music"&gt;&lt;/i&gt;&lt;i class="icon-mic"&gt;&lt;/i&gt;&lt;i class="icon-coin-dollar"&gt;&lt;/i&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>icon</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-webfont 字體]]></title>
    <url>%2F2017%2F12%2F22%2FCSS-Webfont%2F</url>
    <content type="text"><![CDATA[使用方法12345//引入字體@import url(//fonts.googleapis.com/earlyaccess/notosansscsliced.css);//設定字體font-family: 'Noto Sans SC Sliced', sans-serif; 範例See the Pen Webfont - 思源體 by Kanboo (@Kanboo) on CodePen. 問題紀錄雖然已有在css設定 font-family: ‘Noto Sans SC Sliced’, sans-serif; ，不過還是沒套用到新的 font-family ，因為CSS權重的問題，還是使用預設的 微體正黑體， 可能是因為 codepen 有額外加 font-family 設定，導致 &lt;style&gt;的CSS權限 大於在 CSS檔裡面的屬性設定 所以若要強制轉換的話，就需要加 !important 1font-family: 'Noto Sans SC Sliced', sans-serif !important; 參考文章谷歌提出字体切片方案Noto Sans SC Sliced]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>webfont</tag>
        <tag>字體</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-Animation 動畫]]></title>
    <url>%2F2017%2F12%2F21%2FCSS-Animation%2F</url>
    <content type="text"><![CDATA[CSS的Animation分為兩個部分，一個是決定動畫該如何跑的 Keyframe，另一個是將動畫載入元素的 Animation。 Keyframes 語法123456789101112//第一種寫法@keyframes 自訂的name &#123; from &#123; ... &#125; to &#123; ... &#125;&#125;//第二種寫法@keyframes 自訂的name &#123; 0% &#123; ... &#125; 50% &#123; ... &#125; 100% &#123; ... &#125;&#125; Animation 屬性1234567//完整語法animation: 自訂的name duration timing-function delay iteration-count direction fill-mode play-state;//常用寫法animation: 自訂的name duration timing-function iteration-count;animation: time 3s linear infinite; Name：@keyframes 動畫名稱。 Duration：動畫時間。 Timing Function：動畫進行的速度曲線。 ease：是預設的。慢進 → 加速 → 減速到結束。 ease-in：慢進 → 加速到結束。 ease-out：快進 → 減速到結束。 ease-in-out：開始跟結束都是慢的狀態。 linear：以相同速度前進。 steps()：無連續的動作，直接跳至各步 ( step ) 的指定 css。 cubic-bezier()：指定動畫滑動的曲線。 Delay：延遲動畫開始的時間。 Iteration Count：動畫重複次數(預設一次)。 infinite(無限) | 次數 Direction：動畫播放方向。 normal ：每次播放都是從 0% 至 100% reverse ：每次播放都是從 100% 至 0% alternate ：播放兩次以上的話，會從 0% 至 100% ，再從 100% 回到 0% ，以此類推 alternate-reverse ：跟 alternate 相反，會先從 100% 開始播放 Fill Mode：控制動畫播放完後的最終狀態。 none ：回到未播放動畫效果前的狀態 forwards ：停在動畫的最後一個狀態上 backwards ：停在動畫的第一個狀態上 (實測不出來) both ：視 animation-direction 來決定停在哪一個狀態上。 Play State：指定動畫播放或暫停。 可以的選項有 running|pause，與影片的播放、暫停是同樣的意思；這在與 JS 搭配時，可妥善控制動畫。 範例翻轉效果 See the Pen CSS Animation-範例1 by Kanboo (@Kanboo) on CodePen. 滾動效果 See the Pen CSS Animation-範例2 by Kanboo (@Kanboo) on CodePen. 參考文章CSS3 動畫基礎CSS3 AnimationAnimation動畫效果]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>動畫</tag>
        <tag>animattion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-練習-自刻時鐘]]></title>
    <url>%2F2017%2F12%2F20%2FCSS-Exercise-Clock%2F</url>
    <content type="text"><![CDATA[練習-自刻時鐘 步驟 先建立骨架(HTML) 12345678&lt;div class="warp"&gt; &lt;div class="clock"&gt; &lt;div class="centerpoint"&gt;&lt;/div&gt; &lt;div class="hour"&gt;&lt;/div&gt; &lt;div class="minute"&gt;&lt;/div&gt; &lt;div class="second"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 將時鐘元件垂直置中 將「圓點、時針、分針、秒針」移至時鐘的中心點。 123456position: absolute;top: 0;bottom: 0;left: 0;right: 0;margin: auto; 修改transform-origin與position位置 下列說明以 時針 為例(分針、秒針比照辦理)： 垂直置中後的 時針 css 12345678910111213$handwidth: 7px;.hour &#123; width: $handwidth; height: 80px; background-color: blue; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;&#125; 先修改 transform-origin 的軸心 12345678910111213.hour &#123; width: $handwidth; height: 80px; background-color: blue;+ //將軸心變更到 中下方 的位置+ transform-origin: 50% 80%; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;&#125; 加上旋轉的動畫效果 123456789101112131415161718192021.hour &#123; width: $handwidth; height: 80px; background-color: blue; //將軸心變更到 中下方 的位置 transform-origin: 50% 80%; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;+ animation: time 25s infinite linear;&#125;+ //旋轉的動畫效果+ @keyframes time &#123;+ to &#123;+ transform: rotate(360deg);+ &#125;+ &#125; 修改 position 位置 此時可以開啟Chrome的開發者工具，先利用工具微調好 時針 的position位置，讓他旋轉效果有繞著時鐘的中心點旋轉後，再將程式碼複製貼回去。 1234567891011121314151617181920212223.hour &#123; width: $handwidth; height: 80px; background-color: blue; //將軸心變更到 中下方 的位置 transform-origin: 50% 80%; position: absolute;- top: 0;+ top: -49px; bottom: 0;- left: 0;+ left: -1px; right: 0; margin: auto; animation: time 25s infinite linear;&#125;//旋轉的動畫效果@keyframes time &#123; to &#123; transform: rotate(360deg); &#125;&#125; 範例See the Pen 練習-自刻時鐘 by Kanboo (@Kanboo) on CodePen.]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>練習</tag>
        <tag>時鐘</tag>
        <tag>clock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 - 語義元素]]></title>
    <url>%2F2017%2F12%2F18%2FHTML5-Semantics%2F</url>
    <content type="text"><![CDATA[重新認識HTML5的語義元素 常用元素&lt;header&gt;區塊標題，不要把它只用來取代 &lt;div class=”header”&gt;它也可以是文章的標題，一頁可以有好多個 &lt;header&gt;，&lt;header&gt; 裡面至少要有一個 h1~h6。 &lt;nav&gt;導覽列。裡面裝的東西應該只有 主要 的navigation links，不要把各種link都丟到&lt;nav&gt;裡面。舉例來說，footer裡面常常會有一排link，那個就不需要包進&lt;nav&gt;。 &lt;main&gt;一個頁面只有一個! 任何 global 都不能放在 main 裡面( e.g. &lt;header&gt; &lt;footer&gt; logo) &lt;section&gt;通常用來把一些相關的元素組合在一起，一般來說，裡面都會包含heading。如果這個區塊的內容可以分成幾個部分的話，那應該使用article。 1234&lt;section&gt; &lt;h2&gt;Section title&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec viverra nec nulla vitae mollis.&lt;/p&gt;&lt;/section&gt; &lt;article&gt;文章中可以脫離其他部分，獨立出來而又完整，甚至可以復用的一部分，通常有自己的標題，當article內嵌article時，裡外層的內容應該是相關的，比如一篇文章和它的留言，而section雖然也具有獨立表達內容的能力，但是對外層有一定的相依性，例如這篇文章中的一個章節。 123456789101112131415&lt;article&gt; &lt;header&gt; &lt;h3&gt; &lt;a href="/my-blog-post"&gt;My blog post&lt;/a&gt; &lt;/h3&gt; &lt;/header&gt; &lt;section&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec viverra nec nulla vitae mollis.&lt;/p&gt; &lt;/section&gt; &lt;footer&gt; &lt;small&gt; Posted on &lt;time datetime="2017-04-29T19:00"&gt;Apr 29&lt;/time&gt; in &lt;a href="/category/code"&gt;Code&lt;/a&gt; &lt;/small&gt; &lt;/footer&gt;&lt;/article&gt; &lt;aside&gt;通常用來包含一些和當前頁面內容有關的額外信息，比如廣告、個人資料信息或相關連結。 &lt;footer&gt;通常包含作者、版權信息或者相關鏈接等。 簡易分辦 &lt;section&gt;&lt;article&gt;&lt;article&gt;: 就算脫離了整體也是一個可以獨立存在、具有完整內容的區塊，例如這篇文章。&lt;section&gt;: 具有獨立表達內容的能力，但是對外層有一定的相依性，例如這篇文章中的一個章節。 下面是簡單的問題，讓我們決定要用 &lt;section&gt; / &lt;article&gt; / &lt;div&gt; 具有完整內容的區塊，而且可以出現在你的閱讀器內嗎? 是的話就是 &lt;article&gt; 跟主要內容是有相關並且列入 outline 裡不會奇怪的? 是的話就是 &lt;section&gt; 跟內容無關或只用來 styling 的? 是的話就是 &lt;div&gt; 建議的架構範例 參考文章结构性元素HTML5 Semantic ElementsHTML5 SemanticsSemantic in HTML5]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>語義架構</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-垂直置中的方法]]></title>
    <url>%2F2017%2F12%2F17%2FCSS-vertical-align%2F</url>
    <content type="text"><![CDATA[整理常用CSS常用的 垂直置中 的方法。 文字的垂直置中方法此方法適用 單行，因為是行高，所以會在行內元素的上下都加上行高的 1/2 ，如果多行，第二行與第一行的間距會變超大，就會導致沒有垂直置中的效果。 123456789// height 和 line-height 要一樣高.div0,.div1 &#123; width: 300px;+ height: 250px;+ line-height: 250px; text-align: center; border: 1px solid #000;&#125; See the Pen 垂直置中 - line-height by Kanboo (@Kanboo) on CodePen. calc &amp; transform使用 calc 動態計算的能力，讓要置中的 div 的 top 屬性，與上方的距離是「50% 的外框高度 + 50% 的 div 高度」，就可以做到垂直置中。 範例1：設定top：50%，再扣掉 div 的 高度/2 方法1：top: calc( 50% - (高度/2) ) 方法2：top: 50%; margin-top: -(高度/2); 方法3：top: 50%; transform: translateY(-50%); 自行計算50%的div高度 1234567891011121314151617181920212223242526272829.redbox &#123; background: #c00; float: left;+ position: relative; //要宣告position，才能使用 top、left width: 30px;- //計算方法1+ height: 30px;+ top: calc(50% - 15px); //高：30/2=15 &#125; .greenbox &#123; background: #0c0; float: left; position: relative; width: 30px;- //計算方法2+ height: 80px;+ top: 50%;+ margin-top: -40px; //高：80/2=40 &#125; .bluebox &#123; background: #00f; float: left; position: relative; width: 30px; height: 50px;- //計算方法3+ top:50%;+ transform: translateY(-50%); &#125; See the Pen 垂直置中 - calc 動態計算1 by Kanboo (@Kanboo) on CodePen. 範例2：將三個div設定寬高各30px，將滑鼠移到黑框內，可觀看效果。 See the Pen 垂直置中 - calc 動態計算2 by Kanboo (@Kanboo) on CodePen. 絕對定位利用絕對位置來指定，要將 上下 的數值都設為 0，再搭配一個 margin:auto，就可以辦到垂直置中。 邏輯：這個方法同時設定top和bottom為0，使得這個div完全不可能符合，最後再透過margin這個指令，讓它達到垂直置中的效果 123456789101112131415161718 .redbox &#123;- // 垂直置中 background: #c00; position: absolute; //要宣告，才能使用 top、left+ top: 0;+ bottom: 0;+ margin: auto; &#125; .bluebox &#123;- // 垂直置中 + 水平置中 background: blue; position: absolute; //要宣告，才能使用 top、left top: 0; bottom: 0;+ left: 0;+ right: 0; margin: auto; &#125; See the Pen 垂直置中 - 絕對定位 by Kanboo (@Kanboo) on CodePen. FlexboxCSS3 最威的盒子模型：Flexbox，使用 align-items 或 align-content 的屬性， 輕輕鬆鬆就可以做到垂直置中的效果喔，Bootstrap 4 也有用喔。 1234567891011121314.div0 &#123;+ display: flex;+ align-items: center;+ justify-content: center; width: 150px; height: 150px; border: 1px solid #000; .redbox &#123; width: 30px; height: 30px; background: #c00; &#125;&#125; See the Pen 垂直置中 - Flexbox by Kanboo (@Kanboo) on CodePen. 參考文章CSS 垂直置中的七個方法CSS垂直置中的方法]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>vertical-align</tag>
        <tag>垂直置中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-transform 2D]]></title>
    <url>%2F2017%2F12%2F16%2FCSS-transform-2D%2F</url>
    <content type="text"><![CDATA[利用 transform 將元素加入 位移、旋轉、縮放和傾斜 的效果。 基本語法transform 屬性可以設定 一個 或 多個 的參數，若設定多個參數的話，中間的區隔使用 空白 即可。 123transform: 第一個參數 第二個參數 ...transform: translate(100px) rotate(20deg); 常用的參數如下列 位移 - translate()、translateX()、translateY() 旋轉 - rotate() 縮放 - scale()、scaleX()、scaleY() 傾斜 - skew()、skewX()、skewY() 位移translate語法 若設定二個，用 逗號 區隔 translate(tx) → 若僅設定一個參數，代表只 位移X translate(tx, ty) 設定 X軸 位移 translateX() 設定 Y軸 位移 translateY() 範例 位移 X軸 50px,位移 Y軸 50px 12345.moved &#123; transform: translate( 50px, 50px); // 上下二段語法，結果一樣 transform: translateX( 50px) translateY( 50px);&#125; See the Pen transform-translate by Kanboo (@Kanboo) on CodePen. 旋轉rotate語法 rotate( 旋轉角度 ) =&gt; rotate( 20deg ) 旋轉30度角 = 30deg旋轉90度角 = 90deg 範例 旋轉45度角 123.rotate &#123; transform: rotate( 45deg);&#125; See the Pen transform-rotate by Kanboo (@Kanboo) on CodePen. 縮放scale語法 參數預設大小為 1 ，若設定 小於 1 就是 縮小，大於 1 就是 放大。 若設定二個，用 逗號 區隔 scale(sx) → 若僅設定一個參數，代表同時縮放 X 和 Y scale(sx, sy) 縮放 X軸 scaleX() 縮放 Y軸 scaleY() 範例 縮小至0.7倍 12345.scaled &#123; transform: scale(0.7); // 上下二段語法，結果一樣 transform: scaleX(0.7) scaleY(0.7);&#125; See the Pen transform-scale by Kanboo (@Kanboo) on CodePen. 傾斜skew語法 若設定二個，用 逗號 區隔 skew(ax) → 若僅設定一個參數，代表只 傾斜X skew(ax, ay) 傾斜 X軸 skewX() 傾斜 Y軸 skewY() 範例 skewed1 傾斜 X , skewed1 傾斜 X 和 Y 1234567891011 .skewed1 &#123; transform: skew(10deg); // 等同 skewX(10deg) transform: skewX(10deg);&#125;.skewed2 &#123; transform: skew(10deg, 10deg); // 等同 skewX(10deg) skewY(10deg) transform: skewX(10deg) skewY(10deg);&#125; See the Pen transform-skew by Kanboo (@Kanboo) on CodePen.]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>transform</tag>
        <tag>2D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-transform-origin 軸心]]></title>
    <url>%2F2017%2F12%2F15%2FCSS-transform-origin%2F</url>
    <content type="text"><![CDATA[在學習 transform 之前，先了解 transform-origin 軸心 怎麼變化？ 說明在撰寫CSS transform 時，預設的 軸心 是在Box的正中央位置(如下圖)， 所以要製作一些比較特別的效果的話，如：時間、開門 …等 就利用變更軸心的位置，再配合 transform 來達成。 1transform-origin: x y; 範例：利用 transform: rotate(90deg) 旋轉 90度，呈現因 軸心位置不同 ，而旋轉的結果有何不一樣。 C 軸心： 正中間(預設) F 軸心： 右下角 E 軸心： 左邊中間 See the Pen transform-origin 更改軸心 by Kanboo (@Kanboo) on CodePen. 其他範例teaching transform-originTransform Origin Examples 參考文章CSS沒有極限 - CSS transform-origin]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>transform</tag>
        <tag>transform-origin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Browsersync]]></title>
    <url>%2F2017%2F12%2F15%2FHexo-Browsersync%2F</url>
    <content type="text"><![CDATA[實現撰寫文章時，可自動刷新頁面預覽，不用再手動F5了。 前言實現刷新功能，需要完成的事情有： 安裝套件 Hexo-Browsersync 解決文章太長-渲染失敗Bug 執行 hexo server，即可。 操作步骤1.安裝套件1$ npm install hexo-browsersync --save 2.修正Bug 安裝 hexo-renderer-jade 插件 1$ npm install hexo-renderer-jade --save 在你的 node_modules 文件夾裡找到 hexo-renderer-pug 的文件夾，然後將裡面 lib/renderer.js 的其中一行代碼 註解 掉： 1//pugRenderer.compile = pugCompile; 新增 _config.yml 的設定。 參考：issue 新增路徑：~/blog/_config.yml12server: compress: true #開啟壓縮 3.執行1$ hexo s 啟動 hexo server 後，你會看到下列的訊息 12345678INFO Start processing[Browsersync] Access URLs: -------------------------------------- UI: http://localhost:3001 -------------------------------------- UI External: http://192.168.1.135:3001 --------------------------------------INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. port:3001 可修改 browsersync 相關設定。port:4000 Blog的預覽畫面。 參考文章Hexo 实现实时预览编辑Hexo不重新生成也可预览修正渲染不全問題]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Browsersync</tag>
        <tag>頁面自動刷新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-複製功能]]></title>
    <url>%2F2017%2F12%2F15%2FHexo-clipboard%2F</url>
    <content type="text"><![CDATA[實現程式碼區塊，可進行 Ctrl + C 前言實現複製功能，需要完成的事情有： 下载插件clipboard.js 插入JavaScript 插入主题中 操作步骤1.下載插件clipboard.js將下載好的 clipboard.js 放置下列路徑， 目錄zclip 為此次 新增 。 ~blog/themes/next/source/lib/zclip/clipboard.min.js clipboard.js下載位址：GitHub 2.新增JavaScript新增 文件 custom.js ，目錄如下： 新增JS文件位置：~/blog/themes/next/source/js/src/custom.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//此函数用于创建复制按钮function createCopyBtns() &#123; var $codeArea = $("figure table"); //查看页面是否具有代码区域，没有代码块则不创建 复制按钮 if ($codeArea.length &gt; 0) &#123; //复制成功后将要干的事情 function changeToSuccess(item) &#123; $imgOK = $("#copyBtn").find("#imgSuccess"); if ($imgOK.css("display") == "none") &#123; $imgOK.css(&#123; opacity: 0, display: "block" &#125;); $imgOK.animate(&#123; opacity: 1 &#125;, 1000); setTimeout(function() &#123; $imgOK.animate(&#123; opacity: 0 &#125;, 2000); &#125;, 2000); setTimeout(function() &#123; $imgOK.css("display", "none"); &#125;, 4000); &#125;; &#125;; //创建 全局复制按钮，仅有一组。包含：复制按钮，复制成功响应按钮 //值得注意的是：1.按钮默认隐藏，2.位置使用绝对位置 position: absolute; (position: fixed 也可以，需要修改代码) $(".post-body").before('&lt;div id="copyBtn" style="opacity: 0; position: absolute;top:0px;display: none;line-height: 1; font-size:1.5em"&gt;&lt;span id="imgCopy" &gt;&lt;i class="fa fa-paste fa-fw"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span id="imgSuccess" style="display: none;"&gt;&lt;i class="fa fa-check-circle fa-fw" aria-hidden="true"&gt;&lt;/i&gt;&lt;/span&gt;'); //创建 复制 插件，绑定单机时间到 指定元素，支持JQuery var clipboard = new Clipboard('#copyBtn', &#123; target: function() &#123; //返回需要复制的元素内容 return document.querySelector("[copyFlag]"); &#125;, isSupported: function() &#123; //支持复制内容 return document.querySelector("[copyFlag]"); &#125; &#125;); //复制成功事件绑定 clipboard.on('success', function(e) &#123; //清除内容被选择状态 e.clearSelection(); changeToSuccess(e); &#125;); //复制失败绑定事件 clipboard.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger); &#125;); //鼠标 在复制按钮上滑动和离开后渐变显示/隐藏效果 $("#copyBtn").hover( function() &#123; $(this).stop(); $(this).css("opacity", 1); &#125;, function() &#123; $(this).animate(&#123; opacity: 0 &#125;, 2000); &#125; ); &#125;&#125;//感应鼠标是否在代码区$("figure").hover( function() &#123; //-------鼠标活动在代码块内 //移除之前含有复制标志代码块的 copyFlag $("[copyFlag]").removeAttr("copyFlag"); //在新的（当前鼠标所在代码区）代码块插入标志：copyFlag $(this).find(".code").attr("copyFlag", 1); //获取复制按钮 $copyBtn = $("#copyBtn"); if ($copyBtn.lenght != 0) &#123; //获取到按钮的前提下进行一下操作 //停止按钮动画效果 //设置为 显示状态 //修改 复制按钮 位置到 当前代码块开始部位 //设置代码块 左侧位置 $copyBtn.stop(); $copyBtn.css("opacity", 0.8); $copyBtn.css("display", "block"); $copyBtn.css("top", parseInt($copyBtn.css("top")) + $(this).offset().top - $copyBtn.offset().top + 2); // $copyBtn.css("right", -$copyBtn.width() - 3); $copyBtn.css("right", 0); &#125; &#125;, function() &#123; //-------鼠标离开代码块 //设置复制按钮可见度 2秒内到 0 $("#copyBtn").animate(&#123; opacity: 0 &#125;, 2000); &#125;);//页面载入完成后，创建复制按钮$(document).ready(function() &#123; createCopyBtns();&#125;); 3.更新主题新增 文件custom.swig，目錄如下： 新增位置：~/blog/themes/next/layout/_custom/custom .swig12&lt; script type = "text/javascript" src = "/lib/zclip/clipboard.min.js" &gt;&lt;/ script &gt; &lt; script type = "text/javascript" src = "/js/src/custom.js" &gt;&lt;/ script &gt; 修改 文件_layout.swig，目錄如下： 修改位置：~/blog/themes/next/layout/ _layout .swig12345678910111213141516&lt;!doctype html&gt;...&lt; html class = "&#123;&#123; html_class | lower &#125;&#125;" lang = "&#123;&#123; config.language &#125;&#125;" &gt;&lt; head &gt; ...&lt;/ head &gt;&lt; body itemscope itemtype = "http://schema.org/WebPage" lang = "&#123;&#123; page.lang || page.language || config.language &#125;&#125;" &gt; ... ... &#123;% include '_third-party/mathjax.swig' %&#125; &#123;% include '_third-party/scroll-cookie.swig' %&#125; &#123;% include '_third-party/exturl.swig' %&#125;+ &#123;% include '_custom/custom.swig' %&#125;&lt;/ body &gt;&lt;/ html &gt; 在文件中前一行插入文件引用，如第15行效果。1&#123;% include &apos;_custom/custom.swig&apos; %&#125; 參考文章HEXO優化之（二）—-添加複制功能]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>clipboard</tag>
        <tag>複製</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-留言版]]></title>
    <url>%2F2017%2F12%2F13%2FHexo-Comment%2F</url>
    <content type="text"><![CDATA[前言 新增 Hexo 的留言版，需要完成的事情有： 註冊 Disqus 的帳號 新建 Disqus 的 website 配置 Hexo 操作步骤1.註冊 Disqus 的帳號Disqus網址：https://disqus.com/ 打開鏈接後， 可以直接用Facebook，Twitter以及Google 登錄，也可以用郵箱註冊後登錄。 2.建立 Disqus website 點擊 GET STARTED 開始建立 website 點擊下面 I want to install Disqus on my site 填寫 Website Name，這是 短名稱，用於和 Hexo連結的 Key值。 直接點擊 Configure Disqus 填寫 Website URL ，這是你 Blog的網址 建立完成畫面 3.配置 Hexo主題配置主題 下面的 config.yml 文件，路徑： ~blog/themes/next/_config.yml 將 Disqus下的 enable 設定為 true 。 同時填寫您的 shortname(短名稱)。 count 用於指定是否顯示評論數量。 12345# Disqusdisqus: enable: true shortname: kanbooBlog count: true 上述步驟設置完成後，更新Blog 123$ hexo clean$ hexo g$ hexo d 參考資料Hexo 集成Disqus 評論Hexo搭建博客系列：（六）Hexo添加Disqus評論Next-评论系统]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Comment</tag>
        <tag>Disqus</tag>
        <tag>留言版</tag>
        <tag>評論</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-文章置頂]]></title>
    <url>%2F2017%2F12%2F13%2FHexo-Topfeatures%2F</url>
    <content type="text"><![CDATA[前言解決Hexo置頂問題，需要完成的事情有： 將目前 node_modules/hexo-generator-index/lib/generator.js 程式碼替換 在需要置頂的文章的前事中添加頂值，值越大越置頂。 操作步骤 替換 generator.js 程式碼 12345678910111213141516171819202122232425'use strict';var pagination = require('hexo-pagination');module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if (a.top &amp;&amp; b.top) &#123; // 兩篇文章top都有定義 if (a.top == b.top) return b.date - a.date; // 若top值一样則按照文章日期降序排 else return b.top - a.top; // 否則按照top值降序排 &#125; else if (a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定義，那麼将有top的排在前面 return -1; &#125; else if (!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都沒定義按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 若找不到 node_modules/hexo-generator-index/lib/generator.js 的話，請先安裝 hexo-generator-index。 指令： npm i --save hexo-generator-index 在需要置顶的文章的中添加 top 值，值越大越置顶。 123title: Hexo-文章置頂date: 2017-12-13 09:29:37top: 100 參考資料hexo置顶功能Hexo文章置顶]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Top</tag>
        <tag>置頂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-transition 轉場效果]]></title>
    <url>%2F2017%2F12%2F12%2FCSS-Transition%2F</url>
    <content type="text"><![CDATA[轉場是從 A 狀態，轉變成 B 狀態，中間的過程，就叫轉場，在 CSS 中叫做 transition。 語法1234567891011transition: property duration timing-function delay;transition: 套用的屬性 花費時間 時間速率 等待時間;transition: all 2s ease-out 1s;// 等同於：transition-property: all; // default: alltransition-duration: 2s; // default: 0；2s 表示 2 秒；2ms 表示 2 毫秒。transition-timing-function: ease-out;transition-delay: 1s; // 開始進行轉場效果之前，所要等待的時間。 transition-timing-function 時間速率 See the Pen transition 各種速率 by Kanboo (@Kanboo) on CodePen. 範例範例 1：hoverSee the Pen Transition - hover by Kanboo (@Kanboo) on CodePen. 範例 2：設定Two CSS propertiesSee the Pen Transition - 設定Two CSS properties by Kanboo (@Kanboo) on CodePen. 特別的點：12//設定二個 CSS屬性，設定不同 時間、速率..等transition: background .2s linear, border-radius 1s ease-in 1s; 上面案例，特別於在 :hover 時，有改變 背景色 和 圓角 效果，不過在 transition 的設定，分別針對 二個屬性設定不同的時間、速率…等 參考資料[CSS][Transition] 轉場效果 CSS3轉場效果(transitions) CSS transition 各種速率]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>transition</tag>
        <tag>動畫</tag>
        <tag>轉場效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-切版練習]]></title>
    <url>%2F2017%2F12%2F11%2FCSS-RWDlayout%2F</url>
    <content type="text"><![CDATA[紀錄練習切版時，遇到卡卡的問題 icon 利用 position 位移示意圖 重點 row 的 position 設置 relative; icon 的 position 設置 absolute; 移動 icon 的位置， top 、 left 將 icon 移進去在 input 時，input 需增加 左邊padding，保留位置給 icon。 HTML 程式碼123456&lt;div class="row"&gt; &lt;label for="email"&gt;Email Address*&lt;/label&gt; &lt;label for="email" class="icon"&gt;&lt;i class="fa fa-envelope-o" aria-hidden="true"&gt;&lt;/i&gt;&lt;/label&gt; &lt;input type="email" name="email" id="email"&gt;&lt;/div&gt; SCSS 程式碼12345678910111213141516171819//記得input的左邊要留padding,保留一些位置給iconinput &#123; padding: 6px 0 6px 28px;&#125;//位移 icon 至 input 裡.row &#123; position: relative; .icon &#123; position: absolute; top: 26px; left: 9px; font-size: 16px; z-index: 10; color: rgba(61, 17, 1, 0.5); &#125;&#125; codepen範例: LoginForm 緞帶效果 重點 .tag-wrap 為 藍色框線 .tag 為 紅色框線(熱賣) .tag-wrap 的 position 設置 absolute ，並且位移要超出原有的框架，才能做出緞帶效果; 新增 .tag 的 width、background-color…等屬性 利用 transform ，位移翻轉 .tag 移動好 .tag 後，在 .tag-wrap 新增 overflow: hidden;， 將多餘的部份隱藏 利用 .tag 的偽元素 :before、:after，新增 小三角 ▲ html 程式碼123456789101112&lt;div class="card"&gt; &lt;!-- 不影響結構 --&gt; &lt;div class="tag-wrap"&gt; &lt;div class="tag"&gt; 熱賣!! &lt;/div&gt; &lt;/div&gt; &lt;!-- 主要結構 --&gt; &lt;div class="card-block"&gt; &lt;/div&gt;&lt;/div&gt; SCSS 程式碼1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.card &#123; width: 230px; height: 200px; position: relative;&#125;//緞帶效果.tag-wrap &#123; $p: 5px; $size: 80px; position: absolute; //位移要超出原有的框架，才能做出緞帶效果 top: -$p; right: -$p; //超出的部份隱藏 overflow: hidden; width: $size * 2; height: $size * 2; //查看位置 border: 1px solid blue; .tag &#123; position: relative; width: $size*2; background-color: orange; padding-top: 0.25rem; padding-bottom: 0.25rem; text-align: center; margin-top: -$p * 2; color: white; //rotate為旋轉、translate為移動、skew為傾斜、scale為縮放 transform: translateX(50%) rotate(45deg) translateY(150%); //查看位置 border: 1px solid red; &amp;:before &#123; content: ""; position: absolute; //利用 加粗邊框 + 邊框上方顏色，達到小三角的效果 border: $p solid transparent; border-top-color: darken(orange, 15%); bottom: -10px; left: 6px; &#125; &amp;:after &#123; content: ""; position: absolute; //利用 加粗邊框 + 邊框上方顏色，達到小三角的效果 border: $p solid transparent; border-top-color: darken(orange, 15%); bottom: -10px; right: 14px; &#125; &#125;&#125; codepen範例: CSS-緞帶效果(乾淨版本)codepen範例: CSS-緞帶效果 觀念補充六角範例從 Sketch 設計到 CSS 切版 本日範例：https://codepen.io/Wcc723/pen/zEYXdN 本日設計參考：https://codepen.io/Wcc723/pen/pWzxXO transform CSS 程式碼123456789101112/* rotate為旋轉skew為傾斜scale為縮放translate為移動 *//* 範例1：移動X軸 → 旋轉 → 移動Y軸 */transform: translateX(150%) rotate(45deg) translateY(50%);/* 範例2：旋轉 → 移動X軸 → 移動Y軸 */transform: rotate(45deg) translateX(150%) translateY(50%); 上列 CSS程式碼 「範例1 、 範例2」，雖然同樣都做了「移動X軸、移動Y軸、旋轉」的動作，但是因為 執行順序 不同，所以二個範例呈現出來的結果也會不一樣。 上述程式碼範例： transform_執行順序 transform基本介紹1.CSS transform 概觀2.CSS transform 軸線的謊言3.CSS transform-origin4.CSS transform-3D的透視 SCSS顏色函數範例123456789.box&#123; background: rgba(#000,.5); //變半透明 background: invert(#f00); //變反向色彩 background: lighten(#06C, 30%); //變亮 background: darken(#06C,15%); //變暗 background: saturate(#06C,50%); //提高飽和度 background: desaturate(#06C,50%); //降低飽和度 background: grayscale(#06C); //灰階&#125; SCSS相關 linear-gradient讓顏色有漸層效果 CSS 程式碼1background-image: linear-gradient(165deg, white, white 50%, $bg-color 50%); background: linear-gradient( 方向, 第一個顏色, 第二個顏色, … ); 背景色 — 线性渐变背景色 — 漸層效果 繪製幾何圖形(支援度不高) 1clip-path: polygon(0 0, 280px 0, 370px 100%, 0% 100%); CSS clip-path 生成器利用CSS繪製更多形狀不可思议的CSS之CLIP-PATH]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>transform</tag>
        <tag>translateX</tag>
        <tag>rotate</tag>
        <tag>translateY</tag>
        <tag>SCSS</tag>
        <tag>linear-gradient</tag>
        <tag>clip-path</tag>
        <tag>position</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS - 常用筆記]]></title>
    <url>%2F2017%2F11%2F13%2FCSS-ForgetfulNotes%2F</url>
    <content type="text"><![CDATA[背景圖123456789101112131415/* 圖片滿版 */.img-cover &#123; background-image: url(./bg.png); background-position: center; background-size: cover; background-repeat: no-repeat;&#125;/* 圖片居中 */.img-contain &#123; background-image: url(./bg.png); background-position: center; background-size: contain; background-repeat: no-repeat;&#125; 其他背景圖範例：固定、滿版、置中background-attachment是背景固定模式的屬性註：作为背景的圖片是撑不起元素的，須額外需要给div新增「寬、高」 圓角123456div.circle&#123; width:80px; height:80px; border-radius:50%; background-color:blue;&#125; 2個重點： 圓的直徑，長寬 一定要等長 border-radius:50% 參考網址： 圓角詳解、CSS3技巧之形狀 區塊陰影、文字立體感12345678/* 外層的陰影 */box-shadow: 1px 1px 5px rgba(0,0,0,0.3);/* 內層的陰影(多加 inset) */box-shadow: inset 1px 1px 5px rgba(0,0,0,0.3);/* 文字的陰影 */text-shadow: 1px 1px 1px rgba(0,0,0,0.5); 參考網址： 玩转box-shadow、文字立體感 a 連結取消 a 連結下底線123a &#123; text-decoration: none;&#125; :hover 移至 a 連結的效果123a:hover &#123; border-bottom: 3px solid #00cc99;&#125; 註：a 連結 預設display為inline，但為了讓 User有更好的操作體驗，會變更成 block，增加「寬、高」範圍，讓 User較易點擊到目標連結。 斷點123456@media (max-width: 768px) &#123; //iPad&#125;@media (max-width: 767px) &#123; //iPhone&#125; 新單位：高度vh、寬度vwvh 代表的是view height，也就是螢幕可視範圍高度的百分比；vw 表示的是view width，也就是螢幕可是範圍寬度的百分比。 ul ol list-style取消樣式ol,ul {list-style: none;} 設定樣式list-style: circle; 其他樣式參考：CSS list-style 指定滑鼠游標的型態cursor: pointer; /*手型，表示超連結*/ 參考網址： 游標的型態]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>筆記</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Search]]></title>
    <url>%2F2017%2F10%2F18%2FHexo-Search%2F</url>
    <content type="text"><![CDATA[前言在新增 Hexo 的 Local Search 時，參考下列的連結文章，跟著步驟安裝及設定即可，不過剛裝好後，發現搜尋功能無法正常使用，後來有查到原因，在此紀錄一下Debug過程。 Local SearchHexo博客添加站內搜索 安裝順序安裝hexo-generator-searchdb在站點的根目錄下執行以下命令 1$ npm install hexo-generator-searchdb --save 編輯站點配置文件(Hexo)新增以下內容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 編輯主題配置文件(Next)啟用本地搜索功能： 123# Local searchlocal_search: enable: true 問題紀錄 點了搜尋後，畫面一直轉圈圈沒停止，查看Console也沒出現Error 查看XHR，目前我有10篇文章，卻只產生三筆entry，且其中一筆entry的content內容沒產生 並且有此錯誤訊息 後來針對有問題那篇文章複製內容，貼到 notepad++ 看看，發現有一亂碼，將亂碼刪除後，Local Search就可以正常運作了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC-讓終端機變好看]]></title>
    <url>%2F2017%2F10%2F15%2FMAC-iTerm2-Zsh%2F</url>
    <content type="text"><![CDATA[前言在安裝 MAC終端機高亮的過程，主要是參考下列的文章，跟著步驟安裝及設定即可，不過安裝過程中，還是有遇到卡卡的地方，所以特別記一下 卡卡的歷程。 為 MAC 的 Terminal 上色 - 透過 iTerm 2 和 Oh My Zsh 高亮你的終端機 讓 MAC 終端機變好看 iterm2-solarized 原文 問題紀錄zsh指令失效安裝完zsh，在使用相關shell命令，出現了zsh: command not found Nodezsh: command not found: hexo等一系列error zsh 和bash 的環境變量bash的環境變量是.bash_profile文件。zsh的環境變量是.zshrc文件。 字面意思是相關命令沒有沒有找到，其實就是bash shell 以及 zsh shell是 兩種讀取系統環境變量，簡單來說就是說 node、Hexo…等套件 是在使用 bash 時候，安裝好的，所以會設定在 .bash_profile裡，後來改使用 zsh shell 的時候，你並沒有把相關的環境變量的配置設置到 .zshrc 中（功能上類似bash 的.bash_profile），所以 .zshrc 沒有配置相關環境變量設置，就把bash 中.bash_profile 全部環境變量加入 .zshrc 就好。 加入方法：123456#打開 zsh 的設定檔open ~/.zshrc# 最后一行加入下面指令# 解決OSX使用oh-my-zsh後.bash_profile自定義失效source ~/.bash_profile zsh: command not foundzsh: command not found解决OSX使用oh-my-zsh后.bash_profile自定义失效 安裝字型原先是跟著最上面文章教學，安裝 字型(Meslo LG M Regular for Powerline)，再修改相關設定後，此字型在 iTerm 上，顯示箭頭是正常的，不過在VScode上面，顯示 箭頭 卻還是有亂碼，所以去Google一下，結果如下 先安裝 字型 1234# 安裝字型$ git clone git://github.com/powerline/fonts ~/.powerline_fonts$ cd ~/.powerline_fonts$ ./install.sh iTerm設定 字型iTerm –&gt; Preferences –&gt; Profiles –&gt; Text –&gt; Change Font推薦使用 Source Code Pro (Adobe的）與 Ubuntu Mono，這兩個字型都相當適合寫程式使用。 VSCode設定 字型在設定參數裡，新增下列二行 12"terminal.integrated.fontFamily": "Source Code Pro for Powerline","terminal.integrated.fontSize": 14 安裝Powerline專屬字型美化你的終端機]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>iTerm2</tag>
        <tag>ZSH</tag>
        <tag>終端機</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-備份]]></title>
    <url>%2F2017%2F10%2F14%2FHexo-backup%2F</url>
    <content type="text"><![CDATA[前言簡單來說，實現備份方法就是利用 二個分支線 個別放我們要的檔案，一個分支線 放 發佈的文章，另一個分支線 放 備份的檔案， master: 利用 hexo deploy 直接推送，存放由 hexo 產生的靜態頁面 hexo: 利用 git command 推送，存放部落格原始碼 由於 Github Page 本身限制頁面主要分支必須為 master，因此考慮增設分支 hexo 用以存放部落格原始碼。 重點提醒當環境都設定好以後，日後不管是在哪一台電腦上撰寫文件、發佈文件、備份檔案，都是在 hexo 分支上hexo 分支上hexo 分支上 因為很重要，所以說三次。 初次備份環境建立此動作僅需在第一台撰寫Blog電腦上執行即可，如果日後換新電腦或要在不同台電腦撰寫Blog的話，請參考下面的 更換環境 的操作。 實作步驟 新建 hexo 分支 1$ git branch hexo 將檔案備份至 hexo 分支 1$ git push origin hexo github上設定 hexo 為 默認分支 日後不同電腦clone下來時，不用再特別切換 hexo 分支 確認 配置hexo deploy 的参数 確認 branch參數一定是設定 master 分支,因為日後操作都在 hexo 分支上， 至於要發佈文件的話，就靠指令 hexo d 幫我們建立發佈的文章。 1234deploy:type: gitrepository: https://github.com/用戶名/用戶名.github.io.gitbranch: master 更換環境執行步驟如果是第一次在新電腦的話，請先參考下列動作，先建立Blog的環境。 12345678910111213#1.克隆到本地$ git clone https://github.com/用户名/用户名.github.io.git Kanbooblog#2.切換到blog目錄;$ cd blog目錄#3.確認目前分支是否為hexo，若不是，則切換備份的分支分稱(hexo)$ git checkout Hexo#4.安装各种npm包$ npm install -g hexo-cli$ npm install$ npm install hexo-deployer-git --save 可能遇到的問題1.warning: LF will be replaced by CRLF在 Windows 中廣泛使用來標識一行的結束。而在Linux / UNIX系統中只有換行符。也就是說在Windows中的換行符為CRLF，而在linux的下的換行符為：LF，當執行 git指令 時，系統提示：LF將被轉換成CRLF。 解決方法： 1$ git config --global core.autocrlf false git提示警告：LF將被CRLF替換Hexo Git部署警告”warning： LF will be replaced by CRLF”的去除方法 部落格更新與部署新文章日後在不同電腦上要新增文件的話，就重覆下列的動作即可。 拉取遠端版本庫上的更新內容 1$ git pull 修改部落格配置或撰寫新文章 添加變更並推送 12345678910$ hexo clean# 產生發佈的文件$ hexo g # 發佈至github-master$ hexo d # 備份至github-Hexo$ git add .$ git commit -m "message"$ git push origin hexo 參考網站Hexo利用Github分支在不同电脑上写博客 實現不同電腦上 Hexo 部落格的同步 hexo备份小技巧]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>備份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-環境建置]]></title>
    <url>%2F2017%2F10%2F14%2FHexo-Create%2F</url>
    <content type="text"><![CDATA[前言建立Hexo環境，需要完成的事情有： 建置github空間 安裝 Node.js（如果還沒有的話） 安裝 Hexo 初始化 Hexo，並在目標資料夾建立所需檔案 安裝 hexo-deployer-git (很重要) 在_config.yml 中設定 Git 等資訊 空間：GitHub因為Blog需要上傳至雲端，所以這裡使用github的免費空間。 創建github page倉庫的名字 要和 你的帳號 一樣，如：用戶名.github.io 進入github page項目設置頁面選擇Settings 創建一個默認的頁面直接選擇Launch automatic -&gt; Continue to layouts page generator -&gt; Publish page,其他東西都不用修改。 查看效果至此，你的github page已經創建完成，你可以訪問自己的站點了。如：https://用戶名.github.io/ Hexo安裝安裝 Hexo 相當簡單；然而，在安裝前您必須先檢查下列您的電腦是否已經安裝下列軟體： Node.js Git 若您的電腦已經安裝上述的必備軟體，那麼恭喜您！只需要透過 npm 即可完成 Hexo 的安裝。 1$ npm install -g hexo-cli 建立123$ hexo init yourname # ( 初始化新的 Hexo )$ cd yourname # ( 進入您剛剛建立的 Hexo 資料夾當中 )$ npm install #（ 安裝 Hexo ) yourname 就是指在電腦裡的檔案名稱，可以隨意取，例如「myhexoblog」 設定進入您 Hexo 主目錄下之後，先找到 _config.yml 這個檔案！ 123456title: Kanboo Notes (輸入您的標題)subtitle: 健忘筆記本 （輸入您的至理名言）description:(輸入您的網站描述)author: Kanboo （輸入您的姓名）language: zh-TW （輸入您所使用的語言）timezone: (留空可以使用系統時間！) 同樣 _config.yml 這個檔案底下，找到 deploy 設定github 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/用戶名/用戶名.github.io.git branch: master 用戶名 就是指你自己的github帳號，記得改對，然後按存檔。 撰寫文件及常用指令撰寫文件至於內文採用的 Markdown 格式不難學，只需要記幾個常用的指令，遇到不懂的再上網查就好。 123456789斜體： *斜體* 粗體： **粗體** 粗斜體： ***粗斜體*** 刪除線：~~刪除~~ 引言： &gt; 引言 章節： # 章節 次級章節（以此類推）： ## 次級章節 表格（註1）：|一行|一行|疊| 插入超連結： [超連結文字](網址) 插入外部圖片： ![圖片描述](圖片網址) Markdown文件Markdown CheatsheetMarkdown 寫表格 指令1234567$ hexo new "postName" #新建文章$ hexo clean #清除快取$ hexo generate #生成靜態頁面至public目錄$ hexo server #開啟預覽訪問端口（默認端口4000，'ctrl + c'關閉server）$ hexo deploy #將.deploy目錄部署到GitHub$ hexo help #查看幫助$ hexo version #查看Hexo的版本 指令簡寫 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 更換Blog主題(NexT)主要完成的步驟如下： 安裝 Blog主題(NexT) _config.yml 修改theme:NexT NexT細項功能設定 如果啟用 分類、標籤 的話，並不會自動幫你建立，可參考下列協助產生 1234新建分類、標籤、關於頁面：$ hexo new page ‘categories’$ hexo new page ‘tags’$ hexo new page ‘about’ hexo-generator-category 產生分類頁$ npm install hexo-generator-category --save hexo-generator-tag 產生標籤頁$ npm install hexo-generator-tag --save 參考網站Hexo搭建GitHub博客 系列文章Github Pages + Hexo搭建博客當個部落客McK-Note Hexo 官網NexT 官網]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LiveCoding-切個垂直時間軸]]></title>
    <url>%2F2017%2F10%2F12%2Flivecoding-timeline%2F</url>
    <content type="text"><![CDATA[教學來源Youtube：直播 - 切個垂直時間軸 GitHub 分支：https://goo.gl/VEbWkm 參考版型：https://goo.gl/rqjErS 螢幕吸顏色 Sip：https://goo.gl/Vh6YIo LiveCoding 官方網站：https://goo.gl/weYx5q LiveCoding Youtube 頻道：https://goo.gl/Hyih3u LiveCoding 臉書粉絲專頁：https://goo.gl/yhDg0l 排版小技巧紀錄 切版過程中，可常利用新增「外層的紅框線」，先確認位置是否正確，事後再拿掉。 border: 1px solid rgba(255, 0, 0, .3) CSS之calc可做運算式運算 calc(50% — 10px / 2) z-index z-index 記得搭配 position : relative 、 absolute 使用 z-index 數字越大的在越上面，反之則在越下面 行高 1234H3&#123; height: 45px; line-height: 45px;&#125; 深入 CSS 之 line-height 應用 時間紀錄點頭像(10分開始) 頭像+白色圓外框+黑色的陰影(12分30秒) 時間軸的 垂直中線 位置的偏移(14分30秒開始) 按鈕(載入更多)(28分19秒開始) 時間軸的icon(38分30秒開始) 資訊卡之小箭頭(1時3分30秒) 使用 CSS Arrow Please，再修改部份css 將 資訊卡區塊 開始變 左右 排版(1時7分 開始) 可用的方法有： 針對左右給不同的 class 用 js 控制 用 nth-child 12345678910/* content底下的第一子元素是:&lt;i&gt;第二個是&lt;button&gt;第三個是&lt;div 資訊卡&gt; *//* 從content底下的子元素，從第3個元素開始並每次加2的倍數(奇數) */:nth-child(2n + 3)/* 從content底下的子元素，從第4個元素開始並每次加2的倍數(偶數) */:nth-child(2n + 4) 用 js 動態新增資訊卡(1h 15分 開始) 123456789101112// 在div底下// 新增img HTML$('&lt;div /&gt;').append ($('&lt;img /&gt;')// 新增 info 的Class$('&lt;div /&gt;').addClass ('info')// 新增 data-time 屬性$('&lt;div /&gt;').attr ('data-time', "2017-10-10")// 新增 純文字$('&lt;div /&gt;').text('我是單純顯示的文字') 資訊卡之圖片(1時28分 開始) 123456789101112131415.content &#123; content屬性設定 .img &#123; img屬性設定 +h3 &#123; h3屬性設定-特例 &#125; &#125; .h3 &#123; h3屬性設定 &#125;&#125; 注意： img 底下有加一個 +h3 的設定 另外 img 平行也有一個 h3 的設定 這裡的觀念為 CSS權重，下列有二個 h3 的設定 1234567img+h3&#123; 屬性設定-特例&#125;h3&#123; 屬性設定&#125; 雖然CSS通常都是 權重一樣大 的話，就是 後面 蓋掉 前面 的屬性，但是 img+h3 權重 &gt; h3 權重，所以 img+h3 不會被後面 單一個h3 屬性蓋掉。 CSS權重 改寫 RWD的格式(1時34分30秒) js 塞入html方式 改寫用 object(json格式)(1時50分 開始)]]></content>
      <categories>
        <category>切版</category>
      </categories>
      <tags>
        <tag>排版</tag>
        <tag>LiveCoding</tag>
        <tag>timeline</tag>
        <tag>切版</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tool-gulp]]></title>
    <url>%2F2017%2F10%2F09%2FTool-gulp%2F</url>
    <content type="text"><![CDATA[gulp環境安裝安裝 Global Gulp 環境npm install gulp -g 如果無法安裝 Global Gulp 環境，請用以下並輸入系統密碼sudo npm install gulp -g 有沒有加入 -g 差異在哪裡呢？ 有加入 “-g”：這是安裝全域的套件也就是安裝在目前的電腦上目的是啟用 “gulp” 這個指令 沒有加入：這是 local 套件安裝的指令是裝在目前的專案資料夾內目的是執行 gulp 時可以取用的套件 總結：只有 npm install gulp -g 才會使用到全域的指令，在教學中， -g 也只會出現一次喔～其餘 gulp 套件只會用到 “npm install –save”。 gulp設定 建立 npm 環境 (package.json用於紀錄安裝什麼套件) npm init 建立 專案用的gulp環境 npm install gulp --save-dev 註1：最後面加 –save 代表將安裝紀錄，記在 package.json註2：安裝完後，會產生node_modules 資料夾(裡面會有許多npm的相依套件) 新增一個檔案：gulpfile.js (用於撰寫預執行的任務) 可搭配 Bower 一起建置開發環境。 1234567npm install gulp-sass --save -&gt;給「正式環境」使用npm install gulp-sass --save-dev -&gt;給「開發環境」使用--save-dev是你開發時候依賴的東西，--save是你發布之後還依賴的東西。比如，你寫ES6代碼，如果你想編譯成ES5發布那麼babel就是devDependencies。如果你用了jQuery，由於發布之後還是依賴jQuery，所以是dependencies。 gulp+bower 設定範本已建置完成範本：gulp-setting 當上述都已設定好，只要將設定檔放置新專案資料夾後，依序執行下列指令即可 123bower installnmp installgulp]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS - float排版問題]]></title>
    <url>%2F2017%2F10%2F04%2FCSS-float%2F</url>
    <content type="text"><![CDATA[紀錄一下 float排版問題 問題：在練習Bootstrap3將表單驗證功能加進去，卻遇到畫面「跑版」的問題，目前是查到 「名稱」底下的&lt;div class=&quot;help-block with-errors&quot;&gt;&lt;/div&gt;所導致。 可能原因為 float？ margin？ 問題點：1.單點 「名稱」欄位，就會造成下方欄位跑版。2.若同時有驗證 左右二邊，欄位又有對齊了。 codepen：排版偏移程式碼解決： 如上圖所述，第一個「名稱」腳變長，造成第三個「Email」排不進去被往後推，導致第四個「聯絡電話」也被往後推擠，造成排版歪掉。 解法為 外層用 row 包起來，清除float的浮動(clearfix)。 codepen：修正後程式碼]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>排版</tag>
        <tag>float</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS - Flexbox]]></title>
    <url>%2F2017%2F09%2F30%2FCSS-Flexbox%2F</url>
    <content type="text"><![CDATA[常用屬性 概念圖 Flex 外容器屬性：flex-direction：決定 flex 主軸線 方向[ row | row-reverse | column | column-reverse ] justify-content：主要軸線(左右)的對齊[ flex-start | flex-end | center | space-between | space-around ] align-items：交錯軸線(上下)的對齊[ flex-start | flex-end | center | baseline | stretch ] Flex 內元件屬性：align-self：單一個物件的交錯軸對齊[ auto | flex-start | flex-end | center | baseline | stretch ] 參考網站圖解：CSS Flex 屬性一點也不難 CSS Flexbox Layout 學習心得筆記]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Flexbox</tag>
        <tag>排版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS - 排版重點整理]]></title>
    <url>%2F2017%2F09%2F30%2FCSS-Layout%2F</url>
    <content type="text"><![CDATA[[display屬性]每一個html標籤都有一個預設的display屬性，通常是block(區塊元素)或者是inline(行內元素)。 block：會從新的一行開始且在占據網頁的一整行，具自己個寬高。 inline：無法設定寬高，依照包含的內容先是寬度。 inline-block：可設定寬高，但又不占據一整行。 none：不顯示，可用來跟使用者互動。 [定位] position，設定區塊的座標方式。如下[position] left/top/right/bottom，設定區塊的左/上/右/下的座標。 z-index，設定區塊的重疊時的顯示優先權。 overflow，當內容超出區塊範圍時候的顯示方式。 [position] static:預設，各元素不用設定即是static，遵守網頁規則由左至右，由上至下。 relative:依照原來存在位置進行調整。absolute:會找上一層(找不到再往上找)有誰設定過 position，依照這個父元素進行位置調整，如果都沒有那就依body進行調整。 fixed:依目前看得網頁進行定位。若是要對齊容器內（div）的對位置，採用absolute比較方便。不用特別計算跟父容器的距離。 [float]設定區塊間的流動方式，像是doc當中的文繞圖。 left:往網頁左邊流動。 right:往網頁右邊流動。 clear:both ：清除流動關係。 [區塊] width，設定區塊寬度。width:1080px; height，設定區塊高度。height:500px; float，設定區塊流動方向。float:left; clear，解除區塊流動。 margin，設定區塊外間距離。如下[margin]。 padding，設定區塊內距。同margin。 [margin設定] margin:10px 20px 30px 40px; 依序為上 右 下 左 margin:10xp 20px 30px; 上 右 下 ?–&gt;找對面的來補,所以是找右的設定來補 margin:10px 20px; 依序為上下 左右 margin:10px; 全都一樣 [背景] background-color，背景顏色 background-image，背景圖案 background-attachment，背景是否固定不動 background-repeat，背景是否重複 background-position，背景位置 [邊框] border-color，四邊的顏色 border-style，四邊的樣式 border-width，四邊的寬度 border-top-color，上邊框的顏色，top可以置換成為right、bottom、left。 border-top-style，上邊框的樣式，top可以置換成為right、bottom、left。 border-top-width，上邊框的寬度，top可以置換成為right、bottom、left。 border-top，上邊框的顏色、樣式與寬度。top可以置換成為right、bottom、left。 border，寬度、樣式、顏色。 [文字] font-family，設定字型 font-size，字體大小 color，字體顏色 line-height，文字行高 font-weight，文字粗體 text-decoration，文字底線 word-spacing，間距 letter-spacing，間距 text-aling，水平對齊方向 text-indent，字首縮排]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>排版</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown常用寫法(置頂)]]></title>
    <url>%2F2017%2F09%2F30%2FMarkDownWrite%2F</url>
    <content type="text"><![CDATA[將常用的 MarkDown 紀錄在這， Ctrl + C 、 Ctrl + V 比較方便。 文字加顏色藍色字 1&lt;font color=&quot;blue&quot;&gt;藍色字&lt;/font&gt; 紅色的字 1&lt;font color=&quot;red&quot;&gt;紅色的字&lt;/font&gt; 20px的字 1&lt;font style=&quot;color:#f90;font-size:20px;&quot;&gt;20px的字&lt;/font&gt; MARKDOWN/HTML常用語法小結 文字增加背景色塊站点配置文件 主题配置文件 站点配置文件 主题配置文件 1234&lt;span id="inline-blue"&gt;站点配置文件&lt;/span&gt;&lt;span id="inline-purple"&gt;主题配置文件&lt;/span&gt;&lt;span id="inline-yellow"&gt;站点配置文件&lt;/span&gt;&lt;span id="inline-green"&gt;主题配置文件&lt;/span&gt; 自定義樣式下列 自定義樣式，參考 超深度优化 文本置中引用我不是一個偉大的程式設計師,我只是一個具有良好習慣的優秀程式設計師。 123&#123;% cq %&#125;我不是一個偉大的程式設計師,我只是一個具有良好習慣的優秀程式設計師。&#123;% endcq %&#125; 数字塊1.左邊是效果。2.我是第二行。 客制CSS文件位置：~/blog/themes/next/source/css/_custom/custom.styl12&lt;span id="inline-toc"&gt;1.&lt;/span&gt;&lt;span id="inline-toc"&gt;2.&lt;/span&gt; label標籤default 1&#123;% label default@default %&#125; primary 1&#123;% label primary@primary %&#125; success 1&#123;% label success@success %&#125; info 1&#123;% label info@info %&#125; warning 1&#123;% label warning@warning %&#125; danger 1&#123;% label danger@danger %&#125; note 標籤default no-icon 1&lt;div class="note default no-icon"&gt;default no-icon&lt;/div&gt; default 1&lt;div class="note default"&gt;default&lt;/div&gt; primary 1&lt;div class="note primary"&gt;primary&lt;/div&gt; success 1&lt;div class="note success"&gt;success&lt;/div&gt; info 1&lt;div class="note info"&gt;info&lt;/div&gt; warning 1&lt;div class="note warning"&gt;warning&lt;/div&gt; danger 1&lt;div class="note danger"&gt;danger&lt;/div&gt; 引用内容 客制CSS文件位置：~/blog/themes/next/source/css/_custom/custom.styl1&lt;blockquote class="question"&gt;内容&lt;/blockquote&gt; 程式碼行內height: 50px; 1`height: 50px;` 區段區段寫法12345``` [language] [title] [url] [link-text]- [language] 是代碼語言的名稱，用來設置代碼塊顏色高亮，非必須；- [title] 是頂部左邊的說明，非必須；- [url] 是頂部右邊的超鏈接地址，非必須；- [link text] 如它的字面意思，超鏈接的名稱，非必須。 上述4項應該是根據 空格 來分隔，而不是 []，故請不要加 []。除非如果你想寫後面兩個，但不想寫前面兩個，那麼就必須加 [] 了，要這樣寫： [] [] [url] [link text]。 MarkDown寫法： CSS12345678``` CSS.container &#123; max-width: 960px; margin: 0 auto; /* 起手式 */ margin-top: 10px;`&#125;``` js12345678910111213``` js.container &#123; function checkList(e) &#123; var num = e.target.dataset.num; // console.log(e.target.nodeName); if (e.target.nodeName !== &apos;LI&apos;) &#123; return &#125;; country.splice(num, 1); updateList(); &#125;&#125;``` 可支援的語法： 連結 插入圖片 內部圖片 1&#123;% asset_img logo.png logo %&#125; 外部圖片 1![Mario](https://goo.gl/2Dty9K) 文字超連結 More info: Writing Google連結：Google 123More info: [Writing](https://hexo.io/docs/writing.html)Google連結：[Google](https://www.google.com.tw/) 項目標籤 符號 序列1 序列2 序列3 123* 序列1* 序列2* 序列3 Check 序列1 序列2 序列3 序列4 1234- [ ] 序列1- [ ] 序列2- [ ] 序列3- [ ] 序列4 數字 序列1 序列2 序列3 序列4 12341. 序列12. 序列23. 序列34. 序列4 重點標示Strong emphasis, aka bold, with asterisks or underscores. Combined emphasis with asterisks and underscores. Strikethrough uses two tildes. Scratch this. 12345Strong emphasis, aka bold, with **asterisks** or __underscores__.Combined emphasis with **asterisks and _underscores_**.Strikethrough uses two tildes. ~~Scratch this.~~]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
</search>
