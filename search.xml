<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[網頁追蹤]]></title>
    <url>%2F2018%2F11%2F14%2FWebTracking%2F</url>
    <content type="text"><![CDATA[整理 網頁追蹤與分析 筆記 FB UTM 工具觸及的網址網址範例： 1234https://kanboo.github.io/?utm_source=facebook&amp;utm_medium=article&amp;utm_campaign=shareInfo 說明 utm_source：從哪個網站過來，如：FB、Google、Blog…等 utm_medium：透過什麼方式，如：banner、文章分享、關鍵字廣告…等 utm_campaign：此次活動名稱 FB UTM 產生器 轉換與行為轉換(從行為 → 漏斗 → 轉換) 希望使用者在網頁上「最終完成的行為」 以此訂定你的「漏斗流程」 範例說明 A 電商：完成「結帳」行為。 B 電商：2.1 有完成「加入購物車」行為，透過分析此行為達到一個量(1 千人)時2.2 再順勢推出「優惠活動」，將 User 推向結帳行為。 AWS：完成一個「注冊流程」。 Faceboox：FB 標準事件程式碼 Mixpanel 測試網站 &gt; 官方網站 設計轉換漏斗選擇「Funnels」→ 建立新 Funnel → 設定篩選條件 篩選條件 FB 追蹤設定將我們所有客戶的追蹤資料，依據不同的條件，分類出不同的類別出來，籍此篩選出具有「更高潛在價值」的客戶清單，不但能更有效的發揮廣告效益，也讓每筆廣告費用花在刀口上，而不是亂槍打鳥。 建立及設定 FB Pixel1. 建立 2. 選擇「手動安裝」 3. 複製追蹤程式碼，嵌入在頁面 4. 可新增額外「追蹤資訊」 不同的追蹤事件 可夾帶額外資訊 驗證是否綁定成功在 head 處，嵌入 facebook 追蹤碼 後，額外新增一事件，如： fbq(&#39;track&#39;, &#39;ViewContent&#39;); ，再去 Facebook 像素 檢查是否有紀錄顯示。 註： 剛觸發追蹤程式碼時，Facebook 不會即時顯示紀錄，須稍待幾分鐘後，才會有最新紀錄顯示。追蹤程式碼 Facebook 像素 紀錄顯示畫面 追蹤事件與參數設定Facebook 像素追蹤碼，點擊「設定」後，再點「自行手動安裝像素程式碼」 再來直接點「繼續」至第二步 有一些基本的追蹤選項可選擇 有些追蹤項目，還可填入額外的參數進去，填完以後，點擊下面複製區一下後，即可將程式碼嵌入我們的頁面或動作裡。 另外也可參照 FB 標準事件程式碼 的範例，如下 直接依照 Facebook 標準的規則，自行撰寫程式碼，完成後，可在結帳頁面或動作時，觸發此段程式碼 1234567&lt;script&gt; // 購買追蹤事件 fbq('track', 'Purchase', &#123; value: 2000, currency: 'TWD', &#125;);&lt;/script&gt; 偵測結果，也可點擊「查看詳細資料」，查看帶入的參數值。 Faceboox：FB 標準事件程式碼 如何自訂事件有時除了追蹤登入「頁面的事件」外，也希望能追蹤到 User 的一些「行為事件」，如：下載產品 DM 的 PDF 動作，不過像此類事件，FB 標準事件程式碼裡並無提供，所以我們就需要「自訂事件」來追蹤此行為，籍此來篩選出具有更高潛在客戶清單。 自行輸入預追蹤的字眼即可 12345// 自訂事件 - 下載PDF行為fbq('track', 'downloadPDF');// 自訂事件 - 註冊行為fbq('track', 'registerStep'); Faceboox：FB 標準事件程式碼 建立廣告受眾要篩選出具有「更高潛在價值」的客戶的話，我們就需下些條件來獲得更精確的資料。 建立「廣告受眾」 下列範例為「篩選出有進註冊頁面，但尚未完成註冊人員」 FB 廣告受眾服務 建立類似廣告受眾1. 選擇哪個當基底 2. 建立類似廣告受眾 3. 設定條件 4. 完成畫面 FB 廣告受眾服務 廣告系統介紹情境說明 銷售產品為「手機」，而我們可將客戶區分為「男生、女生」二類型，再根據這二種類型，設計不同的廣告內容，讓廣告能更觸動人力，提高客戶的購買欲望，另外也可分析出不同的文案下，哪個廣告效益較好(埋 UTM)，用來當下次的參考資料。 廣告管理員 在「行銷活動」，點擊「建立」 點擊「選擇引導式建立流程」 選擇「轉換次數」 輸入「行銷活動名稱」，點擊「設定廣告帳號」 設定相關資訊後，點擊「繼續」 輸入「廣告組合名稱」，選擇想要使用者最終想達成的「目標」 畫面往下滑動，挑選出主要的廣告受眾 設定預花費的廣告金額 FB 廣告平台服務 FB 廣告優化流程先訂出想要追蹤的過程及最終目標 優化過程是須「循序漸近」的，用案例來說明的話 一個商品或網站一開始，一定沒有各種的追蹤事件紀錄，如：加入購物車、結帳、註冊…等紀錄，所以我們一開始只能先從「瀏覽商品資訊」的客戶下廣告，當運行一段時間後，追蹤紀錄陸續會累積「註冊、結帳…」等，籍此我們可以再利用這些數據，產生另一組的「類似廣告受眾」出來，再針對這些「類似廣告受眾」下廣告，進而擴大我們的銷售範圍或客戶群。 利用既有的受眾，產生另一組「類似廣告受眾」 FB 轉換功能介紹 自訂轉換流程可額外設定不在 Facebook 標準事件範圍裡的條件，選擇「設定新的自訂轉換」。 選擇「自訂事件」 填入「名稱」、選擇「類別」，至於「類別」就挑選一個比較符合的選項挑選，最後點擊「建立」。 成功建立一事件 這時再次選擇時，就會出現我們剛新增的「自訂事件」名稱 另外也可在「事件管理工具 → 像素 → 自訂轉換」，看到我們新增的「自訂事件」 可測試看看，是否此追蹤事項是否有生效 若確定生效後，就可以在「廣告管理員」去針對「自訂轉換」建立廣告。 FB 分析建立客製化漏斗利用現有的數據來分析，是否哪個階段可優化或改善，將每個階段的客戶停留率再提高，進而達到最終目標行為(結帳、註冊)。 開啟「FB Analytics」介面 選擇「分析項目」 點選「建立漏斗」 選擇「新增漏斗步驟」，挑選事件 新增第二個項目，點擊後面的「+」號，就可再挑事件 也可設定時間的範圍 完成設定的結果 最後可將此設定「儲存」，可日後可再查看。 FB：分析連結 FB 分析-營業額與顧客終生價值也可觀看「收入」的分析報告。 FB：分析連結 Google Analytics學習如何收集資料，進而分析出有參考性的資訊 自訂事件與轉換 整合訂單數據 拉出受眾，結合廣告系統 開啟電子商務增強版 確認有「購物行為、結帳行為」二個選項，才算有開啟成功。 GA 事件操作方式跟之前埋 FB 追蹤程式碼很像，此外一樣有分「內建」和「自建」的追蹤事件 內建事件 (電子商務、增強型電子商務) 自訂事件 (下載電子書、觀看影片) 1234567// 格式gtag('event', '&lt;event_name&gt;', &#123;&lt;optional_event_params&gt;&#125;)// 實際寫法gtag('event', 'sign_up', &#123; 'method' : 'Google'&#125;); 官方文件：gtag.js 事件參考和參數參考gtag.js 收集增強型電子商務數據GA Chrome 偵測工具 購物行為事件名稱 觀看產品：view_item 跟踪商品詳情查看 必填欄位 加入購物：add_to_cart 添加到購物車 開始結帳：begin_checkout 結帳操作 購買成功：purchase 購買情況 持續收集上述的使用者紀錄，當累積到一定的基數後，就可以分析出可靠性的參考數據，進而決策下一個走向或功能 官方文件：gtag.js 事件參考和參數參考gtag.js 收集增強型電子商務數據 viewcontent 瀏覽商品設定紀錄使用者在瀏覽商品項目時，當進某商品頁面時，我們可以「詳細紀錄」使用者瀏覽哪個商品。 123456789101112131415gtag('event', 'view_item', &#123; items: [ &#123; id: 'P12345', name: 'Android Warhol T-Shirt', list_name: 'Search Results', brand: 'Google', category: 'Apparel/T-Shirts', variant: 'Black', list_position: 1, quantity: 2, price: '2.0' &#125; ]&#125;); 補充：關於「展示數據」，「id、name」參數為必填，其餘的為選填。 官方文件跟踪商品詳情查看：view_item增強型電子商務：展示數據 add_to_cart 加入購物車設定當使用者將產品加入購物車時，觸發 GA 去紀錄使用者的產品資訊。 1234567891011121314151617181920// 監聽 加入購物車 按鈕const btn_addCart = document.querySelector('#addCart');btn_addCart.addEventListener('click', function(e) &#123; gtag('event', 'add_to_cart', &#123; items: [ &#123; id: 'P12345', name: 'Android Warhol T-Shirt', list_name: 'Search Results', brand: 'Google', category: 'Apparel/T-Shirts', variant: 'Black', list_position: 1, quantity: 2, price: '2.0' &#125; ] &#125;);&#125;); 補充：關於「商品數據」，「id、name」參數為必填，其餘的為選填。 官方文件跟踪將商品添加到購物車或從購物車中移除商品的操作商品數據 begin_checkout 結帳行為設定當使用者開始進行結帳時，可紀錄目前的資訊，若結帳需經過「多次的操作」的話，也可紀錄使用者操作到哪個頁面，而放棄最終結帳行為，進而分析優化結帳流程。 1234567891011121314151617// 結帳頁面gtag('event', 'begin_checkout', &#123; items: [ &#123; id: 'P12345', name: 'Android Warhol T-Shirt', list_name: 'Search Results', brand: 'Google', category: 'Apparel/T-Shirts', variant: 'Black', list_position: 1, quantity: 2, price: '2.0' &#125; ], coupon: ''&#125;); 跟踪結帳操作 purchase 購買事件設定紀錄最終的結帳資訊，以及購買產品清單。 1234567891011121314151617181920212223242526272829303132gtag('event', 'purchase', &#123; transaction_id: '24.031608523954162', affiliation: 'Google online store', value: 23.07, currency: 'USD', tax: 1.24, shipping: 0, items: [ &#123; id: 'P12345', name: 'Android Warhol T-Shirt', list_name: 'Search Results', brand: 'Google', category: 'Apparel/T-Shirts', variant: 'Black', list_position: 1, quantity: 2, price: '2.0' &#125;, &#123; id: 'P67890', name: 'Flame challenge TShirt', list_name: 'Search Results', brand: 'MyBrand', category: 'Apparel/T-Shirts', variant: 'Red', list_position: 2, quantity: 1, price: '3.0' &#125; ]&#125;); 補充：關於「操作數據」，「transaction_id」參數為必填，其餘的為選填。 官方文件跟踪購買情況操作數據 客制自訂事件123456// 格式gtag('event', &lt;action&gt;, &#123; 'event_category': &lt;category&gt;, 'event_label': &lt;label&gt;, 'value': &lt;value&gt;&#125;); 123456// 實際範例：gtag('event', '下載電子書', &#123; event_category: '點擊連結', event_label: '下載行銷密技電子書', value: 10&#125;); &lt;action&gt;是在 Google Analytics（分析）事件報告中顯示為事件操作的字符串。 &lt;category&gt;是顯示為事件類別的字符串。 &lt;label&gt;是顯示為事件標籤的字符串。 &lt;value&gt;是一個顯示為事件價值的非負整數。 跟踪 Google Analytics（分析）事件：GA 自訂事件 設定目標 - 程序視覺呈現若想要額外分析出不同的資料的話，如：完成註冊、下載電子書…等，其他的數據分析的話，就可使用「目標」來篩選出我們要的報表。 操作流程下列以分析「完成註冊之依頁面瀏覽順序」的案例，進行操作 設定 → 選擇「目標」 選擇「新增目標」後 選擇「自訂」，點擊「繼續」 輸入「名稱」、選擇「類型」後，按「繼續」 目標詳情 實際連結目標 =&gt; 輸入最終目標的頁面網站 不過下列有額外打開「程序」此選項，原因為進行「註冊行為」時，使用者不可直接到達最終的註冊完成頁面，一定要完成前面的「填寫個人資料」這步驟後，才會有可能達成「完成註冊」行為，所以才需設定「程序」這層判斷，讓數據能更精確。 完成目標設定 查看「程序視覺呈現」 從事件設定轉換目標 第一步選「自訂」，輸入「名稱」，選擇「事件」 填寫「事件條件」 補充說明： 上述需填寫的事件條件，等同是我們埋 GA 事件的參數，下圖為「對應關係」 完成目標設定 多管道程序觀看使用者是透過何種方式到達我們網站，如：社群、Gogole 搜尋、Blog…等 從 UTM 觀看轉換成效選擇「來源/媒介」，再搭配選擇「轉換」選項後，可以用來分析從哪個地方來的使用者，達成的轉換率(註冊、結帳)比較高，我們就可以嘗試增加廣告費用，來測試轉換率是否還會再提高。 其他參考文章：Google analytics 事件追蹤、轉換目標設定教學超詳細 GA 網站分析入門大全Google Tag Manager Micro Challenge 分流短網址服務 官方連結：https://lihi.io/ 活動網址情境說明 假設我有一個活動公告，要發送給所有的客戶，而第一次發佈(簡訊)時，發現不小心填錯活動網址，這時要回收這些訊息，已無法達成，所以我們可以透過「Lihi 短網址」功能，發送「短網址」給客戶，所以更正為正確網址，此時「短網址」也會自動導向正確的網址。 範例 可注意下列紅框的部份(短網址)，都是一樣的，而藍框的部份(網址)，則長的不一樣。 第一次發佈網址 第二次更改後網址 lihi 之參數功能參數說明 設定結果 A/B 測試設定 A/B 入口網址 後續可再追蹤，由哪個入口進來的成效較優 四張前端必看的 GA 報表前端常用報表 1. 特定頁面在瀏覽器上的跳出率與停留時間 位置：行為 &gt; 網站內容 &gt; 內容深度分析 維度：瀏覽器 原因：觀察瀏覽器是否有影響客戶的跳出率 範例： 購物車頁面：safari 的跳出率比其他瀏覽器高 20%，原來是某個 JS 沒寫好 結帳頁面：為什麼 IE 的停留時間都不到 10 秒，原來有 BUG 導致跳轉 2. 響應式網頁的使用體驗查詢 位置：目標對象 &gt; 行動裝置 &gt; 總覽 維度：螢幕解析度 原因：以說服客戶你所開發的前端介面，在平均工作階段時間有滿足絕大部分的需要 範例： 查詢到在 iPad 的平均工作時段較低，原來是響應式沒有寫好 觀察流量與轉換率的比重 注意轉換率： 100 個人來到你的網站 大於 2% 可撐起一間公司 大於 3% 公司存活率 5~10% 狂 3. 網頁效能查詢 位置：行為 &gt; 網站速度 &gt; 總覽 維度：無 原因：能使用速度說服客服你的網頁效能平均值 範例： 當客戶和你要網站平均載入時，可以撈此表的資料 4. 特定系統上的瀏覽器是否有問題 位置：目標對象 &gt; 技術 &gt; 瀏覽器與作業系統 維度：主要維度(作業系統) + 次要維度 (瀏覽器) 原因：以方便你觀察特定系統是否再各數據有明顯落差 範例： 發現到 android 的 firefox 版跳出率很高 Linux 的 Chrome 平均工作階段時間很低 解讀數據四大面向 目標對象：顧客面貌 分析出主要客群 客戶開發：來源從哪裡來的？ 直接連結 廣告 搜尋 社群 推薦連結(參照連結-&gt;如：Blog 上的分享網址、葉配文、Youtube…等) 行為：顧客都在上面做哪些事情？ 轉換：是否有達成你訂定的目標？ 行銷與營運人員想瞭解的報表 每個來源加入購物車、結帳的轉換率 每個產品的業績，與客戶特性 各載具的結帳、購買轉換率 重點字句 100 個人來到你的網站，超過 3%的「轉換率」，可撐起一家公司 從 100% 的顧客中，尋找出 10% 願意付費的使用者 共筆文章 GTM 六角：GTM搞搞就懂：透過 GTM 對網站進行 GA 追蹤 tags: GA、FB]]></content>
      <categories>
        <category>網頁追蹤</category>
      </categories>
      <tags>
        <tag>網頁追蹤</tag>
        <tag>GA</tag>
        <tag>FB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex]]></title>
    <url>%2F2018%2F08%2F19%2FVuex%2F</url>
    <content type="text"><![CDATA[整理 Vuex 筆記 流程與說明用下列二張圖，簡易表示 Vuex 的概念。 單向數據流 與 Vue 相似之處 State存放所有要共用的變數 store.js123456789// store.jsconst state = &#123; isLoading: false, formData: &#123; name: 'Kanboo', sex: 'male', age: 18 &#125;&#125;; vue檔12345678910// .vueimport &#123; mapState &#125; from 'vuex'// 方法1(不推)this.$store.state.isLoading// 方法2(建議)computed: &#123; ...mapState(['isLoading','formData'])&#125; Getter如同 computed，用來取得 state 裡的變數值，或者經過計算、篩選的 state 值 store.js123456789// store.jsconst getters = &#123; isLoading: state =&gt; state.isLoading, formData: state =&gt; state.formData, doneTodos: state =&gt; &#123; // 經過計算篩選的值 return state.todos.filter(todo =&gt; todo.done); &#125;&#125;; Vue檔12345678910// .vueimport &#123; mapGetters &#125; from 'vuex'// 方法1(不推)this.$store.state.doneTodos// 方法2(建議)computed: &#123; ...mapGetters(['isLoading', 'formData', 'doneTodos'])&#125; 範例分別敘述下列三種用法 用法 1：計算 尚未 Done 的項目 用法 2：計算 已 Done 的項目 使用 getters 參數，取得原先已有的itemsNotDone函式 用法 3：透過外層「傳遞傳數」，再加以運算出結果 store.js123456789101112131415161718192021222324252627// store.jsconst state = &#123; todos: [ &#123; id: 1, done: true &#125;, &#123; id: 2, done: true &#125;, &#123; id: 3, done: false &#125;, &#123; id: 4, done: false &#125;, &#123; id: 4, done: true &#125; ]&#125;;const getters = &#123; // 用法1 itemsNotDone(state) &#123; return state.todos.filter(todo =&gt; !todo.done).length; // 過濾 &#125;, // 用法2 itemsDone(state, getters) &#123; return state.todos.length - getters.itemsNotDone; // 搭配「用法1」運用 &#125;, // 用法3 itemsWithID(state) &#123; return id =&gt; &#123; return state.todos.filter(item =&gt; item.id === id); // 接收「參數」 &#125;; &#125;&#125;; 達到傳遞傳數的方式，需配合上述的「用法 3」的設定 Vue檔12345678910111213import &#123; mapState, mapGetters &#125; from 'vuex';export default &#123; computed: &#123; ...mapState(['todos']), ...mapGetters(&#123;'itemsWithID'&#125;) &#125;, methods: &#123; getID() &#123; this.itemWithID(16); // 傳遞參數給getters的函式 &#125; &#125;&#125; 延伸上例，有可能會遇到不同Modules，卻命名到一樣名稱的話，這時我們可以利用「更名」方式，避免實際運用時，產生衝突。 123456789101112131415import &#123; mapState, mapGetters &#125; from 'vuex';export default &#123; computed: &#123; ...mapState(['todos']), ...mapGetters(&#123; todoItem: 'itemsWithID' // 將 itemsWithID 改用 todoItem 名稱 &#125;) &#125;, methods: &#123; getID() &#123; this.todoItem(16); // 使用新名稱呼叫 &#125; &#125;&#125;; Mutations用於更改 state 裡的變數。 注意： 請記住所有要更改 state 的變數值，都只能透過 mutations 進行更改。 store.js123456789// store.jsconst mutations = &#123; LOADING(state, value) &#123; state.isLoading = value; &#125;, FORMDATA(state, value) &#123; state.formData = value; &#125;&#125;; Vue檔12345678910// .vueimport &#123; mapMutations &#125; from 'vuex';// 方法1(不推)this.$store.commit('LOADING' , true)// 方法2(建議，不過還是透過actions觸發比較好)methods: &#123; ...mapMutations(['LOADING','FORMDATA'])&#125; 觸發 Mutations承上例，若要觸發 Vuex 的 mutations，因為我們有解構賦值 mapMutations 裡的 methods，所以就直接使用即可，不建議使用this.$store.commit 的方式，如下所示 Vue檔1234567891011// .vue// 基本型別 (Primitives)this.LOADING(false);// 物件this.FORMDATA(&#123; name: 'Lucas', sex: 'male', age: 4&#125;); Actions如同 methods，在執行過程中，可透過 AJAX 取的資料後，再計算分析後，將結果回塞給 state 裡的變數值，But…剛剛上面說過，所有要更改 state 的變數值，都只能透過 mutations 進行更改。 store.js1234567891011121314151617181920212223242526// store.jsconst actions = &#123; loading(&#123; commit &#125;, value) &#123; commit('LOADING', value) &#125;, getProducts(&#123; commit &#125;, page = 1) &#123; const api = `/api/$&#123;process.env.DBPATH&#125;/products?page=$&#123;page&#125;` commit('LOADING', true) axios.get(api).then(res =&gt; &#123; if (res.data.success) // action 不應該直接修改 state 的值, // 要使用 commit 的方式呼叫 mutations 去改值 // 以下寫法在嚴格模式會發生錯誤 // state.isLogin = true; commit('PRODUCTS', res.data.products) commit('PAGINATION', res.data.pagination) &#125; else &#123; this.$bus.$emit('messsage:push', res.data.message, 'danger') &#125; commit('LOADING', false) &#125;) &#125;&#125; Vue檔12345678910// .vueimport &#123; mapActions &#125; from 'vuex';// 方法1(不推)this.$store.dispatch('loading', true)// 方法2(建議)methods: &#123; ...mapActions(['loading','getProducts']),&#125; Mutations vs Actions說明二者的差異點，另外需注意的是「Mutations 和 Actions」都是解構賦值至 vue 的 methods 位置，所以要注意二者的 Function Name 是否有衝突。 MutationsMutations 一定要是「同步式」更改 state 的變數值，不可以是「非同步」更改變數值。 錯誤範例store.js123456789// store.jsconst mutations = &#123; LOADING(state, value) &#123; setTimeout(() =&gt; &#123; // 非同步, 不行 state.isLogin = value; &#125;, 1000); &#125;&#125;; 正確範例store.js123456// store.jsconst mutations = &#123; LOADING(state, value) &#123; state.isLoading = value; &#125;&#125;; ActionsActions 可以是非同步更改 state 的值，但在 strict(嚴格) 模式下，Actions 不應該直接更改 state 的值，而且是要 Actions 觸發 Mutations 去改 state 的值。 非嚴格模式(不推)store.js12345678// store.jsconst actions = &#123; login(&#123; commit, state &#125;, value) &#123; setTimeout(() =&gt; &#123; state.isLoading = value; // 在strict下，這樣不行 &#125;, 1000); &#125;&#125;; 嚴格模式(建議)store.js12345678910111213141516171819202122232425262728// store.jsconst actions = &#123; addToCart(&#123; commit, dispatch &#125;, &#123; id, qty = 1 &#125;) &#123; const api = `/api/$&#123;process.env.DBPATH&#125;/cart`; const cart = &#123; product_id: id, qty &#125;; commit('LOADING', true); // 觸發 mutation 變更值 axios.post(api, &#123; data: cart &#125;).then(res =&gt; &#123; if (res.data.success) &#123; dispatch('getCart'); // 呼叫另一個 action &#125; commit('LOADING', false); // 觸發 mutation 變更值 &#125;); &#125;, getCart(&#123; commit &#125;) &#123; const api = `/api/$&#123;process.env.DBPATH&#125;/cart`; axios.get(api).then(res =&gt; &#123; if (res.data.success) &#123; commit('CART', res.data.data); // 觸發 mutation 變更值 &#125; &#125;); &#125;&#125;; Action 傳送多個值因為 Action 的接收參數只有二個，而第一個參數固定是 context，所以只剩第二個參數可以傳送「資料」，若只有一個值的話，沒什麼問題，但如果同時間，要傳送多筆資料，又卡在只剩一個參數可塞值的話，該如何解決呢？ 參數 第一個參數：context 第二個參數（可選）：payload context 對象包含以下屬性： 12345678&#123; state, // 等同于 `store.state`，若在模組中则为「局部」状态 rootState, // 等同于 `store.state`，只存在于模組Module中 commit, // 等同于 `store.commit` dispatch, // 等同于 `store.dispatch` getters, // 等同于 `store.getters` rootGetters; // 等同于 `store.getters`，只存在于模組Module中&#125; 官方 API：Action 範例(單個值)Vue檔123456789methods: &#123; ...mapActions(['loading']), createOrder() &#123; // ...略 this.loading(true) // do something... this.loading(false) &#125;&#125; 範例(多個值)籍由傳送 物件 並透過 解構賦值 的配合，達到傳遞多筆資料。 store.js1234567891011121314// store.jsconst actions = &#123; // 第二參數 payload 透過解構賦值的方式，達到傳遞多筆資料 addToCart(&#123; commit, dispatch &#125;, &#123; id, qty = 1 &#125;) &#123; // ...略 const cart = &#123; product_id: id, qty &#125;; // ...略 &#125;&#125;; Vue檔1234567891011// .vuemethods: &#123; ...mapActions(['addToCart', 'getCart']), addItem() &#123; // 傳送 物件 this.addToCart(&#123; id:product.id, qty:product.num &#125;) &#125;&#125; Action 非同步處理多事件有時我們可能要完成一個事的話，需等待前一個 AJAX 回傳結果，才能繼續執行下一步驟，這樣的話，我可以利用 promise 完成此事。 範例下列為要完成 actionB 的動作時，事前需先完成 actionA 的事情，所以 actionA 多包一層 promise 來回應，而 actionB 則用 .then 來等待上一事件完成，才會繼續執行後續動作 commit(&#39;someOtherMutation&#39;) Vuex123456789101112131415actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') // do something resolve() // 回應「成功完成」 &#125;, 1000) &#125;) &#125;, actionB (&#123; commit, dispatch &#125;) &#123; return dispatch('actionA').then(() =&gt; &#123; // 1. 等待 actionA 完成 commit('someOtherMutation') // 2. 執行後續動作 &#125;) &#125;&#125; Module 模組化簡單來說，就是原本全部都寫在 store.js 裡的程式，全部拆分一支支的模組 js，各別存放有相互關係的功能，最終再透過 Vuex 的 modules 引入各個模組。 事前提醒當我們將 store.js 裡，部份程式拆分為模組 js 時，此時模組 js 的程式作用域如下： state 屬於模組「區域」變數 actions、mutations、getters 仍是屬於「全域」變數 所以當不同模組裡，有命名到「相同名稱」的話，就會出現錯誤訊息，只要我們將名稱不要重覆即可，並不是一件很嚴重的事，我們也可以從命名的方式，用來分辦是屬於哪個模組內的 methods。 官方：命名空间 高封裝度和復用性如果希望你的模塊具有更高的封裝度和復用性，你可以通過添加 namespaced: true 的方式使其成為帶命名空間的模塊，這時「actions、mutations、getters」就變成「區域」變數。 範例將原本在 store.js 拆解出 「產品模組、購物車模組」，剩下共用的部份，依舊放在 store.js 裡即可，如：畫面 loading 效果 Product.js 模組12345678910111213141516171819202122232425262728293031323334353637383940// 產品模組const state = &#123; products: [], product: &#123;&#125;, pagination: &#123;&#125;&#125;;const getters = &#123;&#125;;const actions = &#123; getProducts(&#123; commit &#125;, page = 1) &#123; // do something &#125;, getProduct(&#123; commit &#125;, id) &#123; // do something &#125;, updateProduct(&#123; commit &#125;, payload) &#123; // do something &#125;&#125;;const mutations = &#123; PRODUCTS(state, value) &#123; state.products = value; &#125;, PRODUCT(state, value) &#123; state.product = value; &#125;, PAGINATION(state, value) &#123; state.pagination = value; &#125;&#125;;export default &#123; namespaced: true, // 將 actions, mutations, getters 變更為區域變數 state, getters, actions, mutations&#125;; Cart 模組1234567891011121314151617181920212223242526272829303132// 購物車模組const state = &#123; cart: &#123;&#125;&#125;;const getters = &#123;&#125;;const actions = &#123; addToCart(&#123; commit, dispatch &#125;, &#123; id, qty = 1 &#125;) &#123; // do something &#125;, removeCartItem(&#123; commit, dispatch &#125;, id) &#123; // do something &#125;, getCart(&#123; commit &#125;) &#123; // do something &#125;&#125;;const mutations = &#123; CART(state, value) &#123; state.cart = value; &#125;&#125;;export default &#123; namespaced: true, // 將 actions, mutations, getters 變更為區域變數 state, getters, actions, mutations&#125;; store.js1234567891011121314151617181920// store.jsimport Vuex from 'vuex';import Vue from 'vue';import Products from './modules/Products'; // 產品模組import Carts from './modules/Carts'; // 購物車模組Vue.use(Vuex);// ..略const modules = &#123; Products, Carts&#125;;export default new Vuex.Store(&#123; // ... modules // 載入模組&#125;); Vue檔1234567891011121314151617181920// .vuemethods: &#123; // 主要 Vuex store ...mapActions(['loading']), // 產品模組 ...mapMutations('Products', ['PRODUCT']), ...mapActions('Products', ['getProducts', 'getProduct', 'updateProduct']), // 購物車模組 ...mapActions('Carts', [ 'removeCartItem', 'addToCart', 'getCart' ]), addCouponCode() &#123; // do something &#125;, createOrder() &#123; // do something &#125; &#125;, 細節可參考下列連結： Vuex 範例：modules使用範例：vue 引用方式 不同模組函式名稱重覆當我們開始拆分模組時，很有可能在不同模組下，命名到同樣名稱的函式，這樣當我們在 Vue 引用時，很可以就會產生衝突。 情況假設 A 模組 和 B 模組 裡，同時有相同 Actions 的名稱叫「setFilter」的話，這時又要同時引入的話，該怎麼處理呢？ 1234567891011export default () &#123; methods: &#123; ...mapActions('module_A', &#123;set_A:'setFilter'&#125;), // 將 setFilter 改用 set_A 名稱 ...mapActions('module_B', &#123;set_B:'setFilter'&#125;), // 將 setFilter 改用 set_B 名稱 changeFilter () &#123; this.set_A() // A模組 的 setFilter this.set_B() // B模組 的 setFilter &#125; &#125;&#125; 官方：在组件中分发 ActionVuex: Actions with same name in different modules 參考文件官方：Vuex2018 iT 邦幫忙鐵人賽：Vuex 學習筆記GitHub：2017 年，線上讀書會，vue vuex 分享]]></content>
      <categories>
        <category>VueJS</category>
      </categories>
      <tags>
        <tag>VueJS</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter]]></title>
    <url>%2F2018%2F08%2F06%2FVueRouter%2F</url>
    <content type="text"><![CDATA[整理 Vue.js Router 筆記 路由設定下面範例為簡單使用路由的起手式。 設定頁面路徑1234567891011121314151617181920212223242526272829import Vue from 'vue';import Router from 'vue-router';// 載入頁面元件import Index from '@/components/Index';import Product from '@/components/Product';Vue.use(Router);export default new Router(&#123; routes: [ &#123; path: '/', // 對應的虛擬路徑 name: 'Index', // 元件呈現的名稱 component: Index // 對應的元件 &#125;, &#123; path: '/product', name: 'Product', component: Product &#125;, &#123; // 如果無對應的網址，就導回首頁。 path: '*', name: 'Index', component: Index &#125; ]&#125;); 切換頁面1234567891011121314151617181920&lt;template&gt; &lt;div id="app"&gt; &lt;!-- 路由切換的方式 --&gt; &lt;!-- 直接用 網址 切換路由(to 沒冒號) --&gt; &lt;router-link to="/product"&gt;PRODUCT&lt;/router-link&gt; &lt;!-- 使用變數 路徑path 切換路由(to 有冒號) --&gt; &lt;router-link :to="&#123;path: 'product'&#125;"&gt;PRODUCT&lt;/router-link&gt; &lt;!-- 使用變數 名稱name 切換路由(to 有冒號) --&gt; &lt;router-link :to="&#123;name: 'product'&#125;"&gt;PRODUCT&lt;/router-link&gt; &lt;!-- 使用變數 名稱name 切換路由(to 有冒號)，並帶params參數 --&gt; &lt;router-link :to="&#123;name: 'product', params:&#123;id: 18&#125;&#125;"&gt;PRODUCT18&lt;/router-link&gt; &lt;!-- ------------------------------------------------ --&gt; &lt;!-- 路由顯示界面 --&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 官方：router-link-props 轉址假設一情況為 User 亂打網址時，找不到相對應的頁面時，這時我們可以籍由「redirect 轉址」的方式，將頁面導向首頁。 範例User 輸入的網址： serverPath/#/products 但並無 products 的頁面，所以這時會被導向 Home 首頁。 1234567891011121314151617export default new Router(&#123; routes: [ &#123; path: '/home', name: 'Home', component: 'Home' &#125;, &#123; path: '/about', component: 'About' &#125;, &#123; path: '*', // 若都無符合上述條件，則轉址「Home首頁」 redirect: '/home' &#125; ]&#125;); 也可使用物件格式設定導向 1234&#123; path: '*', redirect: &#123;name: 'home'&#125; // 物件格式&#125; 別名假設我們想要網址，不管是輸入「/about」或者「/story」時，統一指向同一個頁面時，但是不更動網址列的「網址路徑」，因為若使用「redirect 轉址」的話，就會被更動到「網址」。 範例可注意下面參數裡，新增「alias」這個變數，用來達成不管是輸入「/about」或者「/story」時,都可以統一指向同一個頁面，但不更動到上方網址路徑的變化。 123456789export default new Router(&#123; routes: [ &#123; path: '/about', alias: '/story', // 「別名」設定 component: 'About' &#125; ]&#125;); 範例(多個別名)別名只是個外號，所以同時存在多個別名，應該也合情合理，而設定方式就是用陣列的型態，將多個別名放在一起。 123456789export default new Router(&#123; routes: [ &#123; path: '/about', alias: ['/story', 'us', 'me'], // 多個「別名」設定 component: 'About' &#125; ]&#125;); 巢狀路由籍由巢狀路由的設定，可以分不同區塊集中管理。 注意：如果巢狀有二層的話，就要有二個 &lt;router-view/&gt; 圖源：Kuro 大-Vue.js 前端框架的演進淺談 設定設定頁面路徑 app.js 第一層1234&lt;div id="app"&gt; &lt;!-- 切換路由界面(第一層) --&gt; &lt;router-view/&gt;&lt;/div&gt; admin.js 第二層1234&lt;div class="admin"&gt; &lt;!-- 切換路由界面(第二層) --&gt; &lt;router-view/&gt;&lt;/div&gt; router.js1234567891011121314151617181920212223242526272829303132333435export default new Router(&#123; routes: [ &#123; path: '/admin', // 第一層 component: () =&gt; import('@/pages/Admin'), // 第二層 children: [ &#123; path: '', // 首頁(default) name: 'AdminDashboard', component: () =&gt; import('@/components/AdminProducts'), meta: &#123; requiresAuth: true &#125; &#125;, &#123; path: 'products', // 產品列表 name: 'AdminProducts', component: () =&gt; import('@/components/AdminProducts'), meta: &#123; requiresAuth: true &#125; &#125;, &#123; path: 'orders', // 訂單 name: 'AdminOrders', component: () =&gt; import('@/components/AdminOrders'), meta: &#123; requiresAuth: true &#125; &#125;, &#123; path: 'coupons', // 優惠券 name: 'AdminCoupons', component: () =&gt; import('@/components/AdminCoupons'), meta: &#123; requiresAuth: true &#125; &#125; ] &#125; ]&#125;); 根據上列程式，切換路由有下列幾種情況 網址：/admin → 會取得children 底下的第一個子項 首頁(default)。 網址：/admin/products → 會取得children 底下的第二個子項 產品列表。 切換頁面 12345678910111213&lt;template&gt; &lt;div id="app"&gt; &lt;!-- 路由連結 --&gt; &lt;router-link to="/admin"&gt;首頁&lt;/router-link&gt; &lt;router-link to="/admin/products"&gt;產品列表&lt;/router-link&gt; &lt;router-link to="/admin/orders"&gt;訂單&lt;/router-link&gt; &lt;!-- 切換路由界面 --&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 範例 官方範例程式碼：JSFiddle 動態路由當有一種情況是很多頁面，不過版型都一樣，只有資料面不一樣的話，我們就可以利用動態 id的方式，透過 AJAX 取得資料，置換掉版型的內容，這樣就只需產出一個Component元件就好。 1234567891011121314151617181920export default new Router(&#123; routes: [ &#123; path: '/', component: () =&gt; import('@/pages/Admin'), children: [ &#123; path: 'customer_order', name: 'AdminShopping', component: () =&gt; import('@/components/AdminShopping') &#125;, &#123; path: 'customer_checkout/:orderId', // 籍由動態id配合AJAX取得結帳資料 name: 'AdminCheckout', component: () =&gt; import('@/components/AdminCheckout') &#125; ] &#125; ]&#125;); 而在 Vue 檔裡，可使用 this.$route.params`來取得值，到時就可利用此 id 透過 ajax 取得資料，並且更新版型的內谷。 123created() &#123; this.orderId = this.$route.params.orderId // 取得動態id值&#125; 範例 pattern matched path $route.params /user/:username /user/evan { username: ‘evan’ } /user/:username/post/:post_id /user/evan/post/123 { username: ‘evan’, post_id: 123 } 官方範例程式碼：JSFiddle 當動態 id 可有可無時，如何設定下列範例為我們有使用「動態路由」，去取得「產品 id」的值，到時可籍由「產品 id」，去後端取得相對應的資料顯示於畫面。 範例網址： serverPath/#/products/16 依上述網址，我們可以編號 16 號的產品資訊 router.js12345678export default new Router(&#123; routes: [ &#123; path: '/products/:id', component: 'Products' &#125; ]&#125;); Vue檔12345// 網址： serverPath/#/products/16created() &#123; this.orderId = this.$route.params.orderId // 16&#125; 不過若當我們的動態 id 可有可無時，網址為下列情況的話 網址： serverPath/#/products 當無帶動態 id 的值時，會導致連預設「products 頁面」也不會顯示出來，所以要避免這樣的情況發生的話，我們需在 router 的動態 id 後面，新增一個「？」，這樣才能避免這預期顯示的畫面沒正確顯示。 12345678export default new Router(&#123; routes: [ &#123; path: '/products/:id?', // 動態id後面新增「？」 component: 'Products' &#125; ]&#125;); 同一路徑載入二個元件可在一個頁面上同時載入多個元件的話，除了一個&lt;router-view&gt;是沒有命名，其餘新增的 &lt;router-view&gt; 都需要額外新增 name 的屬性。 12345678910111213&lt;template&gt; &lt;div id="app"&gt; &lt;!-- default --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 指定名：list --&gt; &lt;router-view name="list"&gt;&lt;/router-view&gt; &lt;!-- 指定名：total --&gt; &lt;router-view name="total"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021// 載入頁面import Product from '@/components/Product';import TheHeader from '@/components/TheHeader';import List from '@/components/List';import Total from '@/components/Total';export default new Router(&#123; routes: [ &#123; path: '/product', // name: 'Product', // component: Product, components: &#123; // 設定多個 component default: TheHeader, list: List, total: Total &#125; &#125; ]&#125;); 路由的 CSS當我們使用&lt;router-link&gt;在切換路由時，而&lt;router-link&gt;實際會轉換成 HTML 的&lt;a&gt;連結標籤，所以當我們想針對目前點擊的&lt;a&gt;連結標籤做 CSS 效果時，可利用下列二個 CSS 的 class 名稱 linkActiveClass：預設頁面，符合此條件的&lt;a&gt;標籤，會有此 class。 linkExactActiveClass：實際點擊&lt;a&gt;標籤後，會變成此 class。 小坑：vue.js 默认路由不加载 linkActiveClass 的问题 自定義切換路由方法可利用 Vue 的 methods，在動作觸發時，使用程式來切換路由。 router.push這個方法會向history添加一個新的記錄，所以，當用戶點擊瀏覽器後退按鈕時，則回到之前的 URL。 123456789101112131415methods: &#123; chagnePath() &#123; // 字符串 this.$router.push('home') // 对象 this.$router.push(&#123; path: 'home' &#125;) // 命名的路由 this.$router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;) // 带查询参数，变成 /register?plan=private this.$router.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;) &#125;&#125; router.replace跟router.push很像，唯一的不同就是，它不會向 history 添加新記錄，而是跟它的方法名一樣，是 替換掉當前的 history 記錄。 其他 router123456789// 在history記錄中向前或者後退多少步，類似window.history.go(n)。this.$router.go(-1);this.$router.go(2);// 往前一頁this.$router.back();// 往後一頁this.$router.forward(); 注意：在 Vue 實例内部，你可以通过 $router 访问路由实例，因此你可以调用 this.$router.push。 官方：Router 实例方法编程式的导航 Lazy Loading Routes主要是設定Compnent時，採用 import(&#39;@/pages/Comics&#39;) 這樣的寫法的話，會將各個頁面的 JS 拆分開來，而不是 build 專案時，只有一個一大包的 JS 檔，如此一來的話，當 User 開啟某頁面時，才會載入當頁面所需的 JS 檔，避免 User 初次進到首頁時，感覺到網站速度慢的狀態。 LazyLoadingRoutes_前步驟： 先在上方 import 元件 在 routes 設定每個 Path，對應的元件 123456789101112131415161718192021222324252627282930313233import Vue from 'vue';import Router from 'vue-router';// 載入頁面元件import Comics from '@/pages/Comics';import ComicDetail from '@/pages/ComicDetail';import ComicChapter from '@/pages/ComicChapter';Vue.use(Router);export default new Router(&#123; routes: [ &#123; path: '/comics', name: 'Comics', component: Comics // 設定頁面元件 &#125;, &#123; path: '/comics/:id', name: 'ComicDetail', component: ComicDetail // 設定頁面元件 &#125;, &#123; path: '/comics/:id/chapter/:cid', name: 'ComicChapter', component: ComicChapter // 設定頁面元件 &#125;, &#123; path: '*', redirect: '/comics' &#125; ]&#125;); LazyLoadingRoutes_後步驟： 直接在 routes 設定每個 Path 時，import 頁面元件 12345678910111213141516171819202122232425262728import Vue from 'vue';import Router from 'vue-router';Vue.use(Router);export default new Router(&#123; routes: [ &#123; path: '/comics', name: 'Comics', component: () =&gt; import('@/pages/Comics') // import寫在這 &#125;, &#123; path: '/comics/:id', name: 'ComicDetail', component: () =&gt; import('@/pages/ComicDetail') // import寫在這 &#125;, &#123; path: '/comics/:id/chapter/:cid', name: 'ComicChapter', component: () =&gt; import('@/pages/ComicChapter') // import寫在這 &#125;, &#123; path: '*', redirect: '/comics' &#125; ]&#125;); 比較圖由下圖可看出，有無使用LazyLoadingRoutes的差異 LazyLoadingRoutes_前 → js 檔案共用 3 支。 LazyLoadingRoutes_後 → js 檔案共用 6 支。 驗證(登入狀態)檢查 User 是否已登入狀態 範例在程式碼第22行位置，可以看到 about 的 path，有新增 meta 物件，透過檢查 authorization 變數 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* eslint no-console:off */import VueRouter from 'vue-router';import Vue from 'vue';import store from './store';import Main from './component/Main.vue';Vue.use(VueRouter);const About = () =&gt; import('./component/About.vue');const Login = () =&gt; import('./component/Login.vue');const log = value =&gt; console.log( `%c$&#123;value&#125;`, 'background: #bdc3c7; color: black; font-size:10px;' );const router = new VueRouter(&#123; mode: 'history', routes: [ &#123; path: '/', component: Main &#125;, &#123; path: '/about', component: About, meta: &#123; authorization: true &#125; &#125;, &#123; path: '/login', component: Login &#125; ]&#125;);// 導向頁面前的檢查機制router.beforeEach((to, from, next) =&gt; &#123; log(`Router beforeEach to: $&#123;to.path&#125; from: $&#123;from.path&#125;`); // 判斷此頁面是否需要 登入狀態 if (to.matched.some(record =&gt; record.meta.authorization || false)) &#123; const isLogin = store.state.isLogin; //取得 Vuex 的 isLogin 變數值 if (isLogin) &#123; // 已登入 next(); &#125; else &#123; // 未登入，導向 login 頁面 next(&#123; path: '/login', query: &#123; redirect: to.fullPath &#125; &#125;); &#125; &#125; else &#123; next(); &#125;&#125;);export default router; router 設定 history 模式Vue router 預設模式是使用 hash，所以當切換網址時，上方網址都會有「#」字號，如下 網址： https://serverPath/#/Page 若想要去掉「#」字號，產生下面的網址的話 網址： https://serverPath/Page 1234const router = new VueRouter(&#123; mode: 'history', // 切換 history 模式 routes: [...]&#125;) 情境若我們將模式更新改history時，會產生下列的情形 正常情況下，User 統一會從首頁登入，如下 首頁網址： https://serverPath/ 但怕的是 User 直接用網址直接想進去某個頁面，如下 產品頁面： https://serverPath/products 不過這時後端並無相對應的「products 頁面」回傳給前端，因為頁面的 router 都是寫在「前端邏輯」上，所以這時後端要協助配合設定「URL Rewrite」，不管 User 上面輸入什麼網址時，後端統一回傳「index.html」頁面，接著讓前端的 router 去導向 products 頁面。 官方：HTML5 History 模式 補充說明後端在實務上應該是在使用者直接輸入網址時，進行你在前面提到的”轉址行為”因為後端的 Router 通常也包含了 API 路徑，所以正確的狀態是: 當使用者直接輸入網址 AP 主機先跑後端的 Router 發現沒有符合的 Path 轉址到前端框架 build 出來的檔案 跑前端 Router 存在前端 Router 中，渲染對應的前端頁面組件 不存在前端 Router 中，轉址到首頁或選擇顯示 404 page 參考文章網站路由 vue-router路由超連結產生器 router-link]]></content>
      <categories>
        <category>VueJS</category>
      </categories>
      <tags>
        <tag>VueJS</tag>
        <tag>Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueComponent]]></title>
    <url>%2F2018%2F08%2F06%2FVueComponent%2F</url>
    <content type="text"><![CDATA[整理 Vue.js Component 筆記 檔案命名規則紀錄一些命名方式，詳細說明可看官方說明 緊密耦合的 Component 和父組件緊密耦合的子組件，應該以 父組件名稱 作為前綴。 官方：紧密耦合的组件名 組件命名的順序 以概念上較普遍的單詞作為開頭，以描述性的修飾詞結尾。 官方：组件名中的单词顺序 Component 命名與引用使用單一檔案組件 （.vue）的話，不用多想，全部 PascalCase 就對了 需要使用 kebab-case 的情況只在你把 template 寫在 .html 裡面，如此一來它會經 browser 解析，而 browser 是不分大小寫的，所以才需要加 - 讓 Vue 知道大寫的轉換規則以找到組件。 FB 討論文：Vue 的元件命名建議 prop 命名 在 HTML 中，使用 kebab-case 在 JavaScript 中，使用 camelCase 官方：Prop-名大小写 官方：优先级 B 的规则：强烈推荐 (增强可读性) props資料傳遞過程用下圖來表示外部資料傳入Vue.component的整個過程。 圖片來源：JSNWORK-Vue.component 組件教學 單向數據流盡可能保持單向數據流的概念，就是讓資料是從 外層 → 內層 單方向傳遞。 AJAX 與 Component 的時間差有時我們的資料可能是由 AJAX 的方式取得，如下例的 Vue 的 created ，而當 component 要讀取父層的資料時，可能這時還沒有資料，所以這時 component 直接讀取父層的 某個變數 資料時，但為空值而錯誤。 錯誤範例開啟錯誤範例，看 console 出現的錯誤訊息。 1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;!-- Component --&gt; &lt;card :user-data="user"&gt;&lt;/card&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el: '#app', components: &#123; card &#125;, data: &#123; user: &#123;&#125;, &#125;, created: function () &#123; var vm = this; $.ajax(&#123; url: 'https://randomuser.me/api/', dataType: 'json', success: function (data) &#123; vm.user = data.results[0]; &#125; &#125;); &#125;&#125;);&lt;/script&gt; 錯誤範例：JSBin 修正版本這時可以利用 v-if 來判斷，透過 AJAX 取得的資料是否已取得，避免在父層資料還為空值時，就被讀取而錯誤。 1234&lt;div id="app"&gt; &lt;!-- Component --&gt; &lt;card :user-data="user" v-if="user.picture"&gt;&lt;/card&gt;&lt;/div&gt; 正確範例：JSBin 參考文章：JSNWORK-Vue.component 組件教學CHRIS-父子組件溝通 pass props / emit eventjeremy-父子組件溝通 - Props 定義盡可能詳細養成好習慣，避免以後踩雷。 一般寫法1234&lt;div id="app"&gt; &lt;!-- 傳入參數值 --&gt; &lt;prompt-component :user-name="name"&gt;&lt;/prompt-component&gt;&lt;/div&gt; 12345678910111213141516Vue.component('PromptComponent', &#123; template: '&lt;button @click="sayHi(userName)"&gt;Say Hi!&lt;/button&gt;', props: ['user-name'], //使用`props`聲明它所獲得的資料 methods: &#123; sayHi: function(name) &#123; alert('Hi ' + name); &#125; &#125;&#125;);var vm = new Vue(&#123; el: '#app', data: &#123; name: 'Kanboo' &#125;&#125;); 程式範例：JSBin 嚴謹寫法1234567&lt;div id="app"&gt; &lt;!-- 傳入參數值 --&gt; &lt;my-component :message="message" :name="name"&gt; &lt;/my-component&gt;&lt;/div&gt; 123456789101112131415161718192021Vue.component('MyComponent', &#123; template: '&lt;div class="component"&gt;&#123;&#123;message&#125;&#125; &#123;&#123;name&#125;&#125; &lt;/div&gt;', props: &#123; message: &#123; type: String, // 型態 default: 'Hello' // 預設值 &#125;, name: &#123; type: String, // 型態 required: true // 是否必填 &#125; &#125;&#125;);var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Hi', name: 'Kanboo' &#125;&#125;); 程式範例：JSBin 官方：Prop props 變數命名當我們在 HTML 在 Component 裡，設定greeting-text屬性，這樣在props要如何正確對應到正確的變數呢！ 範例： 12&lt;!-- HTML使用 kebab-case --&gt;&lt;todo-item greeting-text="hello"&gt;&lt;/todo-item&gt; 可看到下面有二種方式， 用雙引號包起來，這樣就跟在 HTML Component 的屬性名稱一樣 使用駝峰式 camelCase，來對應屬性名稱。 123456789Vue.component('TodoItem', &#123; template: '&lt;h1&gt;&#123;&#123; greetingText &#125;&#125;&lt;/h1&gt;', props: &#123; // 第一種方式 'greeting-text': String, // 第二種方式(建議) greetingText: String &#125;&#125;); 官方：组件注册 emit 向外層傳送事件雖然我們要盡可能保持單向數據流的概念，就是讓資料是從 外層 → 內層 單方向傳遞，不過有特殊情況的話，需要由 內層 去變動 外層 的值的話，這時就需透過 $emit 傳遞事件方式，去觸發外層事件來更新變數值。 範例程式：透過 emit 向外傳遞資訊 Slot 插槽替換簡單來說就是將我們的 component，修改為一個可客制化的 component。 以 DailogBox 為例，我們每次使用都有可能因不同情況，而輸出不同的「標題、內文、按鈕」，但我們的主體結構是長一樣的，這時就可以使用Slot來替換局部 HTML。 範例當有多個插槽時，我們就必須給予插槽名稱，才能正確替換局部 HTML。 原則上遵照下列幾點即可： 外層是在 Tag標籤，新增 slot 屬性，如：&lt;header slot=&quot;header&quot;&gt;替換的 Header&lt;/header&gt; 內層是在 slot標籤，新增 name 屬性，如：&lt;slot name=&quot;header&quot;&gt;這段是預設的文字&lt;/slot&gt; 若無設定 slot名稱 的話，就會自己找洞插，不過一個洞就還好，多個的話，怕插錯洞。 12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;h2&gt;具名插槽(使用 預設值)&lt;/h2&gt; &lt;named-slot-component&gt; &lt;/named-slot-component&gt; &lt;h2&gt;具名插槽(替換 預設值)&lt;/h2&gt; &lt;named-slot-component&gt; &lt;header slot="header"&gt;替換的 Header&lt;/header&gt; &lt;template slot="footer"&gt;替換的 Footer&lt;/template&gt; &lt;template slot="btnString"&gt;按鈕內容&lt;/template&gt; &lt;p slot&gt;其餘的內容&lt;/p&gt; &lt;/named-slot-component&gt;&lt;/div&gt;&lt;script type="text/x-template" id="namedSlotComponent"&gt; &lt;div class="card my-3"&gt; &lt;div class="card-header"&gt; &lt;slot name="header"&gt;這段是預設的文字&lt;/slot&gt; &lt;/div&gt; &lt;div class="card-body"&gt; &lt;slot&gt; &lt;h5 class="card-title"&gt;預設內文表頭&lt;/h5&gt; &lt;p class="card-text"&gt;預設內文文字&lt;/p&gt; &lt;/slot&gt; &lt;a href="#" class="btn btn-primary"&gt; &lt;slot name="btnString"&gt;預設動作內容&lt;/slot&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="card-footer"&gt; &lt;slot name="footer"&gt;這是預設的 Footer&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/script&gt; 加上顏色標籤，方便對應程式碼 使用 is 動態切換 Component原先我們是使用 is 來決定要掛載哪一個 Component 12&lt;!-- is 沒有冒號 --&gt;&lt;div is="primary-component" :data="item"&gt; 不過有時可能要因應不同條件下，顯示不同的 Component，我們可能用 v-if 這樣寫去切換 1234&lt;!-- A情況 --&gt;&lt;primary-component :data="item" v-if="current === 'primary-component'"&gt;&lt;/primary-component&gt;&lt;!-- B情況 --&gt;&lt;danger-component :data="item" v-if="current === 'danger-component'"&gt;&lt;/danger-component&gt; 但可能有超過二種以上條件的話，程式碼就顯得雜亂，這時我們可以改寫用 變數 方式，並配合 is 的特性去做切換。 is 動態切換範例注意行數 第 2 行：需使用:is，而不是is，差在有沒有冒號。 第 23 行：用current變數，來紀錄目前要使用哪個 Component 遵守上述二點，這時我們就可以在不同條件下，變更current的值，來切換不同 component。 1234567891011121314151617181920212223242526&lt;!-- is 有冒號 --&gt;&lt;div class="mt-3" :is="current" :data="item"&gt;&lt;/div&gt;&lt;script&gt;Vue.component('primary-component', &#123; props: ['data'], template: '#primaryComponent',&#125;);Vue.component('danger-component', &#123; props: ['data'], template: '#dangerComponent',&#125;);var app = new Vue(&#123; el: '#app', data: &#123; item: &#123; header: '這裡是 header', title: '這裡是 title', text: '這是 context' &#125;, current: 'primary-component' &#125;&#125;);&lt;/script&gt; Component 為何要用 return data主要要說明 new Vue 的 data 及 Component 的 data，一個是使用 {}(物件)，一個卻要使用 return {}(物件)，這二者差異點是在哪裡！ 修改前當有重覆性的 Component 且會運用 變數 來紀錄的話，有時很有可能會導致共用到同一個 變數 ，而互相影響彼此的結果，就像下面的例子一樣，可以開啟CodePen，分別 點擊 裡面的按鈕，看會出現什麼結果。 12345678910111213141516171819&lt;div id="app"&gt; &lt;div&gt; 1.你已經點擊 &lt;button class="btn btn-outline-secondary btn-sm" @click="counter += 1"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt; 下。 &lt;/div&gt; &lt;div&gt; 2.你已經點擊 &lt;button class="btn btn-outline-secondary btn-sm" @click="counter += 1"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt; 下。 &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125;, &#125;);&lt;/script&gt; 非 Component：CodePen 修改後跟修改前，最大的差異就在於額外新增一段程式碼 Vue.component，利用此功能達成 Component 化。 123456789101112131415161718192021222324252627282930&lt;div id="app"&gt; 修改後： &lt;div&gt; 3.你已經點擊 &lt;counter-component&gt;&lt;/counter-component&gt; 下。 &lt;/div&gt; &lt;div&gt; 4.你已經點擊 &lt;counter-component&gt;&lt;/counter-component&gt; 下。 &lt;/div&gt;&lt;/div&gt;&lt;script&gt; // 新增Vue-component組件 Vue.component('counter-component', &#123; data: function () &#123; return &#123; counter: 0 &#125; &#125;, template: ` &lt;button class="btn btn-outline-secondary btn-sm" @click="counter += 1"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt; ` &#125;) var app = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125;, &#125;);&lt;/script&gt; Component：CodePen 注意事項不過使用 Vue.component 要特別注意一點，就是在 data 的宣告部份， 原本是使用 {}(物件) 的方式宣告，而在Vue.component的data一定要使用函式宣告， 並且 return {}(物件)，否則無法正常執行。 1234567891011Vue.component('counter-component', &#123; // 宣告為function，並且 return 物件 data: function() &#123; return &#123; counter: 0 &#125;; &#125;, template: ` &lt;button class="btn btn-outline-secondary btn-sm" @click="counter += 1"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt; `&#125;); 差異說明 Component 會採用 函式 return 值 的原因，是因為 Component 會一直被重覆建立，而每個 Component 的 data 必須有所區隔，利用此方式來建立不同記憶體位址的 {}(物件) new Vue 的 data 直接使用{}(物件)，也是因為只會只有一個，此 Vue 並不會被別人複製，所以就不會發生共用到同一個記憶體位址，而產生互改別人的資料的問題。]]></content>
      <categories>
        <category>VueJS</category>
      </categories>
      <tags>
        <tag>VueJS</tag>
        <tag>Component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJS]]></title>
    <url>%2F2018%2F07%2F15%2FVueJS%2F</url>
    <content type="text"><![CDATA[整理 Vue.js 筆記 v-model 資料綁定基本上 Vue 的資料綁定，就是直接用 v-model 加上 data 裡的變數名稱，即可完成綁定。 範例123456789101112131415&lt;div id="app"&gt; &lt;!-- v-model 綁定 --&gt; &lt;input type="text" class="form-control" v-model="text"&gt; &lt;!-- 即時呈現 --&gt; &#123;&#123; text &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; text: '', &#125;, &#125;);&lt;/script&gt; 不過唯一要注意的事情，就是綁定的是什麼元素，如：input、Checkbox、radio、select..等，我們需要依照不同的狀況綁定不同的資料格式，如下 1234567891011var app = new Vue(&#123; el: '#app', data: &#123; text: '', // input標籤 textarea: '', // textarea標籤 checkbox: false, // 單選的checkbox checkboxArray: [], // 多選的checkbox singleRadio: '', // radio標籤 selected: '' // select標籤 &#125;&#125;); 由上例來看，我們需特別注意的是 HTML-checkbox 標籤 單選的 checkbox，資料儲放的格式需為boolean型態。 多選的 checkbox，資料儲放的格式需為array型態。 官方：表單控件綁定 表單元素绑定 value有時我們使用 radio、checkbox、selected時，要達成呈現文字及儲存的資料要有所不一樣的話，我們就可以透過value來設定，另外若需要綁定 value 到 Vue 實例的一個動態屬性上，這時可以用v-bind實現。 範例12345678910&lt;!-- 當選中時，`picked` 為字符串"a" --&gt;&lt; input type = "radio" v-model = "picked" value = "a" &gt;&lt;!-- `toggle` 為true 或false --&gt;&lt; input type = "checkbox" v-model = "toggle" &gt;&lt;!-- 當選中時，`selected` 為字符串"abc" --&gt;&lt; select v-model = "selected" &gt; &lt; option value = "abc" &gt; ABC &lt;/ option &gt;&lt;/ select &gt; select 使用 v-for 渲染主要重點在於賦予option的 value 時，記得要加:符號，如下例 1234&lt;select name="" id="" v-model="selected2"&gt; &lt;option disabled value=""&gt;請選擇&lt;/option&gt; &lt;option :value="item" v-for="item in selectData"&gt;&#123;&#123; item &#125;&#125;&lt;/option&gt;&lt;/select&gt; 官方：值绑定 v-model 修飾符12345678&lt;!-- lazy 就像 onchange 一樣，離開欄位才會觸發 --&gt;&lt;input type="text" v-model.lazy="lazyMsg"&gt;&lt;!-- 將值轉型為 數字型態 --&gt;&lt;input type="number" v-model.number="age"&gt;&lt;!-- 去頭去尾多餘的空白 --&gt;&lt;input type="text" v-model.trim="trimMsg"&gt; 官方：修飾符 複選框主要是在 select的標籤上，新增multiple這個屬性即可。 12345&lt;select name="" id="" multiple v-model="multiSelected"&gt; &lt;option value="Kanboo"&gt;Kanboo&lt;/option&gt; &lt;option value="Lucas"&gt;Lucas&lt;/option&gt; &lt;option value="Mary"&gt;Mary&lt;/option&gt;&lt;/select&gt; 連結：JSBin 呈現文字的方式簡單來說有下列幾種 直接輸出：{ {message;}} 綁定在HTML Tag標籤上 純文字： v-text HTML： v-html 範例12345678910&lt;div id="app"&gt; &lt;!-- 直接輸出 --&gt; &#123;&#123; message &#125;&#125; &lt;!-- v-text --&gt; &lt;div v-text="message"&gt;&lt;/div&gt; &lt;!-- v-html --&gt; &lt;div v-html="message"&gt;&lt;/div&gt;&lt;/di&gt; v-bind 標籤屬性綁定經過上面的解說與示範，我們如何要將資料綁定在 HTML Tag標籤 HTML Tag標籤 HTML Tag標籤上的話，可能就很直接的使用下列的方式 1&lt;img src="&#123;&#123; imgSrc &#125;&#125;" alt=""&gt; 在 src 的地方，直接使用 { { imgSrc }} 就以為可以自動綁定好了。 錯誤範例錯誤範例12345678910111213&lt;div id="app"&gt; &lt;!-- 錯誤使用方式，須使用 v-bind --&gt; &lt;img src="&#123;&#123; imgSrc &#125;&#125;" alt=""&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; imgSrc: 'https://images.unsplash.com/photo-1479568933336-ea01829af8de?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=d9926ef56492b20aea8508ed32ec6030&amp;auto=format&amp;fit=crop&amp;w=2250&amp;q=80' &#125; &#125;)&lt;/script&gt; But…人生總是不如意，上例案例並無法將圖片網址正確的綁上 img 標籤 上，正確的使用方式，應該要使用 v-bind 這功能，如下例 &lt;img v-bind:src=&quot;imgSrc&quot; alt=&quot;&quot;&gt; 所以要在 img 標籤 針對 Attributes 做綁定的話，就要加上 v-bind 正確範例正確範例1234567891011121314&lt;div id="app"&gt; &lt;!-- 針對 Attributes 做綁定的話，就要加上 v-bind --&gt; &lt;img v-bind:src="imgSrc" v-bind:class="className" alt=""&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; imgSrc: 'https://images.unsplash.com/photo-1479568933336-ea01829af8de?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=d9926ef56492b20aea8508ed32ec6030&amp;auto=format&amp;fit=crop&amp;w=2250&amp;q=80', className: 'img-fluid' &#125; &#125;)&lt;/script&gt; 圖片連結當我們要讀取本地端的圖片時，如果直接輸入路徑時，會造成它無法正常顯示，主要是因為 vue-loader 的編譯規則 所導致，我們可以改寫用require方式，來取得本地端圖片的位置。 12345&lt;!-- 失效 --&gt;&lt;img :src="@/assets/img_bg.png"&gt;&lt;!-- 正常 --&gt;&lt;img :src="require('@/assets/img_bg.png')"&gt; How to bind img src to data in Vue &gt; vue tempalte 中的 img 标签无法打包出来 &gt; vue 踩坑系列——backgroundImage 路径问题 有無冒號的區別有冒號有冒號為 v-bind 的縮寫，所以有冒號時，這時資料是綁定一個「變數」，所以此時 hello 就代表綁定 Vue Data 裡的 hello 變數。 123456789101112&lt;!-- 有冒號 --&gt;&lt;my-component :message="hello"&gt;&lt;/my-component&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; hello: 'Hi', &#125;&#125;);&lt;/script&gt; 有時不一定是變數，直接寫運算式也行 123// 有冒號:message="1==1":message="1==1?'abc':'xyz'" 無冒號無冒號代表無綁定，所以此時 message 變數的值，就是一個 hello 的字串。 12&lt;!-- 無冒號 --&gt;&lt;my-component message="hello"&gt;&lt;/my-component&gt; v-for 重覆渲染在呈現多筆資料時，可使用 v-for 功能，來實現重覆渲染畫面， 一般使用時，可使用 v-for=&quot;item in list&quot;， 但若有需要資料的索引值的話，可改寫為 v-for=&quot;(item, index) in list&quot;， 這樣就可以利用 index 取得目前的索引值。 範例12345678910111213141516171819202122232425262728&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="(item, index) in list"&gt; &#123;&#123; index + 1 &#125;&#125; - &#123;&#123; item.name &#125;&#125;，年齡：&#123;&#123; item.age &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; list: [&#123; name: '小明', age: 16 &#125;, &#123; name: '媽媽', age: 38, &#125;, &#123; name: '漂亮阿姨', age: 24 &#125; ] &#125; &#125;)&lt;/script&gt; v-for :key 的用途由於 Vue.js 在效能考量，在預設的狀況下，Vue.js 會儘量重覆使用已渲染好的元素。若不設定 key 值，不會重新渲染元素，只會 部份更新 部份更新 部份更新。 無 key 範例在 HTML 的綁定 li 的部份，後面並無加 :key 的設定，然後我們在 li 裡的 input 欄位裡，分別打上 1111、2222、3333 的值後，這時我們點擊按鈕(反轉陣列)時，你會看到資料有二種變化的情況， { { index }} - { { item.id }} { { item.name }} 的值，有正常的反轉變化。 input欄位，卻沒有跟著變化。 無 key 範例12345678910111213141516171819202122232425262728293031&lt;div id="app"&gt; &lt;ul&gt; &lt;!-- 這裡無設定 :key --&gt; &lt;li v-for="(item, index) in list"&gt; &#123;&#123; item.id &#125;&#125; &#123;&#123; item.name &#125;&#125; &lt;input type="text" placeholder="自己手打加上數字"&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button @click="reverseArray" &gt;反轉陣列&lt;/button&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; list: [ &#123; id: '01', name: '甲甲甲' &#125;, &#123; id: '02', name: '乙乙乙' &#125;, &#123; id: '03', name: '丙丙丙' &#125; ] &#125;, methods: &#123; reverseArray: function () &#123; this.list.reverse(); console.log(this.list) &#125;, &#125;&#125;);&lt;/script&gt; 無 Key 範例：JSBin 綁定 key 範例下面範例為有使用 :key，可以在範例看到資料變化時，整個li 裡面的元素，也會跟著一起變化。 綁定 key 範例123456789101112&lt;div id="app"&gt; &lt;ul&gt; &lt;!-- 綁定 Key ，Key須是 唯一值 uniqueKey --&gt; &lt;li v-for="(item, index) in list" :key="item.id"&gt; &#123;&#123; item.id &#125;&#125; &#123;&#123; item.name &#125;&#125; &lt;input type="text" placeholder="自己手打加上數字"&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button @click="reverseArray" &gt;反轉陣列&lt;/button&gt;&lt;/div&gt; 綁定 Key 範例：JSBin 使用建議：1. 有使用 v-for 的話，建議都要配合 key。2. key最好是都是 唯一值 uniqueKey。3. key的值可以自訂，只要不一樣即可。 v-if 判斷式由上例延伸，如果想要在某種條件下，不顯示資料的話， 我們就可以加上 v-if 來加上判斷式， 範例條件為 年齡小於 25 歲不顯示 12345&lt;ul&gt; &lt;li v-for="(item, index) in list" v-if="item.age &lt; 25"&gt; &#123;&#123; index + 1 &#125;&#125; - &#123;&#123; item.name &#125;&#125;，年齡：&#123;&#123; item.age &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 補充：不過良好的撰寫習慣的話，盡量避免 v-for配 v-if一起使用，主要原因是會 耗效能，可以利用 computed 計算，先過濾掉不要的的物件後，再渲染出結果。 避免 v-if 與 v-for 一起使用最主要的原因是「效能」的考量。 情境說明：假設我有 100 個 User(90 男、10 女)，此時我只想顯示 10 女 的資料就好。 12345&lt;ul&gt; &lt;li v-for=&quot;u in Users&quot; v-if=&quot;u.sex === &apos;female&apos;&quot; :key=&quot;u._id&quot;&gt; &#123;&#123; u.name &#125;&#125; - &#123;&#123; u.isActive &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 不過上例的程式的執行，會跑 100 次 forloop 及判斷，所以當有更新資料時，又會重新跑 100 次，這樣效能上就顯得不優。 這時我們就可以使用 computed 先將資料過濾好後，再丟給 v-for 去渲染畫面，這樣就可以優化效能的部份。 v-if 與 v-show v-if：若為flase時，DOM 元素是不會被渲染出來，會整個消失的。 v-show：若為flase時，則是使用 disply:none 將元素隱藏。 v-on 事件綁定以往我們要將某個 DOM 元素綁上事件的話，會使用 EventTarget.addEventListener() 來賦予功能，而在 Vue 要綁上事件監聽的話，實現步驟如下 在 DOM 元素，宣告綁定事件 在 Vue 的 methods 裡，建立函式 範例1234567891011121314151617181920&lt;div id="app"&gt; &lt;!-- 1. 在DOM元素，宣告 綁定事件 --&gt; &lt;button v-on:click="reverseText"&gt;反轉字串&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; text: '', &#125;, methods: &#123; // 2. 在Vue的methods裡，建立 函式 reverseText: function () &#123; console.log('Click me'); &#125; &#125; &#125;);&lt;/script&gt; HTML 各種事件屬性：HTML Event Attributes v-on 進階指令(修飾符)下列介紹一些 修飾符 的使用，可協助縮短我們的程式碼。 事件修飾符最常見的例子，就是 event.preventDefault() 或 event.stopPropagation()， 有時我們在監聽事件時，會需要取消一些 HTML 標籤 預設的行為或是停止事件冒泡， 一般情況下，我們會像下列範例這樣撰寫 取消預設行為1234reverseText(event) &#123; event.preventDefault(); // 取消預設行為 this.newText = this.text.split('').reverse().join('');&#125; 不過在 Vue 裡，有提供我們另外的寫法，如下 說明事件修飾符12345678910111213141516171819&lt;!--阻止單擊事件繼續傳播--&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!--提交事件不再重載頁面--&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!--修飾符可以串聯--&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!--只有修飾符--&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!--添加事件監聽器時使用事件捕獲模式--&gt;&lt;!--即元素自身觸發的事件先在此處處理，然後才交由內部元素進行處理--&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!--只當在event.target是當前元素自身時觸發處理函數--&gt;&lt;!--即事件不是從內部元素觸發的--&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt; 官方說明：事件修飾符 範例 stop - 調用 event.stopPropagation()，停止事件冒泡 (Event Bubbling)行為。 12345&lt;h6&gt;將此範例加上 stopPropagation (防止向外尋找)&lt;/h6&gt;&lt;div @click="trigger('div')"&gt; &lt;!-- 新增 event.stopPropagation() --&gt; &lt;span @click.stop="trigger('box')"&gt;&lt;/span&gt;&lt;/div&gt; stop 範例：JSBin capture - 將監聽事件模式，更改為使用 事件捕獲 (Event Capturing) 模式，。 123456&lt;h6 &gt;事件偵聽器時使用 capture 模式 (事件改為由外而內)&lt;/h6&gt;&lt;div @click.capture="trigger('div')"&gt; &lt;span @click.capture="trigger('box')"&gt; &lt;button @click.capture="trigger('button')"&gt;按我&lt;/button&gt; &lt;/span&gt;&lt;/div&gt; capture 範例：JSBin self - 只會觸發自己綁定的 DOM 元素，不會有Event Capturing和Event Bubbling，這樣就不用再新增event.stopPropagation()。 123456&lt;h6&gt;事件偵聽器時使用 self 模式 (只會觸發自己範圍內的)&lt;/h6&gt;&lt;div @click.self="trigger('div')"&gt; &lt;span @click.self="trigger('box')"&gt; &lt;button @click.self="trigger('button')"&gt;按我&lt;/button&gt; &lt;/span&gt;&lt;/div&gt; self 範例：JSBin once - 只觸發一次回調。 123456&lt;h6&gt;事件偵聽器只觸發一次&lt;/h6&gt;&lt;div @click.once="trigger('div')"&gt; &lt;span @click.once="trigger('box')"&gt; &lt;button @click.once="trigger('button')"&gt;按我&lt;/button&gt; &lt;/span&gt;&lt;/div&gt; once 範例：JSBin 按鍵修飾符以往我們在監聽鍵盤的事件時，都是使用 event.keyCode 進行判斷，如下例 123456function runScript(e) &#123; // 判斷是否有按 Enter 鍵 if (e.keyCode === 13) &#123; // your code &#125;&#125; 一樣 Vue 也有提供我們另外的寫法，如下 說明12&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.13="submit"&gt; 另外也有提供常見的按鍵別名，如：enter、esc、tab…等。 12&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt; 官方說明：按键修飾符 範例 {keyCode | keyAlias} - 只當事件是從特定鍵觸發時才觸發回調。 1&lt;input type="text" @keyup.13="trigger('按下Enter鍵')"&gt; 別名修飾 - .enter, .tab, .delete, .esc, .space, .up, .down, .left, .right 1&lt;input type="text" @keyup.enter="trigger('按下Enter鍵')"&gt; 特殊按鍵，可同時加二個修飾符，達到特殊動作才觸發事件 - .ctrl, .alt, .shift, .meta 1&lt;input type="text" @keyup.shift.enter="trigger('shift + Enter')"&gt; 滑鼠修飾符 .left - (2.2.0) 只當點擊鼠標左鍵時觸發。 .right - (2.2.0) 只當點擊鼠標右鍵時觸發。 .middle - (2.2.0) 只當點擊鼠標中鍵時觸發。 1&lt;span class="box" @click.middle="trigger('點擊鼠標-中鍵')"&gt;&lt;/span&gt; v-on &amp; v-bind 縮寫身為專業的懶人的話，能少寫一個字就絕對不多打一個字，下列分別介紹 v-on 和 v-bind 的縮寫。 v-on原先的寫法 v-on: 改為 @ 代表，參考下例。 12345// 原始寫法&lt;a href="#" v-on:click.prevent="reverseText"&gt;反轉字串&lt;/a&gt;// 縮寫&lt;a href="#" @click.prevent="reverseText"&gt;反轉字串&lt;/a&gt; v-bind原先的寫法 v-bind: 只留下 : 代表即可，參考下例。 12345// 原始寫法&lt;img v-bind:src="imgSrc" &gt;// 縮寫&lt;img :src="imgSrc" &gt; v-class 動態切換 ClassName有時我們會針對 DOM 元素，動態的新增移除 CSS 屬性，而在 Vue 裡，我們實現的方式， 除了使用 v-bind: 綁定資料外，也需要在後面新增條件式的判斷， 這樣我們才能達到動態切換 ClassName，如下例所示 使用方式12&lt;!-- 額外新增判斷式 --&gt;&lt;div class="box" v-bind:class="&#123; '要加入的 ClassName' : 判斷式 &#125;"&gt;&lt;/div&gt; 物件寫法 方法 1：直接寫直接使用 { &#39;屬性名稱&#39;: 判斷式 } 寫入，若是有多個的話，可用「逗號」隔開。 方法 2：物件有時超過二個以上的話，會大大降低可讀性， 所以將多個的 &#39;屬性名稱&#39;: 判斷式 寫在 Vue 的 Data 裡。 1234567891011121314151617181920212223242526&lt;!-- 方法1：直接寫 --&gt;&lt;div class="box" :class="&#123; 'rotate': isTransform, 'bg-orange': boxColor &#125;"&gt; Style&lt;/div&gt;&lt;!-- 方法2：物件 --&gt;&lt;div class="box" :class="objectClass"&gt; Object&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; isTransform: true, boxColor: true, // 物件 objectClass: &#123; 'rotate': true, 'bg-orange': true, &#125;, &#125;,&#125;);&lt;/script&gt; 程式範例：JSBin 更改 CSS 物件之判斷式若是 CSS 採用物件寫法的話，不過當要更改判斷式的值時，要稍微注意一下取值的寫法。 12345678910111213141516171819202122232425262728&lt;!-- 方法2：物件 --&gt;&lt;div class="box" :class="objectClass"&gt; Object&lt;/div&gt;&lt;!-- 取物件裡，單個屬性 --&gt;&lt;button v-on:click="objectClass.rotate = !objectClass.rotate"&gt; rotate&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;!-- 注意，若有「-」字號，要用「中括號」方式寫法 --&gt;&lt;input type="checkbox" v-model="objectClass['bg-orange']"&gt; bg-orange&lt;/input&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; objectClass: &#123; 'rotate': false, 'bg-orange': false, &#125;, &#125;,&#125;);&lt;/script&gt; 程式範例：JSBin 陣列寫法直接利用陣列的方式，將ClassName寫進Array裡，記得要是「字串」。 1234&lt;!-- 陣列 --&gt;&lt;div class="box" :class="['rotate', 'bg-orange']"&gt; Array&lt;/div&gt; 程式範例：JSBin 動態更新 CSS 陣列寫法可透過 checkbox 的特性，可動態新增移除ClassName是否寫進 Array 123456789101112131415161718192021222324252627&lt;!-- 陣列 --&gt;&lt;div class="box" :class="arrayClass"&gt; Array&lt;/div&gt;&lt;!--1. 先綁定 v-model 及 設定 value 的值。2. 籍由 checkbox 的特性，若有勾選時，才會是true， 此時才會存在在 arrayClass 裡， 若無勾選的話，就不會存在 arrayClass 裡。3. 可打開 Vue工具 觀察 arrayClass 的變化。 --&gt;&lt;input type="checkbox" v-model="arrayClass" value="rotate"&gt; rotate&lt;/input&gt;&lt;input type="checkbox" v-model="arrayClass" value="bg-orange"&gt; bg-orange&lt;/input&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; arrayClass:[], &#125;,&#125;);&lt;/script&gt; 程式範例：JSBin 綁定行內樣式:style=&quot;{ 樣式屬性 : &#39;樣式的值&#39; } 可以直接利用 :style 的寫法，將 CSS 屬性寫在 HTML 上面， 不過有一點要 注意 注意 再 注意 若樣式屬性有「-」字號的話，改寫為「駝峰式命名」，將「-」去除而接著後面第一個字母改大寫。 駝峰式命名： box-shadow =&gt; boxShadow ( S 變大寫) margin-top =&gt; marginTop ( T 變大寫) 1234567891011121314151617181920212223242526&lt;!-- 直接寫入HTML裡 --&gt;&lt;div class="box" :style="&#123;backgroundColor: 'orange'&#125;"&gt;&lt;/div&gt;&lt;div class="box" :style="&#123;backgroundImage: 'url(' + img + ')' &#125;"&gt;&lt;/div&gt;&lt;!-- 取用Vue Data的值 --&gt;&lt;div class="box" :style="styleObject1"&gt;&lt;/div&gt;&lt;!-- 陣列方式，裡面插入多個物件 --&gt;&lt;div class="box" :style="[&#123;backgroundColor: 'orange'&#125;, &#123;borderWidth: '3px'&#125;]"&gt;&lt;/div&gt;&lt;div class="box" :style="[styleObject1, styleObject2]"&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; img: 'https://fakeimg.pl/100x100/?text=Hello', styleObject1: &#123; backgroundColor: 'red', borderWidth: '10px' &#125;, styleObject2: &#123; boxShadow: '3px 3px 5px rgba(0, 0, 0, 0.16)' &#125; &#125;,&#125;);&lt;/script&gt; 程式範例：JSBin Computed 跟 method 差異點因為這二者做的事情都好像可以完成，所以有時會不知該選Computed 或 Methods？ 比較表 method computed 使用方式 可傳參數 類變數 執行方式 每次呼叫，每次執行 快取 適用選擇 功能面、動作操作 資料格式、內容處理 使用方式 說明二者的呼叫方式不太一樣 method method呼叫方式1234// 方式1this.fun();// 方式2this.fun('參數1', '參數2'); computed computed 屬性默認只設置 getter 函數，不過在需要時，還可以提供 setter 函數，如下 12345678910111213141516// ...computed: &#123; fullName: &#123; // getter 函数 get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter 函数 set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... 所以 computed 的呼叫方式，就是使用 getter 或 setter 二種用法，而這樣的用法，就很像我們一般在使用JS 的變數一樣，不是取值，就是覆寫值。 1234// gettergetFullName = this.fullName;// setterthis.fullName = '改變的值'; 執行方式 說明 method 每次呼叫，每次執行，所以若呼叫 10 次，就會執行 10 次。 computed 與 method 不同的點，若是當資料沒有變動時，就不會重新計算，所以就算呼叫 10 次，資料若沒變的話，就直接回傳 cache 給你。 如何選擇在選擇二者時，請優先考慮 computed，若 computed 可以使用且滿足你的需求，就用 computed 來執行，另外下列簡易區分方式 computed 若是性質比較偏向 data 的 資料格式 或 內容處理 的話，可選用 computed。 method 可以想成我們在用 JS 的addeventlistener,通常在某些情況下，我們會呼叫函式，幫我們處理相關事宜，如：click、mouseover…等。 Computed 跟 method 觸發時機這裡我們從 觸發時機 來比較二者差異，這樣下次要選擇時，就可以選擇較適當作法。 Computed：其相依的 data 改變時，computed 才會重新計算。 Methods：只要 data 有改變時，不管 有無相依 ，都會重新計算。 結論 需要每次更新，就用 Methods 在意效能，就用 Computed 範例可以點擊範例裡的count按鈕，然後看 console 顯示的訊息，你就會知道Computed 或 Methods 觸發時機有什麼不一樣了。 12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;button @click="plus"&gt;count：&#123;&#123; count &#125;&#125;&lt;/button&gt; &lt;p&gt;now (computed)：&#123;&#123; now &#125;&#125;&lt;/p&gt; &lt;p&gt;getNow (method)：&#123;&#123; getNow() &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; count: 0 &#125;, methods: &#123; // 只要 Vue data 的值有改變時，不管是哪一個值改變，都會觸發每一個函式重新計算。 getNow: function() &#123; console.log("getNow" + "--被觸發執行了") return Date.now(); &#125;, plus() &#123; console.log("plus" + "----被觸發執行了") this.count += 1; &#125; &#125;, computed: &#123; // 其相依的 `data` 改變時，computed 才會重新計算。 // 下面 now 函式裡面沒有 count 的變數，所以count更新時，也不會被觸發 now: function() &#123; console.log("now" + "-----被觸發執行了") return Date.now(); &#125; &#125;,&#125;);&lt;/script&gt; 範例程式：JSBin Computed 與 Watch 的差異觸發時機 Computed：當 methods 裡，有包含到 Vue Data 的變數的話，當變數值更新時，就會觸發 Computed 裡 method 的呼叫。 Watch：針對 Vue Data 裡，特別指定監聽某一個變數，當此變數更新時，就會觸發 Watch 裡 method 的呼叫。 說明在一般情況下，我們通常會直接使用Computed去監聽變數，不用Watch是因為還需要一個個變數去綁定，不過有時如果遇到要處理非同步或複雜的計算時，就可以考慮使用Watch來處理事情。 Watch 範例我想要「使用 trigger 來觸發旋轉 box、並在三秒後改變回來」，所以我特別指定監聽 trigger 這個變數是否有變更。 Watch 範例：JSBin 官方說明：watcher template 小技巧以往我們要針對多個DOM 新增v-if判斷時，需要一個一個新增，如下例 12345678&lt;div v-if="showTemplate"&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;Kanboo&lt;/p&gt;&lt;/div&gt;&lt;div v-if="showTemplate"&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;Lucas&lt;/p&gt;&lt;/div&gt; 若是多個 DOM 的條件都為一樣的話，此時我們可以使用template標籤，將整個區塊包起來，然後在template上，新增判斷式即可。 12345678910&lt;template v-if="showTemplate"&gt; &lt;div&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;Kanboo&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;Lucas&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; DOM 解析注意某些 HTML 元素限制內部的元素只能是某幾種 tag，如：table、select、ul / ol 等，若是使用 Component 時就必須特別小心。 table =&gt; thead、tbody =&gt; tr =&gt; td select =&gt; option ul、ol =&gt; li 失效範例雖然 select 底下的 Component my-option 的裡面是使用option看似合理，不過最主要是一開始 HTML 在渲染時，看到select底下的是 my-option 標籤，因為 HTML 認為這在select 底下是無效的標籤，所以就將my-option 標籤移除，也因為這樣 Vue 要在解析 Component 時，已經不見了。 12345&lt;div id="app"&gt; &lt;select&gt; &lt;my-option&gt;&lt;/my-option&gt; &lt;/select&gt;&lt;/div&gt; 1234567Vue.component('my-option', &#123; template: `&lt;option&gt;Option A&lt;/option&gt;`&#125;);var app = new Vue(&#123; el: '#app'&#125;); 正確方法若要可以正常渲染的話，就需將 Component 寫法移至 Vue 的 template 裡面，透過這樣的方式，讓 Vue 來幫我們解析及渲染畫面。 1&lt;div id="app"&gt;&lt;/div&gt; 123456789101112Vue.component('my-option', &#123; template: `&lt;option&gt;Option A&lt;/option&gt;`&#125;);var app = new Vue(&#123; el: '#app', template: ` &lt;div id="app"&gt; &lt;select&gt;&lt;my-option&gt;&lt;/my-option&gt;&lt;/select&gt; &lt;/div&gt; `&#125;); 資料更新的機制一般情況下，我們要更新 Vue Data 裡面的值時，通常直接指定變數後，就賦予值給它，不過若是要更新「物件 和 陣列」時，就要注意什麼情況會更新，什麼情況不會被更新，下列範例主要是看 PJ 大文章說明(為什麼畫面沒有隨資料更新 - Vue 響應式原理（Reactivity）)，將一些關鍵點紀錄下來 物件更新若是物件要更新某個屬性值的話，有下列方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const postVm = new Vue(&#123; el: '#post', data: &#123; post: &#123; userId: '', id: '', title: '' // body: "", //一開始沒加 // author: "" //一開始沒加 &#125; &#125;, created() &#123; let vm = this; // https://jsonplaceholder.typicode.com/posts/1 request.get(root + '/posts/3').end((err, res) =&gt; &#123; let response = res.body; /** * 問題狀況 * 1. vm.post.body 一開始忘記設定進去 * 2. vm.post.author 後來新增的欄位 * 資料已經設定進去，但是畫面沒有更新，可以開 Vue Dev Tool 搭配 $forceUpdate() **/ vm.post.userId = response.userId; vm.post.id = response.id; vm.post.title = response.title; // ↓ 事後新增此變數，畫面會無法自動刷新，主要是沒有賦予響應式屬性(Reactivity)。 vm.post.body = response.body; /** * 解決辦法 1: 一開始在 data 的地方就補齊 **/ /** * 解決辦法 2: 使用 Vue.set(object, key, value)，重新賦予響應式屬性(Reactivity) **/ vm.$set(vm.post, 'body', response.body); vm.$set(vm.post, 'author', ''); /** * 解決辦法 3: 使用 Object.assign 建立新的物件 **/ // vm.post = response // 不建議 vm.post = Object.assign(&#123;&#125;, response, &#123; author: '' &#125;); &#125;); &#125;&#125;); 陣列更新若針對陣列時，只有下列幾個 methods，才會觸發 Vue 去重新渲染畫面。 陣列函式：push()、pop()、shift()、unshift()、splice()、sort()、reverse() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const postsVm = new Vue(&#123; el: '#posts', data: &#123; currentIndex: '', posts: [], post: &#123; userId: '', id: '', title: '', body: '' &#125; &#125;, methods: &#123; refreshForm(index) &#123; this.currentIndex = index; // 暫存用變數 this.post.userId = this.posts[index].userId; this.post.id = this.posts[index].id; this.post.title = this.posts[index].title; this.post.body = this.posts[index].body; &#125;, saveForm(event) &#123; console.log('saveForm'); console.log('this.currentIndex', this.currentIndex); /** * 問題一： * 使用 index 的方式修改陣列中的內容會壞掉 * - 資料更新但畫面不更新 **/ this.posts[this.currentIndex] = this.post; /** * 解決方法一：使用 Vue 可觀察到的陣列方法 * push()、pop()、shift()、unshift()、splice()、sort()、reverse() * arr.splice(startIndex, delteCount, addItem) **/ this.posts.splice(this.currentIndex, 1, this.post); // 會有陣例 by reference 問題 /** * 解決方法二： 使用 vm.$set * vm.$set(array, index, value) **/ this.$set(this.posts, this.currentIndex, this.post); // 會有陣例 by reference 問題 /** * 問題二：陣列中的值是「物件內容」變成響應式的，會有by reference， * 所以若是遇到「物件」的話，建議使用 Object.assign 重新賦予 **/ // 對應 解法一 this.posts.splice( this.currentIndex, 1, Object.assign(&#123;&#125;, this.post) // 重新創一個新物件 ); // 對應 解法二 this.$set(this.posts, this.currentIndex, Object.assign(&#123;&#125;, this.post)); &#125; &#125;, computed: &#123; // postsLength () &#123; // // 提醒：如果畫面中沒有使用到 postsLength ，則不會自動促發 computed // let newPostId = this.posts.length + 1 // this.post.id = newPostId // return newPostId // &#125; &#125;, created() &#123; let vm = this; // AJAX request // https://jsonplaceholder.typicode.com/posts/ request.get(root + '/posts').end((err, res) =&gt; &#123; vm.posts = res.body; &#125;); &#125;&#125;); PJ：為什麼畫面沒有隨資料更新 - Vue 響應式原理（Reactivity）官方說明：Vue-Mutation Methods Vue 生命週期建立或移除 DOM 元素時，所經歷的事件 beforeCreate：實體初始化。 Created：實體建立完成。資料 $data 已可取得，但 $el 屬性還未被建立。———–↓↓↓————– beforeMount：執行元素掛載之前。 mounted：元素已掛載， $el 被建立。———–↓↓↓————– beforeUpdate：當資料變化時被呼叫，還不會描繪 View。 updated：DOM 的更新已經完成，View 被顯示在畫面上。———–↓↓↓————– activated：如果有設定 keep-alive，這個掛鉤會被呼叫。 deactivated：停用 keep-alive時被呼叫。或 beforeDestroy：實體還可使用。 destroyed：實體銷毀。所有綁定被解除、事件偵聽被移除、子實體也被銷毀。 範例1234567891011121314151617181920212223242526272829303132333435beforeCreate() &#123; console.log(`beforeCreate! $&#123;this.text&#125;`);&#125;,created() &#123; alert(`created! $&#123;this.text&#125;`);&#125;,beforeMount() &#123; alert(`beforeMount! $&#123;this.text&#125;`);&#125;,mounted() &#123; alert(`mounted! $&#123;this.text&#125;`);&#125;,updated () &#123; console.log(`updated! $&#123;this.text&#125;`);&#125;,activated () &#123; // 有使用 keep-alive 時，會觸發此事件 alert(`activated! $&#123;this.text&#125;`);&#125;,deactivated () &#123; // 有使用 keep-alive 時，當使用v-if為false， alert(`deactivated! $&#123;this.text&#125;`);&#125;,beforeDestroy() &#123; // 刪除前 console.log(`beforeDestroy! $&#123;this.text&#125;`);&#125;,destroyed() &#123; // 刪除後 console.log(`destroyed! $&#123;this.text&#125;`);&#125; 生命週期範例 1：JSBin生命週期範例 2：JSBin 參考文件：Vue 實體與生命週期、Vue 生命周期钩子]]></content>
      <categories>
        <category>VueJS</category>
      </categories>
      <tags>
        <tag>VueJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-Grid]]></title>
    <url>%2F2018%2F06%2F27%2FCSS-Grid%2F</url>
    <content type="text"><![CDATA[整理 Grid 的排版與範例 前言在 Youtube 看 Amos 大大 解說 Grid 的各種屬性及運用，所以將一些使用方式及技巧做個紀錄。 Youtube：CSS GRID / CSS格線好好玩 CSS Grid繼 Flexbox 之後，另一新品種的排版方式， 而主要排版可選「格子」或「線條」二種方式去分配區塊。 「格」的概念定義好共有「幾列幾欄」後，再依照有幾個區塊，分別要放置哪個地方。 分配放置的結果，如下所示 父層grid-template-rows：設定幾 列grid-template-columns：設定幾 欄grid-template-areas：分配各區塊佔據的位置 子層grid-area：佔據的名稱 範例HTML12345&lt;div class="container"&gt; &lt;div class="box1"&gt;A&lt;/div&gt; &lt;div class="box2"&gt;B&lt;/div&gt; &lt;div class="box3"&gt;C&lt;/div&gt;&lt;/div&gt; CSS123456789101112131415161718192021222324252627282930.container &#123; width: 100%; height: 400px; outline: 2px solid red; display: grid; grid-template-rows: 1fr 1fr 1fr 1fr; grid-template-columns: 1fr 1fr 1fr 1fr; grid-template-areas: 'B3 B3 B1 B1' 'B3 B3 B1 B1' 'B3 B3 B1 B1' 'B2 B2 B2 B2';&#125;.container &#123; font-size: 50px;&#125;.box1 &#123; grid-area: B1; background-color: #faa;&#125;.box2 &#123; grid-area: B2; background-color: #afa;&#125;.box3 &#123; grid-area: B3; background-color: #aaf;&#125; 範例程式：JSBin grid-template-areas 須為連續區塊在分配區塊的位置時，須為連續矩形區塊，不可有「交叉、L 形」之類的分配。 正確 錯誤B3區塊這樣設定的話，就會造成 Grid 壞掉。 新單位 fr(fractional)原本我們分配rows或columns時，單位都是使用px、%…等，而 Grid 有提供一個新單位fr, 他的概念就像「幾分之幾」一樣，下列用範例說明解釋 範例說明CSS1grid-template-rows: 1fr 1fr 2fr 1fr; 先將全部的 fr 加總，所以共有 5fr，然後上例共分成四個區塊， 所以分別佔據的面積就為 1/5、1/5、2/5、1/5 repeat如果分配的區塊都相同或者有一定的規則時，這樣我們就可以用 repeat 來重覆定義。 CSS123grid-template-rows: repeat(4, 1fr);/* 等同下例 */grid-template-rows: 1fr 1fr 1fr 1fr; 也可以多個。 CSS123grid-template-rows: repeat(2, 1fr 2fr);/* 等同下例 */grid-template-rows: 1fr 2fr 1fr 2fr; grid-gap 格線簡單來說，就是設定每個區塊上下左右之間，是否有空隙， 另外如果有設定grid-gap時，整個區塊的空間會先分配給grid-gap後， 剩餘的空間，再給fr去做切割使用。 語法grid-gap: 列row / 欄column; 也可分別設定的， grid-row-gap: 列row; grid-column-gap: 欄column; 範例HTML1234567891011121314&lt;div class="grid-container"&gt; &lt;div class="item1"&gt;1&lt;/div&gt; &lt;div class="item2"&gt;2&lt;/div&gt; &lt;div class="item3"&gt;3&lt;/div&gt; &lt;div class="item4"&gt;4&lt;/div&gt; &lt;div class="item5"&gt;5&lt;/div&gt; &lt;div class="item6"&gt;6&lt;/div&gt; &lt;div class="item7"&gt;7&lt;/div&gt; &lt;div class="item8"&gt;8&lt;/div&gt; &lt;div class="item9"&gt;9&lt;/div&gt; &lt;div class="item10"&gt;10&lt;/div&gt; &lt;div class="item11"&gt;11&lt;/div&gt; &lt;div class="item12"&gt;12&lt;/div&gt;&lt;/div&gt; CSS12345678910111213141516.grid-container &#123; display: grid; grid-template-columns: auto auto auto auto; grid-gap: 30px 5px; /* 列 欄 */ background-color: #2196f3; padding: 10px;&#125;.grid-container &gt; div &#123; background-color: rgba(255, 255, 255, 0.8); text-align: center; padding: 20px 0; font-size: 30px;&#125; 範例程式：JSBin 「線」的概念我們一樣切割為「四欄四列」，而「面的概念」是用佔據第幾個區塊來分配， 不過「線」的話，就是用「起始線/終點線」來規劃佔據的範圍到哪裡， 再說三次，線的概念為 起始線/終點線起始線/終點線起始線/終點線 範例用上面「面的範例」來修改，註解掉的地方為「面的寫法」， 改用「線的寫法」，來呈現一樣結果。 CSS123456789101112131415161718192021222324252627282930313233343536373839404142.container &#123; width: 100%; height: 400px; outline: 2px solid red; display: grid; grid-template-rows: 1fr 1fr 1fr 1fr; grid-template-columns: 1fr 1fr 1fr 1fr; /* grid-template-areas: 'B3 B3 B1 B1' 'B3 B3 B1 B1' 'B3 B3 B1 B1' 'B2 B2 B2 B2'; */&#125;.container &#123; font-size: 50px;&#125;.box1 &#123; /* grid-area: B1; */ grid-column: 3/5; grid-row: 1/4; background-color: #faa;&#125;.box2 &#123; /* grid-area: B2; */ grid-column: 1/5; grid-row: 4/5; background-color: #afa;&#125;.box3 &#123; /* grid-area: B3; */ grid-column: 1/3; grid-row: 1/4; background-color: #aaf;&#125; 範例程式：JSBin 線的分配可為「負值」線的分配設定值為：起始線/終點線，不過裡面的值可為「負數」， 代表從尾段往前計算線條位置。 範例12345678910.box1 &#123; /* A 區塊 */ grid-row: 1/5; grid-column: 4/5;&#125;.box2 &#123; /* B 區塊 */ grid-row: 5/-5; grid-column: 1/-4;&#125; 範例程式：JSBin span 的用法前面我們說「線」的分配設定值為：起始線/終點線，其實也可以配合「span」來使用。不過使用span時，要特別注意二點 span的值，只能 正數 span的方向，都是 由左至右、由上而下 不過第二點比較容易踩雷，所以再說三次 由左至右、由上而下由左至右、由上而下由左至右、由上而下 範例 以此圖來說，我想要 A、B 二區塊，從上而下全部佔滿， 這時除了使用 起始線/終點線 的寫法外， 我可以使用 span 來表示要佔據幾格。 CSS1234567891011.box1 &#123; /* A 區塊 */ grid-row: 1/ 5; grid-column: 4/5;&#125;.box2 &#123; /* B 區塊 */ grid-row: 1 / span 4; /* 使用span用法 */ grid-column: 1/-4;&#125; 從上例來看 .box2 的 grid-row: 1/ span 4;，就是從 起始線 1 的位置 開始佔據 4 格 的空間。 範例程式：JSBin 特殊分配法介紹完「面與線」的概念後，再來我們先來個簡單又特別的範例， 範例下例切割為「八列八欄」，共有 ABCD 區塊要分配，我們要排成一個斜線的形狀。 HTML123456&lt;div class="container"&gt; &lt;div class="box1"&gt;A&lt;/div&gt; &lt;div class="box2"&gt;B&lt;/div&gt; &lt;div class="box3"&gt;C&lt;/div&gt; &lt;div class="box4"&gt;D&lt;/div&gt;&lt;/div&gt; CSS123456789101112131415161718192021222324252627282930313233343536.container &#123; width: 100%; height: 400px; outline: 2px solid red; display: grid; grid-template-rows: repeat(8, 1fr); grid-template-columns: repeat(8, 1fr);&#125;.container &#123; font-size: 50px;&#125;.box1 &#123; grid-row: 1/3; grid-column: 1/3; background-color: #faa;&#125;.box2 &#123; grid-row: 3/5; grid-column: 3/5; background-color: #afa;&#125;.box3 &#123; grid-row: 5/7; grid-column: 5/7; background-color: #aaf;&#125;.box4 &#123; grid-row: 7/9; grid-column: 7/9; background-color: #8f8;&#125; 範例程式：JSBin 可「重疊」分配再用上例來修改，如果想要 C 的部份區塊要蓋在 B 區塊上面，只要將二者分配的值，有交錯即可。 123456789101112131415// ...略.box2 &#123; grid-row: 3/5; grid-column: 3/5; background-color: #afa;&#125;.box3 &#123; grid-row: 4/7; grid-column: 4/7; background-color: #aaf;&#125;// ...略 範例程式：JSBin 補充說明：如果想要換成 B 蓋在 C 上面的話，就可以使用 position 和 z-index 配合使用，不過在 Grid 裡，可以直接使用 z-index 即可。 grid-auto-* 自動切割欄列1234567// 固定分配grid-template-rows: repeat(8, 1fr);grid-template-columns: repeat(8, 1fr);// 自動分配grid-auto-rows: 1fr;grid-auto-columns: 1fr; 再來我們來說說，grid-template-* 與 grid-auto-* 之間差異點， 就是 grid-auto-* 會自動計算你使用的正整數最大值後，自動用最大值去切割區塊， 這樣可能還不是很清楚，我們用範例來說明： 範例123456789101112131415.container &#123; display: grid; grid-auto-rows: 1fr; grid-auto-columns: 1fr;&#125;.box1 &#123; grid-row: 1/10; grid-column: 1/2;&#125;.box2 &#123; grid-row: 3/5; grid-column: 1/8;&#125; 從上例來看的話，我們先看 rows 的部份， .box1：grid-row: 1/10;.box2：grid-row: 3/5; 上述row裡面最大正整數值為：10， 不過要注意 10 是終點線，所以要扣掉 1，共切了 9 格； 而 columns 的部份規則也是一樣， .box1：grid-column: 1/2;.box2：grid-column: 1/8; 上述columns裡面最大正整數值為：8， 所以 8 - 1 = 7 ，共切了 7 格。 範例程式：JSBin minmax()指定最小格線及最大格線。 範例：HTML1234567891011121314&lt;div class="grid"&gt; &lt;div class="item"&gt; &lt;img src="https://fakeimg.pl/200x200/?text=Hello"&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="https://fakeimg.pl/200x200/?text=Hello"&gt; &lt;/div&gt; &lt;!-- 圖片*100個 --&gt; &lt;div class="item"&gt; &lt;img src="https://fakeimg.pl/200x200/?text=Hello"&gt; &lt;/div&gt;&lt;/div&gt; CSS1234567891011121314151617181920* &#123; margin: 0; padding: 0;&#125;.grid &#123; box-sizing: border-box; display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));&#125;.item &#123; outline: 1px solid red;&#125;.item img &#123; width: 100%; /* 解決baseline問題 */ vertical-align: top;&#125; 說明 minmax(160px, 1fr)grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); 簡單說明一下，上述程式碼 auto-fill 就是自動填滿，那用 minmax(160px, 1fr) 填滿是什麼意思呢！ 單單從 minmax(160px, 1fr) 這程式碼來描述的話， 最小值就是 160px ，而最大值是 1fr ？？ 那1fr又代表多少呢？ 讓我再用簡單例子來說明(給自己聽)， 因為我本身設定最小值為160px,所以當我一列若要可以塞下第二個 div 的話，我最少也要有 160px*2=320px 的寬度，才能塞得下第二個 div，所以當一列的寬度在 160px~319px 時，只會有一個 div，並且這一個 div 會在160px~319px 之間，自動幫我伸縮它的寬度，但當我一列的寬度到達 320px 寬度時，它就會塞入第二個 div 在同一列上，所以我大膽假設minmax(160px, 1fr)的1fr,就是取 最小值 * 2 - 1px 吧！ 範例：寬度：320px 時，一列可放 2 張圖片 寬度：480px 時，一列可放 3 張圖片 範例程式：JSBin 對齊方式 水平軸對齊 justify-content：整個 grid 範圍 justify-items：所有格子 統一設定 justify-self：一個格式 單獨設定 垂直軸對齊 align-content：整個 grid 範圍 align-items：所有格子 統一設定 align-self：一個格式 單獨設定 參考文件：MDN-Box alignment in CSS Grid Layout]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>排版</tag>
        <tag>Grid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery-選取器]]></title>
    <url>%2F2018%2F05%2F31%2FjQuery-Selector%2F</url>
    <content type="text"><![CDATA[深入了解 jQuery 選取器 實作的原理 前言在 Youtube 直播看到 Alex 大大，深入說明 jQuery 底層的程式碼，在此紀錄 選取器 的脈絡。 Youtube：從 jQuery 入門到認識 JavaScript #2 DOM 選取器與遍歷的使用解析Facebook：Alex 宅幹嘛-粉絲團 Node.nodeType在 jQuery 的原始碼裡，很常使用 Node.nodeType 來判斷取得物件的種類， 所以我們要先了解 Node.nodeType 是什麼。 常出現的號碼，請記 1 表示元素的 Element 節點，如 &lt;body&gt;、&lt;a&gt;、&lt;p&gt;、&lt;script&gt;、&lt;style&gt;、&lt;html&gt;、&lt;h1&gt; 或 &lt;div&gt;。 3 表示 HTML 元素屬性的 Attr 節點 或 實際文字字元的 Text 節點，它包括了「換行與空格」。 9 表示文件的 Document 節點。 MDN - Node.nodeType Node.nextSibling有時候我們會需要取得 目前元素&lt;div&gt; 的下一個兄弟元素&lt;div&gt;，這時我們會使用 element.nextSibling 來完成這個任務，偏偏有時回傳給我們的東西，竟然不是我們的好兄弟元素&lt;div&gt;，而是一個奇怪的東西，這奇怪的東西正好是上述所說的 Node.nodeType 為 3。 範例測試 HTML12&lt;div id="div-01"&gt;Here is div-01&lt;/div&gt;&lt;div id="div-02"&gt;Here is div-02&lt;/div&gt; Javascript1234567891011121314151617181920var el = document.getElementById('div-01').nextSibling, i = 1;console.log('Siblings of div-01:');while (el) &#123; console.log(i + '. ' + el.nodeName); el = el.nextSibling; i++;&#125;// 輸出結果：// Siblings of div-01:// 1. #text// 2. DIV// 3. #text// 4. SCRIPT// 5. #text// 6. SCRIPT 由上例可看到 div-01 取下一個元素時，回傳的是 #text，而不是 DIV 元素。 CodePen 解決#text 問題那我們如何解決這個問題呢？下列有幾種解法供參考。 解法 1 使用 nodeType 判斷，當我們取得下一個的話，判斷 el.nextSibling !== 1 時，就代表不是元素的 Element 節點，所以需要再往下抓下一個，直到 el.nextSibling === 1 時，才是我們要的 div 元素。 解法 2 使用 element.nextElementSibling 取得下一個元素，它幫會我們避開 el.nextSibling !== 1 的東西，若你看他的原始碼的話，他也是使用 解法 1 的寫法去執行，只是此函式事先幫我們判斷好而已。 MDN - NonDocumentTypeChildNode.nextElementSibling for loop 潮的寫法以往我們看到使用 for loop 的寫法如下 forloop123for (let i = 0; i &lt; 5; i++) &#123; // your code&#125; 再開始介紹 for loop 潮的寫法之前，這裡先重新複習 for loop 的語法結構 英文版：for ([initialization]; [condition]; [final-expression])中文版：for ([宣告]; [條件]; [改變]) 我就用中文來解說 宣告 就等於我們一般在使用的 let a = 10 、 let b = 87 條件 就像我們使用 if 的判斷式一樣， if(a === 9) 看完說明後，接下來我們來看 jQuery 裡，使用比較潮的寫法 siblings函式1234567891011var siblings = function(n, elem) &#123; var matched = []; for (; n; n = n.nextSibling) &#123; if (n.nodeType === 1 &amp;&amp; n !== elem) &#123; matched.push(n); &#125; &#125; return matched;&#125;; 注意上例 for loop 的寫法，他第一個 initialization 竟然沒有寫，為什麼呢？ 下面我們用簡單的範例來說明 潮的寫法12345var sibling = elem.parentNode.firstChild;for (; sibling; sibling = sibling.nextSibling) &#123; if (sibling.nodeType !== 1 || sibling === elem) continue; siblings.push(sibling);&#125; 其實你注意 for loop 的上面一行， 可以看到它只是提前把 for loop裡第一個 initialization 拉出來外層撰寫，所以當開始執行 for loop 時，就不必再宣告一次，程式就可以直接執行了。 Youtube 說明時間點-2h32m50s jQuery 的 siblings再來我們來看 jQuery 的 siblings 函式時，紀錄二個重點 重點 1 Q.siblings 如何實現取得目前元素之相鄰的兄弟元素？ A. 最初的想法，我們可以使用 Node.nextSibling 和 Node.previousSibling ，分別 for loop 往前往後各跑一次抓取。 不過我們來看一下 jQuery，是如何實現呢？ siblings函式1234567891011var siblings = function(n, elem) &#123; var matched = []; for (; n; n = n.nextSibling) &#123; if (n.nodeType === 1 &amp;&amp; n !== elem) &#123; matched.push(n); &#125; &#125; return matched;&#125;; 呼叫siblings123siblings: function( elem ) &#123; return siblings( ( elem.parentNode || &#123;&#125; ).firstChild, elem );&#125; 主要的重點在於 呼叫siblings 裡的 ( elem.parentNode || {} ).firstChild，它的作法為 由目前元素 先往上一層父元素後，再往下層抓排序第一個的子元素，這樣就回到兄弟元素的第一個了。 接著開始從第一個元素，for loop 使用 nextSibling 取得下一個元素，並且過程中排除自己。 這樣的話，就可以取得所有相鄰的兄弟元素。 重點 2 延續上個案例 Q.(elem.parentNode || {}).firstChild 之裡面的 {} 是做什麼用的？ A. 其實後面的 {} 是用來擋 程式錯誤 噴error 的， 如果當elem是沒東西時，這時就會給 {} 值，而當 JS 執行此段語法 {}.firstchild 時， 會回傳 undefined 值，至少 js 還看得懂 undefined，所以就不會出現 error訊息，造成網站掛了，但若是直接用 undefined.firstchild，就會死給你看。 範例說明 可以將下列的程式碼，貼到 Chrome 開發者工具試試。 例1：沒給值12345let a; // 沒給值，預設為 undefineda.firstchild;// console 輸出：// Uncaught TypeError: Cannot read property 'firstchild' of undefined 例2：有給值12345let b = &#123;&#125;;b.firstchild;// console 輸出：// undefined 情境說明 以 AJAX 為例 res.data.member[0].name 有時跟後端串 API 後，回傳的資料要取得 User 的名字， 但有時避免後端開錯規格或遺漏掉的話，避免 JS 執行時，直接噴錯誤的話， 我們就要自行新增一些 擋煞 的機制，參考寫法如下 擋煞機制123456if (res.data) &#123; let list = data.membe || []; let name = list[0].name || ''; // i get name&#125; 說明 {} 的用途]]></content>
      <categories>
        <category>JS</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tool-CSScomb]]></title>
    <url>%2F2018%2F05%2F31%2FTool-CSScomb%2F</url>
    <content type="text"><![CDATA[CSScomb - CSS 屬性排版插件 前言以往再寫 SCSS 時，都會用此插件，整理 SCSS 的排序，這樣很整齊看起來滿爽的， 不過最近遇到在寫 SCSS 時，同時有使用二個以上的 mixinx 的話，就會造成排版錯亂的效果。 修正紀錄一下，如何解決自動排版錯亂的問題。 1.Settings 設定因為預設沒有 mixin 的排序，所以需調整 csscomb 的參數設定，下列附上我的設定值。 我的 csscomb_preset 2.CRLF 與 LF 設定將原先的 CRLF 更改為 LF，然後再重新執行一次，即可。 解決問題的issue 補充說明CRLF 跟 LF 之區別 — 隱形的 bugGit 在 Windows 平台處理斷行字元 (CRLF) 的注意事項 參考文件Gua - 好用的CSS屬性排版插件官方vscode-csscomb]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>vscode</tag>
        <tag>CSScomb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-AllSample]]></title>
    <url>%2F2018%2F05%2F28%2FJS30-AllSample%2F</url>
    <content type="text"><![CDATA[整理全部 JS30 的範例及連結 前言有時要找之前做過的範例參考程式碼，但又忘記是在第幾個做過， 所以就將全部範例整理起來，並加上圖片、簡短描述，方便以後查詢。 成品JS30 範例-全部清單 說明簡易說明頁面的功能。 DEMO：實作完成的成品 GitHub：參考成品的程式碼 Blog：紀錄個人學習的心得 JS30 練習連結Wes Bos-JavaScript30]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Promise-asnyc-await]]></title>
    <url>%2F2018%2F05%2F25%2FES6-Promise-asnyc-await%2F</url>
    <content type="text"><![CDATA[Promise 與 asnyc-await 的運用 Promise Chain下列為連續執行任務時，全部成功執行完畢的情況 Promise Chain12345678910111213141516171819202122232425262728293031323334353637let task01 = () =&gt; &#123; return new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve('OK'); &#125;, 0) &#125;)&#125;let task02 = () =&gt; &#123; return new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve('OK'); &#125;, 0) &#125;)&#125;let task03 = () =&gt; &#123; return new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve('OK'); &#125;, 0) &#125;)&#125;// 執行任務task01() .then(result =&gt; &#123; console.log(`task01=&gt;$&#123;result&#125;`); return task02(); &#125;) .then(result =&gt; &#123; console.log(`task02=&gt;$&#123;result&#125;`); return task03(); &#125;) .then(result =&gt; &#123; console.log(`task03=&gt;$&#123;result&#125;`); console.log('done！！'); &#125;) .catch(err =&gt; console.log(err));// 輸出訊息// task01=&gt;OK// task02=&gt;OK// task03=&gt;OK// done！！ JSBin Promise Chain 如何截取錯誤若執行任務過程中有 失敗 的話，就會統一使用 catch 截取錯誤的訊息。 截取錯誤12345678910111213141516171819202122232425262728293031323334353637383940414243let task01 = () =&gt; &#123; return new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve('01 OK'); &#125;, 0) &#125;)&#125;let task02 = () =&gt; &#123; return new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; &#123; reject('02 failed'); // 這裡出錯了... &#125;, 0) &#125;)&#125;let task03 = () =&gt; &#123; return new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve('01 OK'); &#125;, 0) &#125;)&#125;// 執行任務task01() .then(result =&gt; &#123; console.log(`task01=&gt;$&#123;result&#125;`) &#125;) .then(task02) .then(result =&gt; &#123; console.log(`task02=&gt;$&#123;result&#125;`) &#125;) .then(task03) .then(result =&gt; &#123; console.log(`task03=&gt;$&#123;result&#125;`) &#125;) .catch(e =&gt; &#123; // 統一截取錯誤 console.log(`error=&gt;$&#123;e&#125;`); &#125;)// 輸出訊息// task01=&gt;01 OK// error=&gt;02 failed JSBin asnyc-await下列為連續執行任務時，全部成功執行完畢的情況 asnyc-await chain123456789101112131415161718192021222324252627282930async function fn1() &#123; return 'ok'&#125;async function fn2() &#123; return 'ok'&#125;async function fn3() &#123; return 'ok'&#125;// 執行任務(async () =&gt; &#123; let a = await fn1(); console.log(`fn1：$&#123;a&#125;`); console.log(`fn1做完...才往下`); let b = await fn2(); console.log(`fn2：$&#123;b&#125;`); console.log(`fn2做完...才往下`); let c = await fn3(); console.log(`fn3：$&#123;c&#125;`);&#125;)();// 輸出訊息// fn1：ok// fn1做完...才往下// fn2：ok// fn2做完...才往下// fn3：ok JSBin asnyc-await 如何截取錯誤在Promise中，我們知道是通過 catch 的方式來捕獲異常，而當我們使用 async 時，則通過 try/catch 來截取錯誤。 截取錯誤1234567891011121314151617181920212223242526async function fn1() &#123; return 'fn1'&#125;async function fn2() &#123; throw 'error：fn2' //送出錯誤&#125;async function fn3() &#123; return 'fn3'&#125;// 執行任務(async () =&gt; &#123; let a = await fn1(); // 截取錯誤 try &#123; let b = await fn2(); &#125; catch(e) &#123; console.log(e); &#125; let c = await fn3();&#125;)();// 輸出訊息// error：fn2 JSBin 但是依上列情況來說，當有多個 await 時，包太多 try/catch 的話，就會顯示程式碼不好看也不好閱讀 1234567891011121314151617181920212223242526272829303132333435async function fn1() &#123; throw 'error：fn1'&#125;async function fn2() &#123; throw 'error：fn2'&#125;async function fn3() &#123; throw 'error：fn3'&#125;// 執行任務(async () =&gt; &#123; try &#123; let a = await fn1(); &#125; catch(e) &#123; console.log(e); &#125; try &#123; let b = await fn2(); &#125; catch(e) &#123; console.log(e); &#125; try &#123; let c = await fn3(); &#125; catch(e) &#123; console.log(e); &#125;&#125;)();// 輸出訊息// error：fn1// error：fn2// error：fn3 JSBin 這時我們可以換個寫法，將 try/catch 移位至 function 裡，而不是包在 await 外層 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950async function fn1() &#123; // 方式1：分別在 try 和 catch 裡，return不同的結果 try &#123; return 'ok'; &#125; catch(e) &#123; return 'fail'; &#125;&#125;async function fn2() &#123; // 方式2：用一個變數紀錄，最後再return結果 let result = false; try &#123; result = true; &#125; catch(e) &#123; result = false; &#125; return result; //回傳結果&#125;async function fn3() &#123; let result = false; try &#123; throw 'error'; &#125; catch(e) &#123; result = false; &#125; return result;&#125;// 執行任務(async () =&gt; &#123; let a = await fn1(); let b = await fn2(); let c = await fn3(); console.log(`fn1：$&#123;a&#125;`); console.log(`fn2：$&#123;b&#125;`); console.log(`fn3：$&#123;c&#125;`);&#125;)();// 輸出訊息// fn1：ok// fn2：true// fn3：false JSBin 何時要用 Promise 還是 asnyc-await 呢？先說結論(個人看法)： 任務有前後關係的話，使用 Promise Chain 寫法 任務無前後關係的話，使用 asnyc-await 寫法 下面用不同情況來說明 情境 1 因 task01、task02、task03 有前後關係的話，執行的順序需要先完成 task01 → task02 → task03，當執行任務過程中，有錯的話，就不必再繼續往下執行。 Promise Chain 寫法123456789101112131415161718192021222324252627282930313233343536373839404142let task01 = () =&gt; &#123; return new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve('01 OK'); &#125;, 0) &#125;)&#125;let task02 = () =&gt; &#123; return new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; &#123; reject('02 failed'); // 這裡出錯了 &#125;, 0) &#125;)&#125;let task03 = () =&gt; &#123; return new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve('01 OK'); &#125;, 0) &#125;)&#125;// 執行任務task01() .then(result =&gt; &#123; console.log(`task01=&gt;$&#123;result&#125;`) &#125;) .then(task02) .then(result =&gt; &#123; console.log(`task02=&gt;$&#123;result&#125;`) &#125;) .then(task03) .then(result =&gt; &#123; console.log(`task03=&gt;$&#123;result&#125;`) &#125;) .catch(e =&gt; &#123; console.log(`error=&gt;$&#123;e&#125;`); &#125;)// 輸出訊息// task01=&gt;01 OK// error=&gt;02 failed JSBin 若是我們改用 asnyc-await 寫的話，如下 asnyc-await 寫法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263async function fn1() &#123; try &#123; return true; &#125; catch(e) &#123; return true; &#125;&#125;async function fn2() &#123; let result = false; try &#123; result = false; &#125; catch(e) &#123; result = false; &#125; return result;&#125;async function fn3() &#123; let result = false; try &#123; throw 'error'; &#125; catch(e) &#123; result = false; &#125; return result;&#125;// 執行任務(async () =&gt; &#123; let a = await fn1(); // 判斷 fn1 是否成功 if(a)&#123; console.log(`fn1：$&#123;a&#125;`); &#125;else&#123; console.log(`fn1：out.....`); throw 'out...' &#125; let b = await fn2(); // 判斷 fn2 是否成功 if(b)&#123; console.log(`fn2：$&#123;b&#125;`); &#125;else&#123; console.log(`fn2：out.....`); throw 'out...' &#125; let c = await fn3(); // 判斷 fn3 是否成功 if(c)&#123; console.log(`fn3：$&#123;c&#125;`); &#125;else&#123; console.log(`fn3：out.....`); throw 'out...' &#125;&#125;)();// 輸出訊息// fn1：true// fn2：out..... JSBin 雖然asnyc-await一樣可以完成同樣的事情，不過程式碼與Promise的寫法來看，就稍微雜亂了一點，主要是因為執行每個任務時，需要在任務之間，穿插 if 的判斷來確認上個任務是否完成，才能繼續往下執行，不像Promise統一使用一個 catch 截取錯誤的訊息。 情境 2 若任務沒有相依關係的話，使用 asnyc-await 的寫法，這樣程式碼看起來就簡潔一點。 asnyc-await123456789101112131415161718192021222324252627282930313233343536373839404142async function fn1() &#123; try &#123; return 'ok'; &#125; catch(e) &#123; return 'fail'; &#125;&#125;async function fn2() &#123; let result = false; try &#123; result = true; &#125; catch(e) &#123; result = false; &#125; return result;&#125;async function fn3() &#123; let result = false; try &#123; throw 'error'; &#125; catch(e) &#123; result = false; &#125; return result;&#125;// 執行任務(async () =&gt; &#123; let a = await fn1(); let b = await fn2(); let c = await fn3(); console.log(`fn1：$&#123;a&#125;`); console.log(`fn2：$&#123;b&#125;`); console.log(`fn3：$&#123;c&#125;`);&#125;)();// 執行任務// fn1：ok// fn2：true// fn3：false JSBin 參考文章Alex 宅幹嘛-這些年經歷過的同步非同步 with Tommy帮助你开始理解async/await]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Promise</tag>
        <tag>ES6</tag>
        <tag>asnyc-await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-:nth-child選取器]]></title>
    <url>%2F2018%2F05%2F24%2FCSS-nth-child%2F</url>
    <content type="text"><![CDATA[CSS :nth-child(n) 筆記 前言因為有時會搞錯 :nth-child 怎麼選取，又或者寫完後，怎麼想要的元素沒套用上CSS樣式。 :nth-child(an+b) 口訣有時我們選取元素時，會有一個固定的規則性，以下例為說明 公式 :nth-child( 5n+2 ) 口訣 要選 N個裡面 的 第幾個 所以若是 5n+2 的話，就是 每5個裡面 的 第2個。 JS Bin on jsbin.com JS Bin 若是 6n+3 的話，就是 每6個裡面 的 第3個。 JS Bin on jsbin.com JS Bin 注意的事項使用:nth-child(n)時，必須為相同 且 連續的子代物件 12345678&lt;h2&gt;選取 div 的 B&lt;/h2&gt;&lt;div class="boxs"&gt; &lt;span&gt;A&lt;/span&gt; &lt;div&gt;B&lt;/div&gt; &lt;div&gt;C&lt;/div&gt; &lt;div&gt;D&lt;/div&gt; &lt;div&gt;E&lt;/div&gt;&lt;/div&gt; 假設我們想取得 &lt;div&gt;B&lt;/div&gt; 的話，我們會怎麼寫呢？ 錯誤寫法 因為我們用肉眼看的話， B 是在 .box裡面div排第一個，所以我們可能會這樣寫 1234.boxs div:nth-child(1)&#123; color: #fff; background: #25aaff;&#125; JS Bin on jsbin.com JS Bin But…若這樣寫的話，CSS會毫無作用，以上述的程式碼解讀，nth-child(n) 我們要反著看才行，選取條件為 選取 .box 裡面第一個元素之後，再判斷是否為 div 標籤，若是的話，才會套用CSS樣式。 所以根據上面的說法，我們會 .box 裡面第一個元素 =&gt; 取到 &lt;span&gt;A&lt;/span&gt; 判斷是否為 div 標籤 =&gt; 判斷 &lt;span&gt;A&lt;/span&gt; 是否為 div 標籤 經過上面判斷，不符合條件，所以就不會套用CSS樣式了。 正確寫法 12345678910111213141516171819/* 正確寫法 *//*第一種寫法*/.boxs div:nth-child(2)&#123; color: #fff; background: #25aaff;&#125;/*第二種寫法*/.boxs :nth-child(2)&#123; color: #fff; background: #25aaff;&#125;/*第三種寫法*/.boxs div:nth-of-type(1)&#123; color: #fff; background: #25aaff;&#125; JS Bin on jsbin.com JS Bin 依上述的案例，改為選取 class 的話，也是一樣的道理，要符合相同 且 連續的物件。 參考文章Amos 使用CSS3 :nth-child(n)]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>nth-child</tag>
        <tag>nth-of-type</tag>
        <tag>選取器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-事件效能處理]]></title>
    <url>%2F2018%2F05%2F03%2FJS-debounce-throttle%2F</url>
    <content type="text"><![CDATA[了解 debounce &amp; throttle 來處理事件效能的問題。 前言在Youtube直播看到 Alex大大 線上分享JS的運用，這次分享處理事件效能的問題，在此紀錄相關資訊，方便以後複習。 Youtube：Alex 宅幹嘛 - Javascript 30 #6 捲軸動畫與事件效能處理 連續畫面的渲染 requestAnimationFrame如果我們有利用 setTimeout 或 setInterval 要處理連續渲染畫面的需求的話，建議可以改使用 requestAnimationFrame ，避免有時會因為 setTimeout 或 setInterval 設定的時間不正確或太密集的話，導致畫面LAG或不正常的情況發生。 requestAnimationFrame 事件效能問題當JS遇到頻繁觸發事件(如：監聽 window的scroll、resize 事件、user瘋狂Click按鈕…等) 的情況，有時可能會造成效能問題，而且常理來說也不太可能會在幾毫秒間，就需要那麼頻繁觸發Event，所以我們就可以利用 延遲執行 這種方法，來減緩觸發Event的次數，下列分別介紹 debounce 與 throttle 二種差異與用法。 debounce因為 debounce 有很多版本的寫法，所以附上我說明的版本。 debounce1234567891011121314function debounce(func, wait = 20, immediate = true) &#123; var timeout; return function () &#123; var context = this, args = arguments; var later = function () &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125; 情境描述： debounce(function, wait, [immediate]) function = 給糖果 wait： 需要冷靜的時間 immediate： 先給或後給 假設我設定 wait：10秒 以及 immediate：先給 的情況下， 有一個小孩第一次跟媽媽吵著要糖吃(觸發事件，如Scroll、resize…)，而debounce媽媽先給小孩糖果(完成任務)，接著小孩立馬即時瞬間不間斷的，又要瘋狂吵鬧要吃糖(瘋狂觸發事件)，媽媽說你要有達到冷靜10秒後，才會再給糖果，否則就不給糖。 這時有二種情況 小孩依舊瘋狂吵要吃糖，沒有冷靜超過10秒以上，這時媽媽怎樣都不會給糖。 小孩吵了一陣子，終於 有冷靜10秒以上，這時媽媽才再給他一顆糖。 說了那麼多，總結來說就是 當觸發事件完成任務後，下次要再可以成功觸發完成任務的條件，就是需停止觸發事件且超過wait設定的時間，才可以再觸發完成一次任務。 Youtube-debounce解說Youtube-debounce隱性的問題 throttle附上解說的版本，若 limit = 0 的話，就等於 debounce了。 throttle1234567891011121314151617181920212223242526272829function throttle(fun, &#123; wait = 33, limit = 0, immediate = false &#125;) &#123; let timer; let startTime = null; return function () &#123; let context = this, args = arguments; let currentTime = new Date().getTime(); if (startTime === null) &#123; if (!immediate) startTime = currentTime else startTime = currentTime - limit &#125; let waitFun = function () &#123; fun.apply(context, args); startTime = null; &#125; clearTimeout(timer); if (limit &amp;&amp; currentTime - startTime &gt;= limit) &#123; fun.apply(context, args); startTime = currentTime; &#125; else &#123; timer = setTimeout(waitFun, wait); &#125; &#125;&#125; 情境描述： 一樣是「會吵的孩子有糖吃」的故事。 throttle(fun, { wait = 33, limit = 0, immediate = false }) fun = 給糖果 wait： 需要冷靜的時間 limit： 超過最小間隔時間，就給糖 immediate： 先給或後給 假設我設定 wait：10秒 、 limit：5秒 以及 immediate：先給 的情況下， 小孩第一次要糖吃時，throttle媽媽一樣先給小孩糖果，但天下小孩一樣白目(有白色的眼球)，立馬又吵要糖吃，小孩吵鬧依舊沒停止且超過10秒，不過throttle媽媽就比較心軟，小孩雖然一直吵，但媽媽只要每超過5秒一次就會心軟給小孩一個糖吃。 最後總結來說就是 當觸發事件完成任務後，有二種情況可以再觸發完成一次任務 停止觸發事件 且 超過wait設定的時間。 連續觸發時，中間間隔時間有超過 limit設定的時間。 Youtube-throttle解說Alex大-codepen範例 閉包（Closure）上述 debounce 與 throttle 這二段程式碼中，都有使用到 閉包（Closure）的用法了。 以 debounce 為例，他利用 timeout 這變數來紀錄且進行一些判斷，下列為他的生命週期 判斷是否第一次執行，再看 immediate 變數，是設定 先執行or後執行。 若是連續觸發時，就清除上一次的setTimeout。 當連續觸發的最後一次時，就會執行 later函式，並清空timeout變數。 這樣下次連續觸發時，就會再回到 1.開始重新判斷。 debounce解說12345678910111213141516171819202122232425262728function debounce(func, wait = 20, immediate = true) &#123; console.log('debounce~~~~in'); // 紀錄 setTimeout 給的 timeoutID var timeout; return function () &#123; console.log('function~~~~in'); var context = this, args = arguments; var later = function () &#123; // 清空 setTimeout 給的 timeoutID timeout = null; // 若 immediate 是設定「fals(後執行)」時，就會執行func if (!immediate) func.apply(context, args); &#125;; // 判斷是否 先執行 且 第一次 var callNow = immediate &amp;&amp; !timeout; // 當連續觸發時，用來清除上次的setTimeout clearTimeout(timeout); // 連續觸發的最後一次，會執行 later函式 timeout = setTimeout(later, wait); // 若符合「先執行 且 第一次」，就執行func if (callNow) func.apply(context, args); &#125;;&#125; 補充：(提醒自己，不要腦補程式碼跑法)1. 當宣告addEventListener時，會執一次debounce函式，並回傳新的函式，此時就完成閉包（Closure）的寫法。2. 之後每當觸發事件時，都是執行新的函式，就是上例的第 6 ~ 27 之間，而 timeout 就有點像是新函式的全域變數，但不是真的在window的全域變數。(jsbin-捲動畫面並開console看)3. JS是由上往下逐行執行，記得看到最後一行才算結束。4. later函式一開始只是宣告，沒執行，最後要等setTimeout才會執行]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>requestAnimationFrame</tag>
        <tag>debounce</tag>
        <tag>throttle</tag>
        <tag>事件效能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-Flex-進階]]></title>
    <url>%2F2018%2F05%2F01%2FCSS-Flex-advanced%2F</url>
    <content type="text"><![CDATA[這次主要介紹 較不常用 的屬性 前言在Youtube直播看到 Amos大大 在解說Flex各種屬性及運用，在此紀錄自己較不熟悉的部份，方便以後複習。 Youtube：玩轉 CSS FLEX 主軸&amp;次軸 flex-direction：決定 flex 主軸線 方向[ row | row-reverse | column | column-reverse ] 在開始說明前，需再次強調一次 主軸與次軸(交錯軸) 的重要性，因為當主軸設定為 row 或 column 的話，都會連帶影響其他屬性的設定，而產生不一樣的排版出來。 舉例來說，我們拿 flex-basis 這個屬性出來說明，當主軸的方向有所不同時，會影響什麼呢？ 當flex-direction: row時，flex-basis影響的是寬度當flex-direction: column時，flex-basis影響的是高度 舊文參考：CSS - Flex整理幾個時間點，方便以後回頭再複習。align-items(1h13m12s)align-self(1h25m19s)flex-order(1h29m13s)flex-grow(1h39m25s)flex-basis(1h43m15s)flex-shrink(1h46m55s) flex-order重點整理 預設值為 0 ，所以要往前就要小於 0，往後就要大於 0。 設定值需為 整數，小數無效，如：1.5。 運用情境 有 A B C 三塊資訊要顯示，而 B 為最重要的資訊 在 電腦 排序要 A B C (電腦是横的看)在 手機 排序要 B A C (手機是直的看)在 平板 排序要 C B A (←老板來亂指定的) 這時就可以透過 media query 和 flex-order 的配合，在不同裝置上，顯示不同的排序。 時間點：flex-order(1h29m13s) 補充：因為 髒髒 的關係，沒事別出大絕，而且也要一一去設定，怕以後維護不易。 flex-grow將剩餘的空間，切成 n 份後，再分配出去。 案例說明 當 子項目全部加總的長度(600px) &lt; 父項目的總長度(1000px) 時，此時就有「剩餘的空間(1000 - 600 = 400)」，可以讓flex-grow依照比例去分配剩下的空間。 時間點：flex-grow(1h39m25s) 備註：Amos大提到用在單列使用時，做分配還OK，但用在多列使用時，分配起來會跟想像中有點不一樣，較不好掌控。先記一下，以後遇到時，踩到此坑才不會太痛。 JS30有練習到 =&gt; JS30-05-Flex-Panel-Gallery flex-basis重點整理 預設值為 auto 控制 主軸 的長度 flex-direction：決定 flex 主軸線 方向 當主軸是 row 的話，就是控制 寬度 當主軸是 column 的話，就是控制 高度 運用情境 利用 flex-basis 與 flex-grow 配合，當成「grid網格」來使用。 See the Pen flex-basis 與 flex-grow 網格實作 by Kanboo (@Kanboo) on CodePen. 時間點：flex-basis 額外測試 Qflex-basis &amp; max-width &amp; width 權重誰大？ Amax-width &gt; flex-basis &gt; width 權重測試：codepen連結 flex-shrink重點整理 預設值為 1 ， 值設定為 0 的話，代表 不給縮，就以原來值為主。 不可以為負值 運用情境 頁面切版有 左、右 二區，左邊是 menu，右邊是 內容區，這時我們就可以設定 左邊的 flex-shrink: 0;右邊的 flex-shrink: 1; 這樣的話，左邊就會固定寬度，右邊就會自動調整 收縮比。 承上例，因 flex-shrink 是控制收縮，所以再新增 flex-grow 控制伸展，這樣不管畫面拉寬拉窄的話，右邊內容區都可以自動伸展收縮。 公式 先將下列三個值算出 收縮值：flex-shrink 總比值：各子項目寬 * 收縮值，並全部加總的值 超出值：全部子項目寬度的加總 減掉 父層的寬度 最後我們再利用上列的值，針對 每一個的子項目 算出 自己的扣除值 扣除值： (子項目的寬 * 收縮比 / 總比值) * 超出值 這樣的話，每個子項目的寬度去減掉自己的扣除值，就完成收縮的作用了。 下列直接用實例說明 See the Pen flex-shrink公式計算 by Kanboo (@Kanboo) on CodePen. 總比值：100 * 1+100 * 1+100 * 1+100 * 5+100 * 5 = 1300 超出值：(100 * 5) - 300 = 200 扣除值： A：(100 * 1 / 1300) * 200 約 15.38 B：(100 * 1 / 1300) * 200 約 15.38 C：(100 * 1 / 1300) * 200 約 15.38 D：(100 * 5 / 1300) * 200 約 76.92 E：(100 * 5 / 1300) * 200 約 76.92 最後實際的值： A：100 - 15.38 = 84.61 B：100 - 15.38 = 84.61 C：100 - 15.38 = 84.61 D：100 - 76.92 = 23.08 E：100 - 76.92 = 23.08 時間點：flex-shrink 排版問題Q如何使用space-between，但我最後一列沒滿…我不想中間空一格該怎麼做？ A 解法1： 文章：Flex-box: Align last row to grid codepen解法 解法2： Flexbox - last row in grid]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Flex</tag>
        <tag>排版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-30-Whack-A-Mole]]></title>
    <url>%2F2018%2F04%2F27%2FJS30-30-Whack-A-Mole%2F</url>
    <content type="text"><![CDATA[打地鼠遊戲 目標 打地鼠遊戲 成品 [DEMO] | [GitHub] 學習紀錄將此專案拆分成多個小部份，一個一個完成後，再將它們組合起來。需完成事項清單： 隨機出現哪隻地鼠 地鼠出現停留的時間 如何開始遊戲與結束遊戲 遊戲的總時間 判斷是否有打到地鼠 紀錄打到地鼠的分數 開發的過程順序如下 1. 先完成 隨機出現哪隻地鼠 和 地鼠出現停留的時間 這二個的部份，所以函式分別為 randomHole() 和 randomTime()。 2. 接下來的部份為 如何開始遊戲與結束遊戲 和 遊戲的總時間，所以對照的函式為 peep() 和 startGame()。 3. 最後就是 判斷是否有打到地鼠 和 紀錄打到地鼠的分數 了，對照的函式為 監聽每隻地鼠click事件 與 bonk()。 整段程式碼12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const holes = document.querySelectorAll('.hole'); // 地洞const scoreBoard = document.querySelector('.score'); // 分數const moles = document.querySelectorAll('.mole'); // 地鼠let lastHole; // 紀錄 最後一次出現的地洞let timeUp = false; // 開關遊戲Flag(false:開，true：關)let score = 0; // 紀錄分數// 回傳 一個隨機數字function randomTime(min, max) &#123; // 產生一個小數點後四捨五入的亂數時間區間 return Math.round(Math.random() * (max - min) + min);&#125;// 回傳 一個隨機的地洞function randomHole(holes) &#123; const idx = Math.floor(Math.random() * holes.length); const hole = holes[idx]; // 判斷 若是與最後一次相同，則重新取得 if (hole === lastHole) &#123; console.log('與上次重覆了！！'); return randomHole(holes); &#125; // 紀錄 最後一次的地洞 lastHole = hole; return hole;&#125;// 呼叫地鼠出現function peep() &#123; const time = randomTime(200, 1000); // 取得 地鼠出現停留的時間 const hole = randomHole(holes); // 隨機取得一個地鼠 // 新增class(地鼠出現) hole.classList.add('up'); // 出現時間結束後，移除class setTimeout(() =&gt; &#123; // 移除class(地鼠消失) hole.classList.remove('up'); // 判斷是否結束遊戲 if (!timeUp) peep(); &#125;, time);&#125;// 啟動遊戲function startGame() &#123; // 清空遊戲分數 scoreBoard.textContent = 0; // 開關遊戲Flag(false:開，true：關) timeUp = false; // 紀錄遊戲分數 score = 0; // 啟動遊戲 peep(); // 設定遊戲時間(時間到關掉遊戲) setTimeout(() =&gt; timeUp = true, 10000)&#125;// 打地鼠function bonk(e) &#123; // e.isTrusted // 若事件物件是由「使用者操作」而產生，isTrusted 值為 true // 若事件物件是由程式碼所建立、修改，或是透過 EventTarget.dispatchEvent() 來觸發，則 isTrusted 值為 false。 // https://www.w3schools.com/jsref/event_istrusted.asp // 防止腳本操作(避免別人用程式呼叫，俗稱外掛) if(!e.isTrusted) return; // 加一分 score++; // 移除class(地鼠消失) this.parentNode.classList.remove('up'); // 更新UI總分數 scoreBoard.textContent = score;&#125;moles.forEach(mole =&gt; mole.addEventListener('click', bonk)); e.isTrusted]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-29-Countdown-Timer]]></title>
    <url>%2F2018%2F04%2F26%2FJS30-29-Countdown-Timer%2F</url>
    <content type="text"><![CDATA[完成可自定義時間的倒數計時器 目標 完成可自定義時間的倒數計時器。 成品 [DEMO] | [GitHub] 學習紀錄將此專案拆分為多個部份，然後再依序慢慢完成一部份的小功能，最終就會完成一個成型的專案，下列為拆分出來的小功能 完成計時函式 UI顯示倒數時間 UI顯示結束時間 監聽倒數時間的按鈕 客制自訂時間倒數 至於上述的功能，沒有一定的先後順序，都是可以獨立完成的，只是寫Code前，可以多想一下，哪些功能先完成的話，會較利於下一個小功能開發時，可以更方便測試或節省開發時間…等因素 一、完成計時函式計時函式12345678910111213141516171819202122232425262728let countdown;function timer(seconds) &#123; // 取得 現在時間 const now = Date.now(); // 取得 現在時間 + 計時秒數 const then = now + seconds * 1000; // 顯示倒數時間 console.log(seconds); // 每秒執行一次，刷新資料 // 將 setInterval 設定在 countdown變數， // 以便於後面可用程式指定結束 setInterval。 countdown = setInterval(() =&gt; &#123; // 計算 倒數的總秒數 const secondsLeft = Math.round((then - Date.now()) / 1000); // 倒數完畢後，結束 setInterval if(secondsLeft &lt; 0) &#123; clearInterval(countdown); return; &#125; // 顯示倒數時間 console.log(secondsLeft); &#125;, 1000);&#125; 二、UI顯示倒數時間UI顯示倒數時間12345678910111213141516const timerDisplay = document.querySelector('.display__time-left');// 顯示倒數時間function displayTimeLeft(seconds) &#123; // 取得 分 const minutes = Math.floor(seconds / 60); // 取得 秒 const remainderSeconds = seconds % 60; // 在顯示秒數部份，若秒數小於10，在個位數前面補零 const display = `$&#123;minutes&#125;:$&#123;remainderSeconds &lt; 10 ? '0' : '' &#125;$&#123;remainderSeconds&#125;`; // 顯示至畫面上 document.title = display; timerDisplay.textContent = display;&#125; 因為完成了 UI顯示倒數時間 功能，所以就可以更新剛剛完成的 計時函式，更新如下 更新 計時函式123456789101112131415function timer(seconds) &#123; // ...略 // 顯示倒數時間- console.log(seconds);+ displayTimeLeft(seconds); countdown = setInterval(() =&gt; &#123; // ...略 // 顯示倒數時間- console.log(secondsLeft);+ displayTimeLeft(secondsLeft); &#125;, 1000);&#125; 三、UI顯示結束時間UI顯示結束時間1234567891011121314151617const endTime = document.querySelector('.display__end-time');// 顯示結束時間function displayEndTime(timestamp) &#123; // 將 總秒數 轉換為 時間格式 const end = new Date(timestamp); // 取得 小時 const hour = end.getHours(); // 將 小時 轉換 12小時制 const adjustedHour = hour &gt; 12 ? hour - 12 : hour; // 取得 分鐘 const minutes = end.getMinutes(); // 在顯示 分鐘 部份，若小於10，在個位數前面補零 endTime.textContent = `Be Back At $&#123;adjustedHour&#125;:$&#123;minutes &lt; 10 ? '0' : ''&#125;$&#123;minutes&#125;`;&#125; 跟上面步驟一樣，完成此函式後，就可以再次更新 計時函式，更新如下 更新 計時函式12345678910function timer(seconds) &#123; // ...略 // 顯示倒數時間 displayTimeLeft(seconds);+ // 顯示結束時間+ displayEndTime(then); // ...略&#125; 四、監聽倒數時間的按鈕監聽倒數時間的按鈕123456789101112const buttons = document.querySelectorAll('[data-time]');// 啟動 倒數時間function startTimer() &#123; // 取得 data-time 的數值 const seconds = parseInt(this.dataset.time); // 傳入 計時函式 timer(seconds);&#125;// 遍歷按鈕 並加上 監聽事件buttons.forEach(button =&gt; button.addEventListener('click', startTimer)); 到這裡看似沒什麼問題，不過當連續點擊倒數按鈕的話，會連續呼叫計時函式，本來連續呼叫函式，應該是沒什麼問題的，但就是因為有使用到 setInterval，所以如果我連續點了 5下 按鈕，這時就會產生5組的setInterval同時在循環執行，導致畫面就會出現怪怪的問題，而修正的方法就是 每當 啟動倒數時間 時，要先清除上一次的setInterval。 修正bug 計時函式123456789function timer(seconds) &#123;+ // 因要重新倒數，清除之前設定+ clearInterval(countdown); // 取得 現在時間 const now = Date.now(); // ...略&#125; 五、客制自訂時間倒數1234567891011// 客制自訂時間倒數document.customForm.addEventListener('submit', function(e) &#123; // 取消 submit 後，頁面跳轉 e.preventDefault(); // 取得 時間 const mins = this.minutes.value; // 傳入 計時函式 timer(mins * 60); // 清空欄位 this.reset();&#125;);]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-28-Video-Speed-Controller]]></title>
    <url>%2F2018%2F04%2F26%2FJS30-28-Video-Speed-Controller%2F</url>
    <content type="text"><![CDATA[用滑鼠控制影片播放速率 目標 用滑鼠控制影片播放速率。 成品 [DEMO] | [GitHub] 學習紀錄此次重點在於 滑鼠在 速率條移動 時，如何取得正確的座標 滑鼠移動的座標 與 速率條 二者之間，如何計算出比例轉換成 速率值 整段程式碼123456789101112131415161718192021222324252627const speed = document.querySelector('.speed');const bar = speed.querySelector('.speed-bar');const video = document.querySelector('.flex');speed.addEventListener('mousemove', function(e)&#123; // console.log(e); // 取得滑鼠在元素移動的座標 const y = e.pageY - this.offsetTop; // 計算滑鼠移到的座標點，佔元素比例是多少 const percent = y / this.offsetHeight; // 比例 轉成 百分比 const height = Math.round(percent * 100) + '%'; // 修改 速度條 的高度 bar.style.height = height; // 設定 最慢速率、最快速率 const min = 0.4; const max = 4; // 取得播放速率(最慢0.4倍，最多4倍速) const playbackRate = percent * (max - min) + min; // 最多取得小數點後兩位 bar.textContent = playbackRate.toFixed(2) + '×'; // 控制影片的速率 video.playbackRate = playbackRate;&#125;)]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-27-Click-and-Drag]]></title>
    <url>%2F2018%2F04%2F24%2FJS30-27-Click-and-Drag%2F</url>
    <content type="text"><![CDATA[可用滑鼠點擊拖曳水平的畫面 目標 可用滑鼠點擊拖曳水平的畫面。 成品 [DEMO] | [GitHub] 學習紀錄重點在於如何計算滑鼠點擊拖移畫面時，是往左或往右，以及如何計算出要移動的定位點是多少。 一、取得相關元素及監聽滑鼠事件取得相關元素及監聽滑鼠事件12345678910111213const slider = document.querySelector('.items');let isDown = false; //紀錄 滑鼠是否點擊的狀態let startX; // 紀錄 滑鼠最初點擊的位置let scrollLeft;// 滑鼠 點擊slider.addEventListener('mousedown', () =&gt; &#123;&#125;);// 滑鼠 超出範圍slider.addEventListener('mouseleave', () =&gt; &#123;&#125;);// 滑鼠 按鍵放開slider.addEventListener('mouseup', () =&gt; &#123;&#125;);// 滑鼠 移動slider.addEventListener('mousemove', () =&gt; &#123;&#125;); 二、分別針對不同滑鼠事件撰寫主要處理的重點在 滑鼠點擊 和 滑鼠移動 這二個事件。 滑鼠 點擊 12345678910111213// 滑鼠點擊slider.addEventListener('mousedown', (e) =&gt; &#123; isDown = true; slider.classList.add('active'); // 紀錄 點擊初始位置 // e.pageX：整個頁面的 x軸 距離 // slider.offsetLeft：目前DOM位於父元素的X座標 startX = e.pageX - slider.offsetLeft; // 紀錄 目前捲軸的左距 scrollLeft = slider.scrollLeft;&#125;); Q其中 startX 這個變數的計算，為什麼不可直接使用 e.pageX 呢？為何還要扣掉slider.offsetLeft？A原因是 滑動捲軸 是出現在 &lt;div class=&quot;items&quot;&gt; 身上，而非在整個頁面，所以當然只能計算在 &lt;div class=&quot;items&quot;&gt; 區塊裡，已移動了多少距離。 滑鼠 移動 1234567891011121314151617// 滑鼠移動slider.addEventListener('mousemove', (e) =&gt; &#123; // 非點擊狀態時，不作用 if (!isDown) return; // 取消預設行為(點擊且拖移的動作，預設行為是 選取範圍) e.preventDefault(); // 目前位置 = 整個頁面x軸距離 - 目前items的左邊距離 const x = e.pageX - slider.offsetLeft; // 移動距離 = 目前位置 - 點擊初始位置 const walk = x - startX; // const walk = (x - startX) * 3; //乘3倍的概念，感覺像增加滑鼠的敏感度 // 設定 .items區塊 的 水平捲軸偏移量 slider.scrollLeft = scrollLeft - walk;&#125;); 滑鼠 超出範圍 123456// 滑鼠超出範圍slider.addEventListener('mouseleave', () =&gt; &#123; // 取消狀態及樣式 isDown = false; slider.classList.remove('active');&#125;); 滑鼠 點擊 123456// 滑鼠按鍵放開slider.addEventListener('mouseup', () =&gt; &#123; // 取消狀態及樣式 isDown = false; slider.classList.remove('active');&#125;); MouseEvent.pageXElement.scrollLeft]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-26-Stripe-Follow-Along-Nav]]></title>
    <url>%2F2018%2F04%2F23%2FJS30-26-Stripe-Follow-Along-Nav%2F</url>
    <content type="text"><![CDATA[navbar次導覽列的動態效果 目標 navbar次導覽列的動態效果。 成品 [DEMO] | [GitHub] 開發建議作法 先建置 HTML架構 新增CSS及特殊效果，可利用Chrome開發工具，測試CSS效果大致上沒問題後。 再開始用JS處理 新增、移除、微調 CSS的部份。 學習紀錄一、準備好HTML架構及CSS效果HTML架構123456789101112131415161718192021222324252627282930&lt;!-- Navbar --&gt;&lt;nav class="top"&gt; &lt;!-- 下拉選單背景，到時用JS控制 大小、定位顯示 --&gt; &lt;div class="dropdownBackground"&gt; &lt;span class="arrow"&gt;&lt;/span&gt; &lt;/div&gt; &lt;!-- 選單 --&gt; &lt;ul class="cool"&gt; &lt;li&gt; &lt;a href="#"&gt;About Me&lt;/a&gt; &lt;div class="dropdown dropdown1"&gt; &lt;!-- 下拉選單內容 --&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;Courses&lt;/a&gt; &lt;ul class="dropdown courses"&gt; &lt;!-- 下拉選單內容 --&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;Other Links&lt;/a&gt; &lt;ul class="dropdown dropdown3"&gt; &lt;!-- 下拉選單內容 --&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 準備好CSS顯示的部份1234567891011121314/* 將 下拉選單內容 顯示 */.trigger-enter .dropdown &#123; display: block;&#125;/* 將 下拉選單內容 透明度改1 */.trigger-enter-active .dropdown &#123; opacity: 1;&#125;/* 將 下拉選單背景 透明度改1 */.dropdownBackground.open &#123; opacity: 1;&#125; 二、選單綁上監聽事件主要的效果切換，就是在滑鼠的移入、移出這二個動作。 綁上監聽事件1234567891011121314151617const triggers = document.querySelectorAll('.cool &gt; li'); // 選單const background = document.querySelector('.dropdownBackground'); // 選單背景const nav = document.querySelector('.top'); // navbar// 滑鼠移入事件function handleEnter() &#123; console.log('ENTER~~');&#125;// 滑鼠移出事件function handleLeave() &#123; console.log('Leave!!');&#125;// 為每個選單綁上 滑鼠移入、移出 監聽事件triggers.forEach(trigger =&gt; trigger.addEventListener('mouseenter', handleEnter));triggers.forEach(trigger =&gt; trigger.addEventListener('mouseleave', handleLeave)); 三、新增動態效果滑鼠移入事件12345678910111213141516171819202122232425262728293031323334353637383940// 滑鼠移入事件function handleEnter() &#123; // console.log('ENTER~~'); // 將 下拉選單內容 顯示 this.classList.add('trigger-enter'); // 為了避免快速滑動導覽列產生錯亂，因此在 setTimeout 上增加判斷， // 當滑鼠移入時，先檢查是否有 trigger-enter 的className， // 若 有 的話，才新增 trigger-enter-active 的className， // 若 無 的話，則只會一直顯示 白色選單背景 的部分，內容不會被顯示出來。 setTimeout(() =&gt; this.classList.contains('trigger-enter') &amp;&amp; this.classList.add('trigger-enter-active'), 150); // 新增 open class，配合 下拉選單背景 使用 background.classList.add('open'); // 取得目前滑入元素底下的 dropdown const dropdown = this.querySelector('.dropdown'); // 取得 dropdown 的 大小、定位 資訊 const dropdownCoords = dropdown.getBoundingClientRect(); // 取得 navbar 的 大小、定位 資訊 const navCoords = nav.getBoundingClientRect(); // 設定 下拉選單背景 的 大小、定位 const coords = &#123; height: dropdownCoords.height, width: dropdownCoords.width, // 因為 getBoundingClientRect 是取得 目標元素相對於「瀏覽器視窗」的位置資訊， // 而 transform的translate 是根據 「父元素」 來定位， // 為了統一以「父元素」為基準點， // 所以要扣掉 navbar 的定位，避免上方區塊增加時造成的錯位， top: dropdownCoords.top - navCoords.top, left: dropdownCoords.left - navCoords.left &#125;; // 設定 下拉選單背景 的 大小、定位 background.style.setProperty('width', `$&#123;coords.width&#125;px`); background.style.setProperty('height', `$&#123;coords.height&#125;px`); background.style.setProperty('transform', `translate($&#123;coords.left&#125;px, $&#123;coords.top&#125;px)`);&#125; 滑鼠移出事件123456// 滑鼠移出事件function handleLeave() &#123; // console.log('Leave!!'); this.classList.remove('trigger-enter', 'trigger-enter-active'); background.classList.remove('open');&#125;]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-25-Event-Capture-Propagation-Bubbling-and-Once]]></title>
    <url>%2F2018%2F04%2F23%2FJS30-25-Event-Capture-Propagation-Bubbling-and-Once%2F</url>
    <content type="text"><![CDATA[了解 addEventListener 的運作 目標 了解 addEventListener 的運作 事件冒泡 (Event Bubbling) 停止冒泡行為 e.stopPropagation() 事件捕獲 (Event Capturing) 單次觸發 成品 [DEMO] | [GitHub] 學習紀錄事件傳遞順序使用 addEventListener 時，不管是設定 Event Bubbling 或 Event Capturing，當Event被觸發時，都是會先從 最外層DOM 走到 target的DOM 然後再走回 最外層DOM，所以當你設定 Event Bubbling(綠色路徑)：只回傳 target的DOM →→ 最外層DOM 的路徑 Event Capturing(紅色路徑)：只回傳 最外層DOM →→ target的DOM 的路徑 所以根據上面的規則，套用在下面的案例的話 HTML123456789&lt;div class="one purple"&gt; 紫色 &lt;div class="two pink"&gt; 粉色 &lt;div class="three orange"&gt; 橘色 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 事件冒泡 (Event Bubbling)：只回傳 target的DOM →→ 最外層DOM 的路徑 事件冒泡 (Event Bubbling)123456789101112131415function logText(e) &#123; // 印出當前div的class name console.log(this.classList.value);&#125;// 第三個參數 useCapture：預設為 false → 事件冒泡 (Event Bubbling)divs.forEach(div =&gt; div.addEventListener('click', logText));/*console列出順序為(target的DOM →→ 最外層DOM)three orangetwo pinkone purple*/ 事件捕獲 (Event Capturing)：只回傳 最外層DOM →→ target的DOM 的路徑 事件捕獲 (Event Capturing)123456789101112131415function logText(e) &#123; // 印出當前div的class name console.log(this.classList.value);&#125;// 第三個參數 useCapture 修改為 true → 事件捕獲 (Event Capturing)divs.forEach(div =&gt; div.addEventListener('click', logText, true));/*console列出順序為(最外層DOM →→ target的DOM)one purpletwo pinkthree orange*/ JS-事件機制的原理 停止冒泡行為 e.stopPropagation()有時只是想單純針對單一元素監聽，不想因為事件冒泡的行為，而去觸發到其他元素，這時就可利用 e.stopPropagation() 來達成此需求。 e.stopPropagation()123456function logText(e) &#123; console.log(this.classList.value); // 停止冒泡行為！ e.stopPropagation();&#125; 注意：使用 e.stopPropagation() 僅針對 事件冒泡 (Event Bubbling) 設定，若是設定為 事件捕獲 (Event Capturing) 的話，則不適用 e.stopPropagation()。 單次觸發once 屬性：當第一次被觸發後，就會移除本身的監聽事件，後續就沒有監聽事件。 目前想到的可運用在表單submit後，解除監聽事件，避免重覆送單。 單次觸發1234567// 在 button 的 addEventListener 第三個參數裡，設定 once 的屬性// 當第一次被觸發後，就會移除本身的監聽事件，後續就沒有監聽事件。button.addEventListener('click', () =&gt; &#123; console.log('Click!!!');&#125;, &#123; once: true&#125;); EventTarget.addEventListener()]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-24-Sticky-Nav]]></title>
    <url>%2F2018%2F04%2F21%2FJS30-24-Sticky-Nav%2F</url>
    <content type="text"><![CDATA[利用一些小技巧，處理navbar的動畫效果 目標 利用一些小技巧，處理navbar的動畫效果。 實踐步驟 監聽 window的scroll 事件 新增 nav的CSS樣式 判斷頁面高度是否已到達特定高度，切換CSS 成品 [DEMO] | [GitHub] 學習紀錄此次重點在於動畫的切換時，可以注意的一些小技巧 當DOM元素position變fixed時，要補足原本佔有的空間 籍由scale縮放的效果，提升視覺感受 針對fixed，新增的CSS123456789101112131415/* 當有 fixed-nav 時，把 site-wrap 縮放回1，讓整體有放大效果*/.fixed-nav .site-wrap &#123; transform: scale(1);&#125;/* 當有 fixed-nav 時，把 nav 固定，並加上陰影*/.fixed-nav nav &#123; position: fixed; box-shadow:0 5px 0 rgba(0,0,0,0.1);&#125;/* 當有 fixed-nav 時，把logo寬度增加*/.fixed-nav li.logo &#123; max-width: 500px;&#125; JS部份12345678910111213141516171819202122// 取得 nav元素const nav = document.querySelector('#main');// 取得 nav頂部 到 &lt;body&gt;頂部 的距離 (目前DOM元素位於父元素的Y座標)let topOfNav = nav.offsetTop;function fixNav() &#123; if (window.scrollY &gt;= topOfNav) &#123; // 注意： // 當DOM元素的 position 被設定為 fixed 時，將不會再佔據原有的高度， // 所以要動態的增加「原本DOM元素的offsetHeight」，用來補足原本DOM元素的高度， // 避免切換position屬性時，造成怪異的彈跳情況。 document.body.style.paddingTop = nav.offsetHeight + 'px'; document.body.classList.add('fixed-nav'); &#125; else &#123; document.body.classList.remove('fixed-nav'); document.body.style.paddingTop = 0; &#125;&#125;// 監聽 滾動 事件window.addEventListener('scroll', fixNav);]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-23-Speech-Synthesis]]></title>
    <url>%2F2018%2F04%2F21%2FJS30-23-Speech-Synthesis%2F</url>
    <content type="text"><![CDATA[將文字轉語音(可變更速率及音調) 目標 將文字轉語音(可變更速率及音調)。 實踐步驟 取得 相關DOM元素 並設定 SpeechSynthesisUtterance(語音設定) 監聽 SpeechSynthesis(語音播放) 的 voiceschanged 事件，取得 語系 相關資料 設定 發音語系 監聽 語系是否變更，更新語音設定，並播放語音 監聽 速率、音調、文字區塊 是否變更，更新語音設定，並播放語音 監聽 buttom 的 click事件，播放或取消語音 成品 [DEMO] | [GitHub] JS學習紀錄一、取得 相關DOM元素 並設定 SpeechSynthesisUtterance(語音設定)12345678910111213// 設定語音服務應讀取的文字內容及播放的細節(語言、音調、聲音、速率...等屬性)const msg = new SpeechSynthesisUtterance();let voices = [];const voicesDropdown = document.querySelector('[name="voice"]');const options = document.querySelectorAll('[type="range"], [name="text"]');const speakButton = document.querySelector('#speak');const stopButton = document.querySelector('#stop');// 設定發音的文字內容msg.text = document.querySelector('[name="text"]').value;// 將一段文字加入發音庫，播放此發音。speechSynthesis.speak(msg); // 測試用 二、監聽 SpeechSynthesis(語音播放) 的 voiceschanged 事件，取得 語系 相關資料1234567891011121314// 取得 語系 相關資料function populateVoices() &#123; /* 取得 speechSynthesis 中所有的 SpeechSynthesisVoice 物件， 而物件的屬性為 所有發音的資訊 */ voices = this.getVoices(); // 取出所有語系，組成HTML後，更新下拉清單的值 voicesDropdown.innerHTML = voices .map(voice =&gt; `&lt;option value="$&#123;voice.name&#125;"&gt;$&#123;voice.name&#125; ($&#123;voice.lang&#125;)&lt;/option&gt;`) .join('');&#125;// 監聽 voiceschanged 事件(當 SpeechSynthesisVoice 清單改變時，就會觸發此事件)speechSynthesis.addEventListener('voiceschanged', populateVoices); 三、設定 發音語系12345// 設定 發音語系function setVoice() &#123; // 根據select挑選的值，從所有的 SpeechSynthesisVoice 物件中，取出符合條件的物件 msg.voice = voices.find(voice =&gt; voice.name === this.value);&#125; 四、監聽 語系是否變更，更新語音設定，並播放語音123456789101112131415161718192021// 設定 發音語系function setVoice() &#123; // 根據select挑選的值，從所有的 SpeechSynthesisVoice 物件中，取出符合條件的物件 msg.voice = voices.find(voice =&gt; voice.name === this.value);+ // 播放語音+ toggle();&#125;+// 觸發 播放語音+function toggle(startOver = true) &#123;+ // 移除所有的發音資訊+ speechSynthesis.cancel();+ // 將一段文字加入發音庫，播放語音+ if (startOver) &#123;+ speechSynthesis.speak(msg);+ &#125;+&#125;+// 監聽 語系 是否變更+voicesDropdown.addEventListener('change', setVoice); 五、監聽 速率、音調、文字區塊 是否變更，更新語音設定，並播放語音透過 DOM元素的命名方式，將 name命名 與 SpeechSynthesisUtterance物件屬性 取一樣名稱，在二邊的配合下，這樣就可以更精簡程式碼。 1234567891011121314151617// 設定速率跟音準function setOption() &#123; /* 透過 DOM元素的命名方式， 將 name命名 與 SpeechSynthesisUtterance物件屬性 取一樣名稱， 在二邊的配合下，這樣就可以更精簡程式碼。 */ // 更新 語音設定 msg[this.name] = this.value; // 播放語音 toggle();&#125;// 監聽 速率、音調、文字區塊 是否變更options.forEach(option =&gt; option.addEventListener('change', setOption)); 六、監聽 buttom 的 click事件，播放或取消語音123456789101112131415// 觸發 播放語音function toggle(startOver = true) &#123; // 移除所有的發音資訊 speechSynthesis.cancel(); // 將一段文字加入發音庫，播放語音 if (startOver) &#123; speechSynthesis.speak(msg); &#125;&#125;+// 播放按鈕+speakButton.addEventListener('click', toggle);+// 停止按鈕+stopButton.addEventListener('click', () =&gt; toggle(false)); SpeechSynthesisUtterance(語音設定)SpeechSynthesis(語音播放) 觀念補充 在使用 addEventListener 時，若遇到需傳入參數的話，不可直接用下列此方式，會導致功能不正常。 功能不正常12// 不能直接寫 function並加上參數stopButton.addEventListener('click', toggle(false)); 可透過下列二種方式，傳入參數值。 解決方式1234567// 寫法1stopButton.addEventListener("click", function()&#123; toggle(false);&#125;)// 寫法2:arrow functionstopButton.addEventListener("click", () =&gt; toggle(false))]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-22-Follow-Along-Link-Highlighter]]></title>
    <url>%2F2018%2F04%2F21%2FJS30-22-Follow-Along-Link-Highlighter%2F</url>
    <content type="text"><![CDATA[滑鼠移動到特定位置產生highlight效果 目標 滑鼠移動到特定位置產生highlight效果。 實踐步驟 取得所有 a元素，並監聽 mouseenter 事件 建立一個 span 來產生 highlight 效果 更新span的寬高及定位 成品 [DEMO] | [GitHub] JS學習紀錄此次重點在於 如何正確計算元素定位座標(考量window.scroll因素) 一、取得所有 a元素，並監聽 mouseenter 事件123456/* step 1. 取得所有 a元素，並監聽 mouseenter 事件 */// 取得HTML中所有的a元素const triggers = document.querySelectorAll('a');// 監聽所有 a元素 的 滑鼠移入 事件triggers.forEach(a =&gt; a.addEventListener('mouseenter', highlightLink)); 二、建立一個 span 來產生 highlight 效果12345/* step 2. 建立一個 span 來產生 highlight 效果 */const highlight = document.createElement('span');highlight.classList.add('highlight');// 將建立的 span 加到頁面中document.body.append(highlight); 三、更新 span 的 寬高及定位初版 一開始雖然有達到 highlight效果，不過因為 window捲軸滾動 的關係，所以當捲軸有往下滑時，此時再更新 span的定位 後，highlight效果就會有位置偏差的問題，沒顯示在準確的位置。 12345678910/* step 3. 更新span的「寬高、定位」，讓 highlight效果 在準確的位置 */function highlightLink() &#123; // 目標元素的 大小 與 相對於瀏覽器視窗的位置資訊 const linkCoords = this.getBoundingClientRect(); // 設定 highlight效果 的 寬高及定位 highlight.style.width = `$&#123;linkCoords.width&#125;px`; highlight.style.height = `$&#123;linkCoords.height&#125;px`; highlight.style.transform = `translate($&#123;linkCoords.left&#125;px, $&#123;linkCoords.top&#125;px)`;&#125; 修正版 因為 window捲軸滾動 的因素，必須加上 scroll移動值，來修正偏差的位置。 12345678910111213141516171819/* step 3. 更新span的「寬高、定位」，讓 highlight效果 在準確的位置 */function highlightLink() &#123; // 目標元素的 大小 與 相對於瀏覽器視窗的位置資訊 const linkCoords = this.getBoundingClientRect(); console.log(linkCoords);+ // 儲存span的「寬高、定位」 資訊+ const coords = &#123;+ width: linkCoords.width,+ height: linkCoords.height,+ top: linkCoords.top + window.scrollY, // 定位新增 window.scroll 的影響因素+ left: linkCoords.left + window.scrollX // 定位新增 window.scroll 的影響因素+ &#125;; // 設定 highlight效果 的「寬高、定位」+ highlight.style.width = `$&#123;coords.width&#125;px`;+ highlight.style.height = `$&#123;coords.height&#125;px`;+ highlight.style.transform = `translate($&#123;coords.left&#125;px, $&#123;coords.top&#125;px)`;&#125; Element.getBoundingClientRect()]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-21-Geolocation]]></title>
    <url>%2F2018%2F04%2F21%2FJS30-21-Geolocation%2F</url>
    <content type="text"><![CDATA[取得裝置的地理位置和速度 目標 取得裝置的地理位置和速度。 實踐步驟 利用 navigator.geolocation 取得裝置的地理位置和速度 成品 [DEMO] | [GitHub] JS學習紀錄紀錄JS如何取得裝置的地理位置和速度。 1234567891011121314151617// 取得DOM元素const arrow = document.querySelector('.arrow');const speed = document.querySelector('.speed-value');// 取得裝置的地理位置和速度navigator.geolocation.watchPosition((data) =&gt; &#123; // 若有成功取得，則會回傳一組 Position console.log(data); // data.coords.speed 取得 速度(公尺/秒) speed.textContent = data.coords.speed; // data.coords.heading 取得 角度(0為正北、90為正東) arrow.style.transform = `rotate($&#123;data.coords.heading&#125;deg)`;&#125;, (err) =&gt; &#123; console.error(err);&#125;); Geolocation]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-20-Speech-Detection]]></title>
    <url>%2F2018%2F04%2F21%2FJS30-20-Speech-Detection%2F</url>
    <content type="text"><![CDATA[利用麥克風說話，將語音轉成文字。 目標 利用麥克風說話，將語音轉成文字。 實踐步驟 建立語音辨識物件 新增文字區塊 監聽並寫入語音資料 成品 [DEMO] | [GitHub] JS學習紀錄紀錄JS如何使用語音的物件。 一、建立語音辨識物件12345678910/* setp 1. 建立語音辨識物件 */// 將全域環境中的 SpeechRecognition 設定好，根據不同瀏覽器window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;// 建立 語音識別功能const recognition = new SpeechRecognition();// 允許語音辨識回傳識別後的資料recognition.interimResults = true;// 開始識別recognition.start(); 二、新增文字區塊1234/* setp 2. 新增文字區塊 */let p = document.createElement('p');const words = document.querySelector('.words');words.appendChild(p); 三、監聽並寫入語音資料1234567891011121314151617181920212223242526/* setp 3. 監聽並寫入語音資料 */// 監聽識別回傳recognition.addEventListener('result', e =&gt; &#123; // 回傳資料為 nodelist，故轉為 array 執行 const transcript = Array.from(e.results) // 透過 map 取得 陣列的第1筆 .map(result =&gt; result[0]) // 再取出第1筆的 transcript .map(result =&gt; result.transcript) // 用 join 將連結符號消掉 .join('') // 將回傳的文字，先過濾 髒字 const poopScript = transcript.replace(/poop|poo|shit|dump/gi, '💩'); // 過濾完後，將回傳內容塞到 p元素 p.textContent = poopScript; // 若回傳內容已經結束，再重新建立一個新的 p元素 來放下一次內容 if (e.results[0].isFinal) &#123; p = document.createElement('p'); words.appendChild(p); &#125;&#125;)// 如果語音辨識結束，則重新打開語音辨識。recognition.addEventListener('end', recognition.start); SpeechRecognition.interimResults]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-19-Webcam-Fun]]></title>
    <url>%2F2018%2F04%2F20%2FJS30-19-Webcam-Fun%2F</url>
    <content type="text"><![CDATA[利用視訊鏡頭顯示影片及拍照功能(+濾鏡效果)。 目標 利用視訊鏡頭顯示影片及拍照功能(+濾鏡效果)。 實踐步驟 取得鏡頭影像 MediaStream影像資料 寫入 canvas 新增拍照功能 新增濾鏡效果 成品 [DEMO] | [GitHub] JS學習紀錄第一次使用JS來操作鏡頭影像，所以紀錄一下整個過程，方便以後回想。 一、取得鏡頭影像12345678910111213141516171819202122/* step 1. 取得鏡頭影像 */function getVideo() &#123; // 取得 user 的視訊裝置，並且回傳 Promise 狀態 navigator.mediaDevices.getUserMedia(&#123; video: true, // 鏡頭 audio: false // 聲音 &#125;) /* 回傳 MediaStream 的資料 */ .then(localMediaStream =&gt; &#123; console.log(localMediaStream); /* 將 MediaStream 寫進 html的video標籤 */ video.src = window.URL.createObjectURL(localMediaStream); /* 讓鏡頭持續運作 */ video.play(); &#125;) .catch(err =&gt; &#123; console.error(`!!Error!!`, err); &#125;);&#125;// 啟動鏡頭getVideo(); MediaDevices.getUserMedia()HTML5 的 Object URL 二、MediaStream影像資料 寫入 canvas1234567891011121314151617/* step 2. MediaStream 寫入 canvas */function paintToCanvas() &#123; const width = video.videoWidth; const height = video.videoHeight; canvas.width = width; canvas.height = height; // 用setInterval來持續取得目前的影像資訊 return setInterval(() =&gt; &#123; // 在 canvas 設置drawImage參數為 (資料來源video, 起始位置X軸, 起始位置Ｙ軸, 長, 寬) ctx.drawImage(video, 0, 0, width, height); // ctx.drawImage(video, 0, 0, 200, 200); &#125;, 16)&#125;/* 監聽video事件，是否啟動 鏡頭 了嗎 */video.addEventListener('canplay', paintToCanvas); CanvasRenderingContext2D.drawImage() 三、新增拍照功能12345678910111213141516171819202122/* step 3. 新增拍照功能 */function takePhoto() &#123; // 將聲音切到 第0秒 並 播放 snap.currentTime = 0; snap.play(); // 將 canvas的內容 轉為 base64的圖檔資訊 const data = canvas.toDataURL('image/jpeg'); // console.log(data); // 用 createElemamnt 來建立一個新的 a 元素 const link = document.createElement('a'); // 設定連結為 base64圖檔 link.href = data; // 設定屬性為：下載 link.setAttribute('download', 'picture'); // a元素裡新增一個 img link.innerHTML = `&lt;img src="$&#123;data&#125;" alt="picture" /&gt;`; // 將 a元素 新增至 strip圖片區塊（在第一筆的位置） strip.insertBefore(link, strip.firstChild);&#125; HTMLCanvasElement.toDataURL()Node.insertBefore() 四、新增濾鏡效果123456789101112131415161718192021222324252627282930313233343536373839404142function paintToCanvas() &#123; // ...略 // 用setInterval來持續取得目前的影像資訊 return setInterval(() =&gt; &#123; // 在 canvas 設置drawImage參數為 (資料來源video, 起始位置X軸, 起始位置Ｙ軸, 長, 寬) ctx.drawImage(video, 0, 0, width, height); // ctx.drawImage(video, 0, 0, 200, 200);+ /* 4. 新增濾鏡效果 */+ // 透過 getImageData 取得 canvans 中所有的像素點(r,g,b,alpha的資訊)+ let pixels = ctx.getImageData(0, 0, width, height);+ // console.log(pixels);+ // 透用濾鏡效果+ // pixels = redEffect(pixels); // 4.1濾鏡效果(紅色)+ pixels = rgbSplit(pixels); // 4.2濾鏡效果(三原色)+ // ctx.globalAlpha = 0.1; // canvas 透明度+ // pixels = greenScreen(pixels); // 4.3濾鏡效果(綠色)+ // 寫入 濾鏡效果+ ctx.putImageData(pixels, 0, 0); &#125;, 16)&#125;+/* step 4-1. 濾鏡效果(紅色) */+function redEffect(pixels) &#123;+ // ...略+&#125;+/* step 4-2. 濾鏡效果(三原色) */+function rgbSplit(pixels) &#123;+ // ...略+&#125;+/* step 4-3. 濾鏡效果(綠色) */+function greenScreen(pixels) &#123;+ // ...略+&#125; canvas 圖像的資料都是數個陣列所組成，數據為數字，順序皆為 RGBA。 CanvasRenderingContext2D.getImageData()CanvasRenderingContext2D.putImageData()]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-18-Adding-Up-Times-with-Reduce]]></title>
    <url>%2F2018%2F04%2F18%2FJS30-18-Adding-Up-Times-with-Reduce%2F</url>
    <content type="text"><![CDATA[利用 map() 與 reduce() 來計算播放清單的總秒數。 目標 利用 map() 與 reduce() 來計算播放清單的總秒數。 實踐步驟 取得所有 data-time 的DOM元素，並轉換成 Array，以便可使用map..等method 計算出總秒數2-1. 取得 時間(分、秒)2-2. 將時間(分、秒)轉化成數字型態，且算成 秒數2-3. 最後將每一首的秒數加總 將 總秒數 計算成 時、分、秒 顯示3-1. 先計算 小時，只取 商數3-2. 剩下的秒數，再計算 分鐘，只取 商數3-3. 最後就是剩餘的 秒數 成品 [DEMO] | [GitHub] JS學習紀錄此次重點在於 運用「map」 如何精進Sort的寫法 一、取得所有要計算時間的元素取得所有要計算時間的元素12345/* 1. 取得所有 data-time 的DOM元素，並轉換成 Array，以便可使用map..等method */const timeNodes = Array.from(document.querySelectorAll('[data-time]'));/* 可簡化如下 */const timeNodes = [...document.querySelectorAll('[data-time]')]; 二、計算出總秒數計算出總秒數1234567891011121314/* 2. 計算出總秒數 */const seconds = timeNodes // 取出每個元素中的data-time資料 .map( node =&gt; node.dataset.time ) // 將 分、秒 拆解並轉成 秒數 .map( time =&gt; &#123; // const [mins, secs] = time.split(':').map( str =&gt; parseFloat(str)); /* 可簡化如下 */ const [mins, secs] = time.split(':').map(parseFloat); return (mins * 60) + secs &#125;) // 用reduce來加總每次執行結果 .reduce( (total , second) =&gt; total + second) 三、.將 總秒數 計算成 時、分、秒 顯示將 總秒數 計算成 時、分、秒 顯示1234567891011121314151617/* 3. 將 總秒數 計算成 時、分、秒 顯示 */// 使用Math.floor取整數，再利用%來操作餘數let secondsLeft = seconds;// 計算 時數const hours = Math.floor(secondsLeft / (60 * 60));// 扣掉 時數// secondsLeft = secondsLeft - (hours * 3600);secondsLeft = secondsLeft % 3600;// 計算 分鐘const minutes = Math.floor(secondsLeft / 60);// 扣掉 分鐘，剩下的就是 秒數// secondsLeft = secondsLeft - (minutes * 60);secondsLeft = secondsLeft % 60; Array.map() 呼叫 function作者在範例中，在Array.map()又Call Function，還可以再簡化寫法， 不過目前對我還不是很直覺可以寫出這種，先在此紀錄一下。 123const [mins, secs] = time.split(':').map( str =&gt; parseFloat(str));// 可簡化如下const [mins, secs] = time.split(':').map(parseFloat);]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-17-Sort-Without-Articles]]></title>
    <url>%2F2018%2F04%2F18%2FJS30-17-Sort-Without-Articles%2F</url>
    <content type="text"><![CDATA[將陣列中的資料，去除冠詞(Articles)後，再進行排序。 目標 將陣列中的資料，去除冠詞(Articles)後，再進行排序。 實踐步驟 取得陣列 去除 冠詞 的字眼 sort的寫法 成品 [DEMO] | [GitHub] JS學習紀錄此次重點在於 運用「正規表達式」 如何精進Sort的寫法 整段程式碼123456789101112131415161718192021const bands = ['The Plot in You', 'The Devil Wears Prada', 'Pierce the Veil','Norma Jean', 'The Bled', 'Say Anything', 'The Midway State','We Came as Romans', 'Counterparts', 'Oh, Sleeper', 'A Skylit Drive','Anywhere But Here', 'An Old Dog'];// 去除 冠詞 的字眼// 使用replace搭配正規表示式來將包含了a, the, an開頭的文字替換為空白。function strip(bandName)&#123; // ^：比對輸入列的啟始位置 // i：Case-insensitive search return bandName.replace(/^(a |the |an )/i, '').trim();&#125;// sort寫法3：利用 箭頭函數 與 三元運算式的簡寫const sortBands = bands.sort((a, b) =&gt; strip(a) &gt; strip(b) ? 1 : -1);// 寫入HTMLdocument.querySelector('#bands').innerHTML = sortBands .map( band =&gt; `&lt;li&gt;$&#123;band&#125;&lt;/li&gt;`) .join(''); sort寫法簡化 從上面程式碼，將「sort程式碼」簡化過程，呈現在下方，做個紀錄。 簡化過程12345678910111213141516// sort寫法1：const sortBands = bands.sort((a, b) =&gt;&#123; if (strip(a) &gt; strip(b))&#123; return 1; &#125;else&#123; return -1; &#125;&#125;)// sort寫法2：利用 三元運算式的簡寫const sortBands = bands.sort((a, b) =&gt;&#123; return strip(a) &gt; strip(b) ? 1 : -1&#125;)// sort寫法3：利用 箭頭函數 與 三元運算式的簡寫const sortBands = bands.sort((a, b) =&gt; strip(a) &gt; strip(b) ? 1 : -1);]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-16-Mouse-Move-Shadow]]></title>
    <url>%2F2018%2F04%2F18%2FJS30-16-Mouse-Move-Shadow%2F</url>
    <content type="text"><![CDATA[滑鼠移動時，讓文字的陰影跟著移動。 目標 滑鼠移動時，讓文字的陰影跟著移動。 實踐步驟 取得取得文字區域的元件 監聽 mousemove 取得 hero 的 寬、高 取得滑鼠的座標 計算位置與比例，修改textShadow屬性值 成品 [DEMO] | [GitHub] JS學習紀錄此次重點在於 座標點的取得以及計算 解構賦值的運用 HTML123&lt;div class="hero"&gt; &lt;h1 contenteditable&gt;🇹🇼 Taiwan!&lt;/h1&gt;&lt;/div&gt; 全部js程式碼1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const hero = document.querySelector('.hero');const text = hero.querySelector('h1');const walk = 100; //設定 text-shadow 座標最大的偏移範圍function shadow(e)&#123; // console.dir(hero); // 取得 hero 的 寬、高 // const width = hero.offsetWidth; // const height = hero.offsetHeight; /* 可簡寫如下 */ const &#123;offsetWidth: width, offsetHeight: height&#125; = hero; // 取得滑鼠的座標 // offsetX與offsetY回傳的座標，是以「目前DOM box model區塊範圍」為主， // 回傳滑鼠座標位於「目前的DOM區塊範圍」的哪裡， // 而不是以整個「window」為主，另外DOM與DOM重疊的話，依舊是分開計算。 // 註：起點為左上角： x:0 , y:0 ，向右增加 x ，向下增加 y let &#123;offsetX: x, offsetY: y&#125; = e; // console.log(x, y); // 若滑鼠從父元素移到子元素的話，offsetX與offsetY會 歸0 重新計算， // 所以需要將父元素與子元素之間座標的落差補足。 if (this !== e.target)&#123; // console.dir(e.target); x = x + e.target.offsetLeft; // 目前DOM之滑鼠的X座標 + 目前DOM位於父元素的X座標 y = y + e.target.offsetTop; // 目前DOM之滑鼠的Y座標 + 目前DOM位於父元素的Y座標 &#125; // console.log(x, y); // (座標在hero的比例 * 最大偏移量的值) - (一半的最大偏移量的值) // 取得 正值或負值 的座標，如： 最大偏移量的值=100，取得範圍落於 -50~50 之間 const xWalk = Math.round((x / width * walk) - (walk / 2)); const yWalk = Math.round((y / height * walk) - (walk / 2)); text.style.textShadow = ` $&#123;xWalk&#125;px $&#123;yWalk * -0.7&#125;px 0 rgba(255,0,0,0.3), $&#123;xWalk * -1&#125;px $&#123;yWalk&#125;px 0 rgba(0,255,0,0.3), $&#123;yWalk&#125;px $&#123;xWalk * -0.5&#125;px 0 rgba(0,255,255,0.3), $&#123;yWalk * -1&#125;px $&#123;xWalk&#125;px 0 rgba(0,0,255,0.3) `;&#125;// 監聽滑鼠事件hero.addEventListener('mousemove', shadow); 解構賦值(Destructuring assignment)從上面程式碼，將使用「解構賦值」的地方，額外拉出來 解構賦值12345// 取得 hero 的 寬、高const width = hero.offsetWidth;const height = hero.offsetHeight;// 可簡寫如下const &#123;offsetWidth: width, offsetHeight: height&#125; = hero; 解構賦值1234let x = e.offsetX;let y = e.offsetY;// 可簡寫如下let &#123;offsetX: x, offsetY: y&#125; = e;]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-15-LocalStorage]]></title>
    <url>%2F2018%2F04%2F18%2FJS30-15-LocalStorage%2F</url>
    <content type="text"><![CDATA[使用 LocalStorage 做 todolist。 目標 使用 LocalStorage 做 todolist。 實踐步驟 input輸入框 取得輸入項目，儲存List清單的項目 刷新html的List清單 儲存至localStorage → 只接受字串 UL的List清單 監聽是否有done 更新List清單的項目 成品 [DEMO] | [GitHub] JS學習紀錄此次學到的東西都在一些小技巧上面，故一步步將撰寫的步驟寫上，並註記哪裡在特別注意。 一、取得輸入項目，並新增至LocalStorage預設元件123const addItems = document.querySelector('.add-items'); //送出按鈕const itemsList = document.querySelector('.plates'); //UL清單const items = []; //儲存List清單的項目 監聽 送出按鈕1addItems.addEventListener('submit', addItem); 新增input項目12345678910111213141516171819202122232425262728function addItem(e)&#123; // 取消原本的預設動作 e.preventDefault(); /* 因為點擊的元素 = addItems，所以可以直接用 this 進行後續的動作 */ // const item = addItems.querySelector('[name="item"]'); const text = (this.querySelector('[name=item]')).value; /* 產生新物件，紀錄輸入的文字與是否勾選的狀態(done) */ const obj = &#123; // text: item.value, //es5寫法 text, //使用es6的解構賦值:text:text done: false &#125; // 新增List清單的項目 items.push(obj); // 刷新html的List清單 populateList(items, itemsList); // 額外將資料存在localStorage(只接受字串) localStorage.setItem('items', JSON.stringify(items)); // 清空input欄位 // item.value = ''; this.reset(); // reset也可清空表單&#125; 刷新html的List清單1234567891011/* 在組HTML時，新增一些資訊在dataset上，以供後續的操作動作，可取得相關資訊。 */function populateList(plates = [], platesList) &#123; platesList.innerHTML = plates.map((plate, index) =&gt; &#123; return ` &lt;li&gt; &lt;input type="checkbox" data-index=$&#123;index&#125; id="item$&#123;index&#125;" $&#123;plate.done ? 'checked' : ''&#125; /&gt; &lt;label for="item$&#123;index&#125;"&gt;$&#123;plate.text&#125;&lt;/label&gt; &lt;/li&gt; `; &#125;).join('');&#125; 二、List清單的預設值因為運用到localStorage儲存資料，所以重新進入此頁面時，可以利用localStorage取得最後一次的紀錄。 預設元件12345const addItems = document.querySelector('.add-items'); //送出按鈕const itemsList = document.querySelector('.plates'); //UL清單//const items = []; //儲存List清單的項目const items = JSON.parse(localStorage.getItem('items')) || []; 三、監聽並儲存checkbox狀態監聽List的項目1itemsList.addEventListener('click', toggleDone); 123456789101112131415161718function toggleDone(e) &#123; // 判斷是 input:checkbox 才執行 if (!e.target.matches('input')) return; // 取得checkbox的data-index值 const el = e.target; const index = el.dataset.index; /* 以往會用 if else 去判斷，可用 「!」來反轉上次的結果。 */ // 切換是否已done的flag items[index].done = !items[index].done; // 更新localStorage localStorage.setItem('items', JSON.stringify(items)); // 刷新html的List清單 populateList(items, itemsList);&#125;]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-14-JavaScript-References-VS-Copying]]></title>
    <url>%2F2018%2F04%2F18%2FJS30-14-JavaScript-References-VS-Copying%2F</url>
    <content type="text"><![CDATA[陣列與物件的傳址(reference)及複製(Copying)。 目標 了解陣列與物件的傳址(reference)及複製(Copying)。 成品 [GitHub] JS學習紀錄型別介紹基本型別：string、number、boolean、null、undefined除了以上幾種之外，其他都可以歸類至物件型別 (Object) 基本型別 =&gt; 傳值(value)物件型別 =&gt; 傳址(reference) 陣列複製列出可完成陣列複製的方式 Array.prototype.Slice() 12const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];const team2 = players.slice(); Array.prototype.concat() 12const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];const team3 = [].concat(players); ES6 展開運算子( Spread Operator ) 12const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];const team4 = [...players]; Array.from() 12const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];const team5 = Array.from(players); 物件複製列出可完成物件複製的方式，以及有雷的地方。 Object.assign() 淺拷貝123456const person = &#123; name: 'Wes Bos', age: 80&#125;;const cap2 = Object.assign(&#123;&#125;, person); JSON.parse() &amp; JSON.stringify() JSON轉換1234567891011121314const wes = &#123; name: 'Wes', age: 100, social: &#123; twitter: '@wesbos', facebook: 'wesbos.developer' &#125;&#125;;// Object.assign 只能淺複製一層，若第二層以上依舊是 傳址(reference)const dev = Object.assign(&#123;&#125;, wes);// 透過JSON轉字串後，利用傳值的特性複製給新變數後，然後轉回物件型態，達到可複製二層以上的物件。const dev2 = JSON.parse(JSON.stringify(wes)); 特例：像 function 沒辦法轉成 JSON 再轉回來，複製的function會直接消失 JSON轉換失敗案例123456789var obj1 = &#123; fun: function()&#123; console.log(123) &#125;&#125;;var obj2 = JSON.parse(JSON.stringify(obj1));console.log(typeof obj1.fun); // 'function'console.log(typeof obj2.fun); // 'undefined' &lt;-- 沒複製 舊文參考：JS-淺拷貝(Shallow Copy) VS 深拷貝(Deep Copy)JS-陣列(Array)-淺拷貝作法]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-13-Slide-in-on-Scroll]]></title>
    <url>%2F2018%2F04%2F09%2FJS30-13-Slide-in-on-Scroll%2F</url>
    <content type="text"><![CDATA[滾動捲軸，使圖片滑動顯示。 目標 當滾動捲軸到「特定定點」時，使圖片滑動顯示。 實踐步驟 CSS的動畫效果 transition transform、translateX、scale 監聽scroll滾動事件，並取得相關高度的資訊，進行判斷 window.scrollY window.innerHeight HTMLElement.height HTMLElement.offsetTop 成品 [DEMO] | [GitHub] JS學習紀錄減緩呼叫function的時間因為監聽scroll的事件，當畫面滾動時，會在短時間觸發好幾次Event，所以為了降低對效能上的影響，作者寫了一個debounce的函式，用來降低觸發的間隔時間。 123456789101112131415161718// 減緩呼叫function的時間function debounce(func, wait = 20, immediate = true) &#123; var timeout; return function() &#123; var context = this, args = arguments; var later = function() &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125;// 呼叫 funtionwindow.addEventListener('scroll', debounce(handleShowImage)); 各種高度的取得及運用程式的邏輯： 當 window.scrollY 移動到 圖片一半以上 的位置時，將圖片顯示 當 圖片底部 已超過 window.scrollY 的位置時，將圖片隱藏 高度的運用1234567891011121314151617181920function handleShowImage(e)&#123; slideImages.forEach( sliderImage =&gt; &#123; // 取得 圖片1/2的座標點（卷軸垂直位移量＋視窗高度）- 1/2圖片高度 const slideInAt = (window.scrollY + window.innerHeight) - sliderImage.height / 2; // 取得 圖片底部座標點（圖片頂部座標點 + 圖片高度） const imageBottom = sliderImage.offsetTop + sliderImage.height; // 判斷 視窗 是否已經超過 圖片高度一半 const ishalf = slideInAt &gt; sliderImage.offsetTop; // 判斷 滾動範圍 是否已經超過 圖片底部 const isNotOver = imageBottom &gt; window.scrollY; // 超過圖片高度一半 且 未超過圖片底部，則顯示 if ( ishalf &amp;&amp; isNotOver)&#123; sliderImage.classList.add('active'); &#125;else&#123; sliderImage.classList.remove('active'); &#125; &#125;)&#125; window.scrollY目前瀏覽器視窗已滾動的Y軸（垂直位置） window.innerHeight目前瀏覽器視窗的高度(不含 上方功能列及開發者工具 區塊) HTMLElement.offsetTop取得 DOM元素 相對於在父元素頂部距離的位置 HTMLImageElement.height圖片本身的高度(此屬性不是每個DOM元素都有) 可額外參考的方法： Element.getBoundingClientRect()取得 目標元素的 大小 與 相對於瀏覽器視窗的位置資訊]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-12-Key-Sequence-Detection]]></title>
    <url>%2F2018%2F03%2F31%2FJS30-12-Key-Sequence-Detection%2F</url>
    <content type="text"><![CDATA[輸入隱藏指令後，觸發特效的效果。 目標 網頁輸入「隱藏指令」後，觸發特效的效果 實踐步驟 監聽 window 的 keyup 事件 window.addEventListener(‘keydown’, function) 判斷輸入的隱藏指令，是否正確。 利用 e.key 取得鍵盤的值 籍由 splice()、join()、includes() 搭配使用進行判斷。 成品 [DEMO] | [GitHub] 隱藏指令：kanboo JS學習紀錄思考：如何刪除多餘的字元Q 主要思考的點是每次鍵盤輸入後，只留下隱藏指令的長度，而將多餘的字元刪除呢？ A 因為每次 push 都加進Array最後面的位置，所以就代表多餘的字元是在前面的位置， 所以我的思維是「從前面扣掉 多餘的字元(鍵盤輸入總長度-隱藏指令長度)」。 從前面計算12// 只保留與superKey一樣長度的字元，多餘的去除掉，避免太過冗長不好看。keyArr.splice(0, keyArr.length - superKey.length); 下例為影片作者的寫法，附上參考。 作者寫法：從後往前計算1keyArr.splice(-superKey.length - 1, keyArr.length - superKey.length); JS程式碼 程式碼不多，就直接貼上來，方便看。 整段程式碼123456789101112131415161718const superKey = 'kanboo'; // 隱藏指令const keyArr = []; // 暫存鍵盤輸入function isSuperKey(e)&#123; keyArr.push(e.key); // 只保留與superKey一樣長度的字元，多餘的去除掉，避免太過冗長不好看。 keyArr.splice(0, keyArr.length - superKey.length); // 作者寫法：從後往前計算 // keyArr.splice(-superKey.length - 1, keyArr.length - superKey.length); if ( keyArr.join('').includes(superKey))&#123; cornify_add(); &#125;&#125;window.addEventListener('keydown', isSuperKey); 補充：字串比對看到Guahsu大的文章，有整理關於字串比對的各種方式，覺得非常實用，筆記… 方便以後可快速搜尋。 各種判斷的方式12345678910111213141516171819202122232425var str = 'abcde';var check1 = 'ab'; //包含ab，期待值是truevar check2 = 'ac'; //包含ac，期待值是false//用includes()來取得true/falsestr.includes(check1); //truestr.includes(check2); //false//用match()來處理，判斷是否為 null 來取得true/falsestr.match(check1); // objectstr.match(check2); // null//用indexOf()來處理，判斷是否為 -1 來取得true/falsestr.indexOf(check1); // 0str.indexOf(check2); // -1//用search()，判斷是否為 -1 來取得true/falsestr.search(check1); // 0str.search(check2); // -1//用RegExp正規表示式來取得true/falsevar reg1 = /ab/;var reg2 = /ac/;reg1.test(str); // truereg2.test(str); // false Guahsu-探索]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-11-Custom-Video-Player]]></title>
    <url>%2F2018%2F03%2F28%2FJS30-11-Custom-Video-Player%2F</url>
    <content type="text"><![CDATA[利用Video屬性及Method來變更播放器的功能，播放/暫停、快進/快退、音量控制、倍數控制。 目標 實現播放器功能 播放/暫停 快進/快退 音量控制 倍數控制 實踐步驟 取得所有video DOM元素 撰寫Function 並 監聽DOM元素 監聽 video 播放或暫停 →延伸→ 切換播放的icon 進度條更新目前播放時間 進度條監聽是否有切換video播放時間 調整 聲音、播放倍數 進、快退(+25 or -10) 成品 [DEMO] | [GitHub] JS學習紀錄video 播放或暫停JS1234567891011121314151617function togglePlay(e)&#123; const method = video.paused ? 'play' : 'pause'; video[method](); // 觸發影片API，當有更新時，連動會觸發本身的Event&#125;// 切換iconfunction updateButton() &#123; const icon = this.paused ? '►' : '❚ ❚'; toggleBtn.textContent = icon;&#125;video.addEventListener('click',togglePlay); //點擊 影片的任何位置toggleBtn.addEventListener('click',togglePlay); //點擊 icon// 監聽影片本身的Event，達到切換播放的iconvideo.addEventListener('play', updateButton);video.addEventListener('pause', updateButton); 上例比較特別的地方是在 togglePlay() 裡的 video[method]() 這個寫法， 原本會寫成 video.play() 和 video.pause() 來呼叫影片method， 所以也可使用 video[method]() 呼叫method。 HTMLMediaElement.play()HTMLMediaElement.paused() 進度條更新目前播放時間因為影片會一直持續播放，所以我們也要持續更新進度條UI畫面。 JS123456789function handleProgress(e)&#123; // video.currentTime 目前播放時間 // video.duration 屬性返回當前音頻/視頻的長度，以秒計。 const percent = (video.currentTime / video.duration) * 100; // console.log(video.currentTime, video.duration, percent); progressBar.style.flexBasis = `$&#123;percent&#125;%`;&#125;video.addEventListener('progress', handleProgress); 作者有提到關於 video 有兩個監聽參數 timeupdate、progress，都可以做為影片時間變動時的觸發條件，二者差異如下： progress：會在載入時，就開始觸發 timeupdate：會在啟動播放後，才開始觸發 所以建議使用 progress 提早觸發。 progresstimeupdate 進度條監聽是否有切換video播放時間判斷User是否有在 進度條 做 變更video時間 的動作，當符合操作條件(滑鼠按住不放且拖移進度條)時，就變更目前影片的播放時間。 JS1234567891011121314151617181920212223const progress = document.querySelector('.progress'); // 進度條DOM元素function scrub(e) &#123; // e.offsetX 取得滑鼠點擊的位置 // progress.offsetWidth 進度條的總寬度 // video.duration 屬性返回當前音頻/視頻的長度，以秒計。 // console.log(e.offsetX, progress.offsetWidth, video.duration); // 根據 滑鼠點擊位置 位於進度條的多少比例，進而計算轉換成 影片的時間 const scrubTime = (e.offsetX / progress.offsetWidth) * video.duration; // 更改影片的播放時間 video.currentTime = scrubTime;&#125;//判斷 滑鼠是否有點擊let mousedown = false;//監聽 進度條DOM元素progress.addEventListener('click', scrub);// 監聽 滑鼠滑動 時，若 滑鼠為down 的狀態時，就呼叫 scrub 的method。progress.addEventListener('mousemove', (e) =&gt; mousedown &amp;&amp; scrub(e));// 監聽 滑鼠是否是 down 或 up 的狀態progress.addEventListener('mousedown', () =&gt; mousedown = true);progress.addEventListener('mouseup', () =&gt; mousedown = false); 補充說明 上列程式碼其中一段，關於監聽 mousemove 的寫法，原始寫法如下 簡化寫法12345678910progress.addEventListener('mousemove', (e) =&gt; &#123; if (mousedown) &#123; scrub(e); &#125;&#125;);/* 上面程式 可簡化成 下面程式碼 */// 監聽 滑鼠滑動 時，若 滑鼠為down 的狀態時，就呼叫 scrub 的method。progress.addEventListener('mousemove', (e) =&gt; mousedown &amp;&amp; scrub(e)); HTMLMediaElement.currentTime 變更 聲音、播放倍數利用 JS 取得DOM元素的name、value的值，進而更新video的屬性。 HTML1234&lt;!-- 聲音 --&gt;&lt;input type="range" name="volume" class="player__slider" min="0" max="1" step="0.05" value="1"&gt;&lt;!-- 播放倍數 --&gt;&lt;input type="range" name="playbackRate" class="player__slider" min="0.5" max="2" step="0.1" value="1"&gt; JS123456function handleRangeUpdate() &#123; video[this.name] = this.value;&#125;ranges.forEach(range =&gt; range.addEventListener('change', handleRangeUpdate));ranges.forEach(range =&gt; range.addEventListener('mousemove', handleRangeUpdate)); HTMLMediaElement.volumeHTMLMediaElement.playbackRate 快進、快退(+25 or -10)利用 JS 取得DOM元素dataset的值，進而更新video的屬性。 HTML1234&lt;!-- 快退 --&gt;&lt;button data-skip="-10" class="player__button"&gt;« 10s&lt;/button&gt;&lt;!-- 快進 --&gt;&lt;button data-skip="25" class="player__button"&gt;25s »&lt;/button&gt; JS123456function skip() &#123; // dataset值是字串，利用parseFloat需轉換成數字型態 video.currentTime += parseFloat(this.dataset.skip);&#125;skipButtons.forEach(button =&gt; button.addEventListener('click', skip));]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-10-Hold-Shift-and-Check-Checkboxes]]></title>
    <url>%2F2018%2F03%2F03%2FJS30-10-Hold-Shift-and-Check-Checkboxes%2F</url>
    <content type="text"><![CDATA[搭配 Shift + 滑鼠 勾選多個Checkbox 目標 利用 Shift + 滑鼠點擊 完成勾選範圍的項目 實踐步驟 取得所有的 checkbox元素，並且監聽 click 事件 利用變數紀錄 前次 與 這次 的點擊項目，計算出二者之間的範圍，完成勾選範圍的項目 lastChooise 記錄最後選擇項目 e.shiftKey 判斷有無按Shift鍵 成品 [DEMO] | [GitHub] JS學習紀錄思考：如何篩選出範圍想法1(我的想法)： 紀錄 最後一次的點擊項目 判斷 目前點擊項目 是在 最後一次點擊項目 的上面或下面 先爬上一次 再爬下一次 知道方向後，再由 目前點擊項目 loop至 最後一次點擊項目，完成勾選範圍的項目 想法2(作者作法)： 紀錄 最後一次的點擊項目 重新到尾loop 一次 將第一個遇到的「currentChooise 或 lastChooise」當起頭 最後結束的時機點，就利用剩下還沒遇到的 「currentChooise 或 lastChooise」當結尾， 由此劃分出 currentChooise 與 lastChooise 之間的範圍 由上述的 想法1 和 想法2 來比較的話，想法1 在過程中就多跑了好幾次loop來判斷一些事項，才能達到結果，所以在此次練習中，又學到了新的思維。 JS程式碼 因為程式碼不多，就直接貼上來，方便看。 整段程式碼12345678910111213141516171819202122232425262728293031const checkboxs = document.querySelectorAll('[type="checkbox"]');let lastChooise = null; // 紀錄最後選擇的Check元素function handleCheck(e)&#123; let isInChooiseScope = false; // 有按shift鍵 &amp; 有勾選Check &amp; 不是最後選擇的Ckeck元素 &amp; 不是第一次選擇Check if (e.shiftKey === true &amp;&amp; this.checked === true &amp;&amp; lastChooise !== this &amp;&amp; lastChooise !== null)&#123; checkboxs.forEach( checkbox =&gt; &#123; // 重點： // 利用loop從頭到尾迭代的特性，將第一個遇到的「currentChooise 或 lastChooise」當起頭 // 最後結束的時機點，就利用剩下還沒遇到的 「currentChooise 或 lastChooise」當結尾， // 由此劃分出 currentChooise 與 lastChooise 之間的範圍 if ( checkbox === this || checkbox === lastChooise)&#123; isInChooiseScope = !isInChooiseScope; &#125; if (isInChooiseScope)&#123; // checkbox.setAttribute('checked', true); // 上下二者結果皆相同 checkbox.checked = true; &#125; &#125;) &#125; lastChooise = this;&#125;checkboxs.forEach( checkbox =&gt; checkbox.addEventListener('click', handleCheck))]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-09-Dev-Tools-Domination]]></title>
    <url>%2F2018%2F03%2F01%2FJS30-09-Dev-Tools-Domination%2F</url>
    <content type="text"><![CDATA[學習Chrome Debug 的工具 目標 如何觀察 DOM 的變化與查看狀態 console 的各種用法 成品 [DEMO] | [GitHub] 六角學院-Chrome 網頁除錯功能大解密官方-Console API 參考 DOM BREAK ON介紹 DOM 的中斷點模式，分別有三種觸發模式可選（可複選） subtree modifications: 當子元素點發生變化時 arrtibute modifications: 當元素發生變化時 node removal: 當元素被移除時 CONSOLEconsole.log()除了一般我們最常用的 log 之外，還可另外新增 變數 ，增加訊息的變化 %s：可帶入 指定的參數 %c：可新增 css樣式 console.warn()log 多顯示為 警告icon console.error()log 多顯示為 錯誤icon console.info()失效，沒有顯示「帶白色“i”的藍色圓圈」 console.assert()可額外用來判斷，若條件為 false 時，才會顯示 錯誤訊息。 console.clear()清除全部log。 console.dir()可顯示出物件的細節資料，如：DOM元素、Function… console.groupCollapsed() &amp; console.groupEnd()可將一群相關訊息打成一包，這樣較易 檢查確認。 console.count()可顯示 累加出現的次數。 console.time() &amp; console.timeEnd()可用於計算一段程式碼執行時，所花費的時間。 console.table()可將陣列的資料，用 table 方式顯示，易於觀看。]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-08-Fun-with-HTML5-Canvas]]></title>
    <url>%2F2018%2F03%2F01%2FJS30-08-Fun-with-HTML5-Canvas%2F</url>
    <content type="text"><![CDATA[用滑鼠在 Canvas 上作畫 目標 使用HTML5的 Canvas 來製作一個畫布 透過 滑鼠 可達到作畫的效果 實踐步驟 建立 canvas 的區塊，設定為 2D 環境，並設定相關屬性 strokeStyle、lineJoin、lineCap、lineWidth 透過 JS 設定 canvas 會應用到的相關變數 canvas的顏色、線條粗細、座標…等 function draw(e) 監聽 滑鼠 的事件 開始作畫：mousedown 作畫中：mousemove 結束作畫：mouseup、mouseout 成品 [DEMO] | [GitHub] canvas學習紀錄設定線條樣式下列為這次 canvas 作畫用到的屬性 strokeStyle 線條顏色 lineJoin 線條轉彎的樣式 lineCap 線條收尾的樣式 lineWidth 線條寬度 HTML1&lt;canvas id="draw" width="800" height="800"&gt;&lt;/canvas&gt; JS-canvas設定1234567891011const canvas = document.querySelector('#draw');const ctx = canvas.getContext('2d'); // 宣告為 2D 渲染環境(e.g. 2D、webgl、webg2、bitmaprenderer)canvas.width = window.innerWidth;canvas.height = window.innerHeight;ctx.strokeStyle = 'blue'; // 線條顏色ctx.lineJoin = 'round'; // 線條轉彎的樣式(e.g. round(圓角)、bevel(去斜角)、、miter(尖形))ctx.lineCap = 'round'; // 線條收尾的樣式(e.g. butt(短方形)、round(圓形)、square(長方形))ctx.lineWidth = 25;ctx.globalCompositeOperation = 'source-in'; // 當有重疊的部份，如何呈現(e.g. source-over、screen、multiply、etc.) 作畫步驟利用JS完成作畫的步驟，如下 beginPath() 宣告開始作畫 moveTo() 作畫的起點 lineTo() 作畫的終點 stroke() 完成作畫 作畫部份程式碼1234ctx.beginPath();ctx.moveTo(lastX, lastY); // start fromctx.lineTo(e.offsetX, e.offsetY); // go toctx.stroke(); MDN-CanvasRenderingContext2DCanvasRenderingContext2D.globalCompositeOperation JS學習紀錄DOM監聽事件之this此次範例，作者在 DOM監聽事件 使用了 箭頭函式，雖然看似沒什麼情況，不過有一點要注意，若是有要對本身的DOM做修改的話，this 這個變數就會有所差異，如下例所示。 箭頭函式123canvas.addEventListener('mousedown', (e) =&gt; &#123; console.log(this); // window&#125;); 一般函式123canvas.addEventListener('mousedown', function(e) &#123; console.log(this); // DOM元素&#125;); JS-一次搞懂 JavaScript 的 this]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-07-Array-Cardio-Day-2]]></title>
    <url>%2F2018%2F02%2F26%2FJS30-07-Array-Cardio-Day-2%2F</url>
    <content type="text"><![CDATA[練習運用 Array 的各種函式 目標 共提供二組資料 people： [{ name: ‘Wes’, year: 1988 },…] comments ：[{ text: ‘Love this!’, id: 523423 },…] 根據不同需求條件篩選出正確的資料 練習題目people 的資料： 在people資料中，是否有19歲以上的人 在people資料中，是否每個人都19歲以上 comments 的資料： 在comments資料中，找到id是 823423 的資料 在comments資料中，找到id是 823423 的資料索引值, 並透過索引值刪除這筆資料 成品 [DEMO] | [GitHub] people 題目people資料123456const people = [ &#123; name: 'Wes', year: 1988 &#125;, &#123; name: 'Kait', year: 1986 &#125;, &#123; name: 'Irv', year: 1970 &#125;, &#123; name: 'Lux', year: 2015 &#125;]; Q：在people資料中，是否有19歲以上的人 A：透過 some() 逐筆判斷，只要其中一筆有符合，就回傳 true some()123456789101112131415// Some and Every Checks// Array.prototype.some() // is at least one person 19 or older?/* 解法 */const isAdult = people.some(function(people)&#123; const currYear = (new Date()).getFullYear(); if ( (currYear - people.year) &gt;= 19)&#123; return true &#125;&#125;)/* 簡化語法 */const isAdult = people.some( people =&gt; (new Date()).getFullYear() - people.year &gt;= 19)console.log(isAdult); Q：在在people資料中，是否每個人都19歲以上 A：透過 every() 逐筆判斷，只要其中一筆不符合，就回傳 false every()1234// Array.prototype.every() // is everyone 19 or older?const allAdults = people.every( people =&gt; (new Date()).getFullYear() - people.year &gt;= 19)console.log(allAdults); comments 題目comments資料1234567const comments = [ &#123; text: 'Love this!', id: 523423 &#125;, &#123; text: 'Super good', id: 823423 &#125;, &#123; text: 'You are the best', id: 2039842 &#125;, &#123; text: 'Ramen is my fav food ever', id: 123523 &#125;, &#123; text: 'Nice Nice Nice!', id: 542328 &#125;]; Q：在comments資料中，找到id是 823423 的資料 A：透過 find() 逐筆判斷，回傳 第一個符合條件的值，若都無符合，則回傳 undefined find()12345678910111213141516// Array.prototype.find()// Find is like filter, but instead returns just the one you are looking for// find the comment with the ID of 823423/* 解法 */const comment = comments.find(function(comment)&#123; if (comment.id === 823423)&#123; return true &#125;&#125;)/* 簡化語法 */const comment = comments.find( comment =&gt; comment.id === 823423)console.log(comment); Q：在comments資料中，找到id是 823423 的資料索引值, 並透過索引值刪除這筆資料 A： 透過 findIndex() 逐筆判斷，回傳 第一個符合條件的索引值，若都無符合，則回傳 -1 將取得的索引值，透過 slice() 和 Spread syntax(展開語法) 的搭配使用，產出一新陣列 findIndex()、slice()、Spread syntax123456789101112131415// Array.prototype.findIndex()// Find the comment with this ID// delete the comment with the ID of 823423const index = comments.findIndex( comment =&gt; comment.id === 823423)// console.log(index);// 去除不要的comment，產生一個新的陣列// slice 為 淺拷貝（shallow copy），不影響原陣列資料。const newComments = [ ...comments.slice(0, index), ...comments.slice(index+1)]console.log(newComments);]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-06-Type-Ahead]]></title>
    <url>%2F2018%2F02%2F26%2FJS30-06-Type-Ahead%2F</url>
    <content type="text"><![CDATA[練習 fetch()、filter()、RegExp()正規表達式 的運用 目標 當 searchInput 更新時，即時篩選出結果，並顯示於下方List。 顯示篩選結果時，需新增CSS效果，強調顯示 搜尋的字眼。 將數字顯示成有 千分位 的格式。 實踐步驟 透過 fetch() 取得 cities的資料 將 cities的資料 過濾出符合條件的資料 filter() RegExp() match() 優化UI 搜尋字串加顏色 數字新增千分位 成品 [DEMO] | [GitHub] JS學習紀錄fetch()先看下面簡單範例的程式碼，再進而解說 簡單範例1234567891011fetch('https://randomuser.me/api/', &#123;&#125;).then((response) =&gt; &#123; // 這裡會得到一個 ReadableStream 的物件 console.log(response); // 可以透過 blob(), json(), text() 轉成可用的資訊 return response.json();&#125;).then((jsonData) =&gt; &#123; console.log(jsonData);&#125;).catch((err) =&gt; &#123; console.log('錯誤:', err);&#125;); 說明 fetch 會使用 ES6 的 Promise 作回應 then 作為 下一步 catch 作為 錯誤回應 (404, 500…) 簡單來說，呼叫完 fetch 後， 若是成功的話，就會走 then，然後 then 可以一直接一直接。 若是失敗的話，就會走 catch ，catch 只有一次。 回傳格式(ReadableStream) Fetch API 的 Response 物件中的 body 屬性提供了一個 ReadableStream 物件， 此階段我們無法直接讀取回傳的資料內容，所以需要再轉一手，才能使用取得的資料。ReadableStream- arrayBuffer()- blob()- formData()- json() &lt;=常用- text() &lt;=常用 最常使用的格式 json() 和 text()，至於 blob() 的話，可用於接收圖片檔案。 MDN-fetch.body六角學院-ES6 原生 Fetch 遠端資料方法 RegExp()、match()在範例中，有要篩選出符合條件的 city 或 state，一開始在字串比對時，我使用了 String.prototype.includes()，不過此method是有區分大小寫(Case-sensitivity)，所以為了搜尋字眼不區分大小寫的話，就需改用 Regular Expressions 方式。 補充說明 str.match(regexp) 的回傳值 有符合：return 一個Array(包含符合條件的結果)，範例 無符合：return null 篩選範例12345678910111213function getMatchData(searchString, searchData)&#123; return searchData.filter( item =&gt; &#123; // 方法1：includes // 使用此方法有一缺點就是「大小寫需一致」才能符合條件。 // 舉例：資料為 "New York" 時，打 "York"，可搜尋的到，但是打 "york"，就會搜不到。 // return item.city.includes(searchString) || item.state.includes(searchString) // 方法2：正規表達式 // RegExp參數說明 → g：Global search 、 i：Case-insensitive search const regex = new RegExp(searchString, 'gi'); return item.city.match(regex) || item.state.match(regex) &#125;)&#125; 正規表示式 Regular ExpressionMDN-String.prototype.match() 組字串小技巧 array.join(‘’)範例中，作者在組HTML字串時，利用 .map() 組合出想要的HTML字串，不過 .map() 回傳是一個 Array，這時作者在 .map() 後，緊接著加了 .join(&#39;&#39;)，這樣的話，立馬就將原本是 「Array的資料 轉化成 一個字串」，取代了以往使用 「字串相加」 的用法。 123456789101112// 第二版：搜尋字串加顏色 、 數字新增千分位const html = matchData.map( item =&gt; &#123; const regex = new RegExp(this.value, 'gi'); const cityName = item.city.replace(regex, `&lt;span class="hl"&gt;$&#123;this.value&#125;&lt;/span&gt;`); const stateName = item.state.replace(regex, `&lt;span class="hl"&gt;$&#123;this.value&#125;&lt;/span&gt;`); return ` &lt;li&gt; &lt;span class="name"&gt;$&#123;cityName&#125;, $&#123;stateName&#125;&lt;/span&gt; &lt;span class="population"&gt;$&#123;numberWithCommas(item.population)&#125;&lt;/span&gt; &lt;/li&gt;`&#125;).join('') CSS學習紀錄List清單之摺疊效果在範例中，搜尋出來的結果，顯示時會有交叉摺疊效果，作者運用下列元素達成此效果。 :nth-child(even)、:nth-child(odd) transform: perspective(100px) rotateX(3deg) translateY(2px) scale(1.001); CSS-交叉摺疊效果12345678.suggestions li:nth-child(even) &#123; transform: perspective(100px) rotateX(3deg) translateY(2px) scale(1.001); background: linear-gradient(to bottom, #ffffff 0%,#EFEFEF 100%);&#125;.suggestions li:nth-child(odd) &#123; transform: perspective(100px) rotateX(-3deg) translateY(3px); background: linear-gradient(to top, #ffffff 0%,#EFEFEF 100%);&#125; MDN-:nth-childMDN-perspective(透視)]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-05-Flex-Panel-Gallery]]></title>
    <url>%2F2018%2F02%2F26%2FJS30-05-Flex-Panel-Gallery%2F</url>
    <content type="text"><![CDATA[JS-Event 與 CSS-Flex 的搭配使用 目標 使用 CSS的 flex、transform、transition.. 等屬性。 透過 JS 監聽事件(click、transitionend)，修改CSS類別(classList)，達到不同效果。 實踐步驟 將HTML的 panels 底下的 5個panel，利用 flex 將版型排好 flex：flex-grow flex-shrink flex-basis 分別監聽(click、transitionend) 三個 panel 利用 DOM.classList.toggle 新增、移除 CSS類別 成品 [DEMO] | [GitHub] CSS學習紀錄flex: flex-grow flex-shrink flex-basis在範例中，有運用到 Flex 的一個css屬性(flex)，其參數如下 語法： flex的簡寫參數1flex: flex-grow flex-shrink flex-basis 屬性： flex-grow：元件的伸展性 flex-shrink：元件的收縮性 flex-basis：元件的基準值 而在範例中，主要用到第一個參數 flex-grow，在此稍微說明其定義 當 子元素全部加總的長度(600px) &lt; 父元素的總長度(1000px) 時，此時就有「剩餘的空間(1000 - 600 = 400)」，可以讓flex-grow依照比例去分配剩下的空間。 承上述，若是 子元素全部的長度 &gt;= 父元素的長度 時，此時就「無剩餘的空間」可分配，這種情況下flex-grow 就無用了， 再承上述，若 子元素總長度 超過 父元素長度時，有可能會造成跑版，這時就可以用第二個參數 flex-shrink，來收縮子元素的長度。 CSS Flex 屬性一點也不難flex-grow 不易理解，难道不是吗?深入解析 CSS Flexbox JS學習紀錄event.propertyName在監聽 transitionend 事件時，主要是判斷增加 Flex: 5 的效果是否已結束，進而觸發另一事件，新增另一個CSS效果(文字滑入)，在JS30-01-JavaScript-Drum-Kit已有練習使用過，在此重新複習一次。 圖：event.propertyName 取得 CSS屬性名稱 transitionendMDN-Event reference includes在影片中，作者有提到 transition: flex 0.7s.. 這一段，在sarafi是 flex，而其他瀏覽器為 flex-grow，不過二個都有 flex這個字眼，所以利用 .includes(&#39;flex&#39;) 來判斷 flex的css效果 是否已結束。 CSS-flex名稱12345678.panel &#123; /* Safari transitionend event.propertyName === flex */ /* Chrome + FF transitionend event.propertyName === flex-grow */ transition: font-size 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11), flex 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11), background 0.2s;&#125; JS-includes1234567891011function toggleActie(e)&#123; // 因 Safari 和 Chrome + FF 顯示 propertyName 有差異 /* Safari transitionend event.propertyName === flex */ /* Chrome + FF transitionend event.propertyName === flex-grow */ // console.log(e); if ( e.propertyName.includes('flex'))&#123; // console.log(this); this.classList.toggle('open-active'); &#125;&#125; 延伸：點擊其他panel時，關閉已展開panel若目前畫面已有展開某一panel時，在點擊其他panel時，需要將前一個panel的CSS效果移除。 解法： 預達到此需求，我先想到 jQuery 的 .siblings() 可使用，但若想用純正的 Vanilla JS 達成，Javascript有 Node.nextSibling 和 Node.previousSibling 可運用，不過已經有別人造好輪子的話，那就…改用大神寫好的來使用，感謝 get-elements-siblings-with-vanilla-javascript。 移除鄰邊的CSS1234567891011121314function toggleOpen(e)&#123; // console.log(this); this.classList.toggle('open'); // 移除鄰邊的CSS // 參考網址：https://gomakethings.com/how-to-get-an-elements-siblings-with-vanilla-javascript/ // DOM.nodeType：元素中的空行或者空格會作為文本節點，返回"#text" var sibling = this.parentNode.firstChild; for (; sibling; sibling = sibling.nextSibling) &#123; if (sibling.nodeType !== 1 || sibling === this) continue; // console.log(sibling); sibling.classList.remove('open'); &#125;&#125; 其他參考解法 GuaHsu大大的思維：紀錄最後一個點擊的Panel，當下一次點擊的Panel不一樣時，則除移CSS效果。 12345678910111213//宣告一個上次點擊的Panel，預設先給他panelslet lastClickPanel = document.querySelector('.panels');function toggleOpen() &#123; //每次檢查進入的element與上次進入的element是不是相同 //若不相同，則把上次點擊的element移除opev效果 //再把lastClickPanel指向為這次的elment if (this !== lastClickPanel) &#123; lastClickPanel.classList.remove('open'); lastClickPanel = this; &#125; this.classList.toggle('open');&#125; GuaHsu]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-04-Array-Cardio-Day-1]]></title>
    <url>%2F2018%2F02%2F16%2FJS30-04-Array-Cardio-Day-1%2F</url>
    <content type="text"><![CDATA[練習運用 Array 的各種函式 目標 共提供四組資料 inventors：first(名)、last(姓) 、year(出生日期)、passed(死亡日期) wiki網站的html ：網址連結 people：逗點分隔的姓名(firstName, lastName) data：提供的一組包含重覆資料的陣列 根據不同需求條件篩選出正確的資料 練習題目inventors 的資料： 篩選出於 1500~1599 年間出生的 inventor (year in 1500-1599) 將 inventors 的 firstname 與 lastname 組合成一個陣列 將 inventors 依據「生日」由大至小排序 加總所有 inventor 的年齡 將 inventors 依據「年齡」由大至小排序 wiki網站的html：網址連結 列出wiki中巴黎所有包含’de’的路名 people 的資料： 依據lastName排序所有people的資料 data 的資料： 分別計算data內每個種類的數量 成品 [DEMO] | [GitHub] inventors 題目inventors資料1234567891011121314const inventors = [ &#123; first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 &#125;, &#123; first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 &#125;, &#123; first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 &#125;, &#123; first: 'Marie', last: 'Curie', year: 1867, passed: 1934 &#125;, &#123; first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 &#125;, &#123; first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 &#125;, &#123; first: 'Max', last: 'Planck', year: 1858, passed: 1947 &#125;, &#123; first: 'Katherine', last: 'Blodgett', year: 1898, passed: 1979 &#125;, &#123; first: 'Ada', last: 'Lovelace', year: 1815, passed: 1852 &#125;, &#123; first: 'Sarah E.', last: 'Goode', year: 1855, passed: 1905 &#125;, &#123; first: 'Lise', last: 'Meitner', year: 1878, passed: 1968 &#125;, &#123; first: 'Hanna', last: 'Hammarström', year: 1829, passed: 1909 &#125;]; Q：篩選出於 1500~1599 年間出生的 inventor (year in 1500-1599) A：透過 filter 篩選出符合條件的資料，最終回傳一個新陣列 filter1234567891011121314// Array.prototype.filter()// 1. Filter the list of inventors for those who were born in the 1500's/* 解法 */const bornArr = inventors.filter(function(inventor)&#123; if (inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600)&#123; return true; &#125;&#125;)/* 簡化語法 */const bornArr = inventors.filter( inventor =&gt; inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600)console.table(bornArr); Q：將 inventors 的 firstname 與 lastname 組合成一個陣列 A：透過 map 將原始資料加工後，最終回傳一個新陣列 map123456789101112131415// Array.prototype.map()// 2. Give us an array of the inventors' first and last names/* 解法 */const newInventors = inventors.map(function(inventor)&#123; return inventor.first + ' ' + inventor.last&#125;)/* 簡化語法 */const newInventors = inventors.map( inventor =&gt; inventor.first + ' ' + inventor.last);/* 簡化語法(Template String) */const newInventors = inventors.map( inventor =&gt; `$&#123;inventor.first&#125; $&#123;inventor.last&#125;`); //Template Stringconsole.log(newInventors); Q：將 inventors 依據「生日」由大至小排序 A： 依照「生日」大小重新排序(return值： -1 排前面 , 1 排後面) sort12345678910111213141516// Array.prototype.sort()// 3. Sort the inventors by birthdate, oldest to youngest/* 解法 */const sortInventors = inventors.sort(function(a, b)&#123; if ( a.year &gt; b.year)&#123; return 1 &#125;else&#123; return -1 &#125;&#125;)/* 簡化語法 */const sortInventors = inventors.sort( (a, b) =&gt; a.year &gt; b.year ? 1 : -1 )console.table(sortInventors) Q：加總所有 inventor 的年齡 A： 籍由 reduce 加總所有的年齡 reduce123456789101112// Array.prototype.reduce()// 4. How many years did all the inventors live?/* 解法 */const totalYears = inventors.reduce(function(total, inventor)&#123; return total + (inventor.passed - inventor.year)&#125;, 0)/* 簡化語法 */const totalYears = inventors.reduce( (total, inventor) =&gt; total + (inventor.passed - inventor.year) , 0)console.log(totalYears); Q：將 inventors 依據「年齡」由大至小排序 A：依照「年齡」大小重新排序(return值： -1 排前面 , 1 排後面) 12345678910111213141516171819202122232425// 5. Sort the inventors by years lived/* 解法 */const sortYearsLived = inventors.sort(function(a, b)&#123; const aYearCount = a.passed - a.year; const bYearCount = b.passed - b.year; if ( aYearCount &gt; bYearCount) &#123; return -1 &#125;else&#123; return 1 &#125;&#125;)/* 簡化語法 */const sortYearsLived = inventors.sort( (a, b) =&gt; &#123; const aYearCount = a.passed - a.year; const bYearCount = b.passed - b.year; // 三元運算子 return aYearCount &gt; bYearCount ? -1 : 1&#125;)console.table(sortYearsLived); wiki-html 題目Q：列出wiki中巴黎所有包含’de’的路名 A：練習 展開運算子(Spread Operator)、map()、filter()、includes() 搭配使用 method組合運用123456789101112131415// 6. create a list of Boulevards in Paris that contain 'de' anywhere in the name// https://en.wikipedia.org/wiki/Category:Boulevards_in_Paris/* 解法 */const category = document.querySelector('.mw-category');//將 nodeList 轉為 Array型態const Links = [...category.querySelectorAll('a')]; //展開運算子(Spread Operator)//可以執行完 map 後，緊接著執行 filterconst de = Links .map( link =&gt; link.textContent) .filter( tName =&gt; tName.includes('de'))console.log(de); people 題目Q：依據 lastName 排序所有people的資料 A：練習 解構賦值(Destructuring Assignment)、sort() 運用 12345678910111213141516171819202122232425262728// 7. sort Exercise// Sort the people alphabetically by last nameconst people = ['Beck, Glenn', 'Becker, Carl', 'Beckett, Samuel', 'Beddoes, Mick', 'Beecher, Henry', 'Beethoven, Ludwig', 'Begin, Menachem', 'Belloc, Hilaire', 'Bellow, Saul', 'Benchley, Robert', 'Benenson, Peter', 'Ben-Gurion, David', 'Benjamin, Walter', 'Benn, Tony', 'Bennington, Chester', 'Benson, Leana', 'Bent, Silas', 'Bentsen, Lloyd', 'Berger, Ric', 'Bergman, Ingmar', 'Berio, Luciano', 'Berle, Milton', 'Berlin, Irving', 'Berne, Eric', 'Bernhard, Sandra', 'Berra, Yogi', 'Berry, Halle', 'Berry, Wendell', 'Bethea, Erin', 'Bevan, Aneurin', 'Bevel, Ken', 'Biden, Joseph', 'Bierce, Ambrose', 'Biko, Steve', 'Billings, Josh', 'Biondo, Frank', 'Birrell, Augustine', 'Black, Elk', 'Blair, Robert', 'Blair, Tony', 'Blake, William'];/* 解法 */const sortPeople = people.sort(function(a, b)&#123; const [aLast, aFirst] = a.split(', '); //解構賦值(Destructuring Assignment) const [bLast, bFirst] = b.split(', '); //解構賦值(Destructuring Assignment) if(aLast &gt; bLast)&#123; return 1 &#125;else&#123; return -1 &#125;&#125;)/* 簡化語法 */const sortPeople = people.sort( (a, b) =&gt; &#123; const [aLast, aFirst] = a.split(', '); const [bLast, bFirst] = b.split(', '); // 三元運算子 return aLast &gt; bLast ? 1 : -1&#125;)console.log(sortPeople); data 題目Q：分別計算data內每個種類的數量 A：練習 reduce() 運用 12345678910111213141516// 8. Reduce Exercise// Sum up the instances of each of theseconst data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck' ];/* 解法 */const dataCount = data.reduce( (counts, item) =&gt; &#123; if(!counts[item])&#123; counts[item] = 0; &#125; counts[item] += 1; return counts;&#125;, &#123;&#125;)console.log(dataCount)]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-03-CSS-Variables]]></title>
    <url>%2F2018%2F02%2F15%2FJS30-03-CSS-Variables%2F</url>
    <content type="text"><![CDATA[利用 CSS變數 與 JS 即時更新圖片的 內距、邊框色、模糊 效果 目標 使用 CSS變數 功能 透過 JS 更改 CSS變數值，達到即時更新 內距、邊框色、模糊 的效果 實踐步驟 在 CSS 的 :root 宣告 CSS變數 宣告方法：使用兩個-符號，代表「變數」，如：--spacing 使用方法：使用var()代表「使用變數」，如：var(--spacing) 分別監聽(change、mousemove)三個 input 的值 利用 dataset 取得自定義的資料，如：this.dataset.sizing 透過 document.documentElement.style.setProperty(&#39;--base&#39;, &#39;#fff&#39;); 更改CSS的變數 成品 [DEMO] | [GitHub] CSS學習紀錄使用 CSS的變數 功能，不過在 IE 上，好像還不支援。 CSS變數說明1234567891011121314151617/* 在CSS 的 :root(全局)設定 變數 */:root &#123; --base: #ffc600; --spacing: 50px; --blur: 10px;&#125;/* 使用CSS變數方法：var(變數名稱) */img &#123; padding: var(--spacing); background: var(--base); filter: blur(var(--blur)); /* CSS濾鏡效果：模糊 */&#125;.hl &#123; color: var(--base);&#125; :root 偽元素(全局):root 這個偽元素是文檔的根元素，等同於 &lt;html&gt; 標籤，所以常用於聲明全局的CSS變量： 設定變數(全局)123：root &#123; --color：#fff ;&#125; 在CSS style要使用時，用 var(變數名稱)，如下： 在CSS使用變數123img &#123; background： var(--color);&#125; 若是要在 JS 使用的話，語法如下： 用JS更改CSS變數12// ：root = 文檔的根元素 = &lt;html&gt; = document.documentElementdocument.documentElement.style.setProperty('--color', '#000'); CSS Variables filter 濾鏡CSS3的濾鏡功能，其中 blur 是高斯模糊，參數越高越模糊 MDN-filter JS學習紀錄dataset利用 dataset 可取得自定義的資料，另外也可使用 getAttribute 取得資料。 HTML1&lt;input id="blur" type="range" name="blur" value="10" data-sizing="px"&gt; JS取得dataset123456//方法1document.querySelector('#blur').dataset.sizing // 輸出：pxdocument.querySelector('#blur').dataset[sizing] // 輸出：px//方法2document.querySelector('#blur').getAttribute('data-sizing'); // 輸出：px MDN-dataset style.setProperty下列三種方法，皆可達到修改CSS的效果，不過實務上用方法2，會比較容易帶 參數 及 可讀性 較佳。 修改CSS12345678910const DOM = document.querySelector('img');//方法1DOM.setAttribute("style", `padding: 10px`)//方法2DOM.style.setProperty('padding', '10px');//方法3DOM.style.padding = '10px'; MDN-setProperty]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-02-JS-and-CSS-Clock]]></title>
    <url>%2F2018%2F02%2F14%2FJS30-02-JS-and-CSS-Clock%2F</url>
    <content type="text"><![CDATA[利用 JS 與 CSS 搭配作出時鐘效果 目標 顯示目前時間 利用 JS 與 CSS 搭配作出時鐘效果 實踐步驟 先調整時鐘的 CSS樣式 修改前： 新增CSS修改語法： 1234transform: rotate(90deg); /* 將 時、分、秒針 從 45分 旋轉至 12點 方向 */transform-origin: 100% 50%; /* 將旋轉的原點移位 */transition: all 0.05s cubic-bezier(0, 2.95, 1, 1); /* 讓秒針有跳動的效果 */border-radius: 50%; /* 原先是 長方形 ，修改成 圓角 ，比較像 時針 */ 修改後： 取得目前時間，並每秒更新一次 利用 setInterval(setDate, 1000) 每秒更新 使用 new Date() 取得目前 時、分、秒 一個圓共 360deg，分別依照 時、分、秒 計算出各自的角度 秒針：(360 / 60) * seconds + 90 分針：(360 / 60) * seconds + 90 時針：(360 / 12) * seconds + 90 補充說明：最後有加 90 是因原先都指向45分的位置，為了指向12點方向，所以有先用CSS旋轉90度 rotate(90deg)。 最後用 JS 透過 element.style 修改 時、分、秒 的角度 element.style.tranform = &quot;roate( 角度 )&quot; 成品 [DEMO] | [GitHub] JS學習紀錄setInterval()如果需要一直持續循環作動，使用 setInterval，例如網頁上每一秒鐘就更新一次時間。 語法：setInterval(callback, time) 12//每秒刷新時間setInterval(setDate,1000); Date()取得時間的函數 12345const nowDate = new Date();nowDate.getSeconds(); //取得當前秒nowDate.getMinutes(); //取得當前分鐘nowDate.getHours(); //取得當前小時 element.style一開始想說要改 CSS 屬性，就很直覺的使用 第一種 方法，學習過程中，得知 第二種 方法也行。 修改CSS：第一種1secondHand.setAttribute("style", `transform: rotate($&#123;secondDegrees&#125;deg)`) 修改CSS：第二種1secondHand.style.transform = `rotate($&#123;secondDegrees&#125;deg)` 延伸：transform:rotate的彈跳問題當秒針旋轉一圈之後，要開始旋轉第二圈時，角度的計算變化會是 444°→90°→96°，重點就在 444° 變成 90° 時，本來rotate 都是順時針旋轉，但 444°→90° 那一瞬間會是 逆時針 轉回去，而造成秒針跳動有點怪異，所以解決方式如下 在角度計算 444°→90° 重新循環時，將 transition 屬性關掉，由於距離短，時間短，將逆時針迴旋的過程瞬間完成。 修正秒針跳動的效果1234567891011121314const nowDate = new Date();//秒針const seconds = nowDate.getSeconds();const secondDegrees = (360 / 60) * seconds + 90;// 修正秒針跳動的效果if(secondDegrees === 90)&#123; secondHand.style.transition = 'all 0s';&#125;else&#123; secondHand.style.transition = 'all 0.05s cubic-bezier(0, 2.95, 1, 1)';&#125;secondHand.style.transform = `rotate($&#123;secondDegrees&#125;deg)` 延伸問題參考：soyaine、GuaHsu]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-01-JavaScript-Drum-Kit]]></title>
    <url>%2F2018%2F02%2F13%2FJS30-01-JavaScript-Drum-Kit%2F</url>
    <content type="text"><![CDATA[按下鍵盤時，觸發聲音及特效 目標 按下鍵盤時，播放聲音、顯示CSS效果 播放完畢後，移除CSS效果 實踐步驟 先監聽 鍵盤 的 keydown Event 利用 e.keyCode 取得符合的 audio標籤 和 div標籤 audio 標籤 =&gt; 播放 聲音 div 標籤 =&gt; 顯示 CSS效果 監聽 CSS 的 transitionend Event (transitionend 事件會在 transition 结束后觸發) e.propertyName !== &quot;transform&quot; 僅針對 transform 繼續做事，不是則停止 若為 transform，則移除 CSS效果 成品 [DEMO] | [GitHub] JS學習紀錄HTML5標籤 HTMLMediaElement透過 js 取得 HTMLMediaElement 元素，來進行影音的播放。 HTML1&lt;audio data-key="65" src="sounds/clap.wav"&gt;&lt;/audio&gt; JS12345//取得 HTMLMediaElement 元素const audio = document.querySelector(`audio[data-key="$&#123;keyCode&#125;"]`);audio.currentTime = 0 ; //設定音效從 0 秒開始audio.play(); // 播放音效 MDN-HTMLMediaElementHTMLMediaElement.playHTMLMediaElement.currentTime DOM元素 Element.classList透過 classList 新增、移除、切換 CSS屬性，就像jQuery的 addClass、removeClass 一樣。 HTML1234&lt;div data-key="65" class="key"&gt; &lt;kbd&gt;A&lt;/kbd&gt; &lt;span class="sound"&gt;clap&lt;/span&gt;&lt;/div&gt; JS123456//取得 DOM 元素const key = document.querySelector(`.key[data-key="$&#123;keyCode&#125;"]`);key.classList.add('playing'); //新增CSS屬性key.classList.remove('playing'); //移除CSS屬性key.classList.toggle('playing'); //切換CSS屬性 Element.classList DOM元素 NodeList使用 querySelectorAll 取得的DOM，返回的結果是 NodeList 型態，非 Array 型態，所以不能使用 Array的method，若要使用Array的method的話，就需轉換成Array型態。 HTML123456789101112&lt;div data-key="65" class="key"&gt; &lt;kbd&gt;A&lt;/kbd&gt; &lt;span class="sound"&gt;clap&lt;/span&gt;&lt;/div&gt;&lt;div data-key="83" class="key"&gt; &lt;kbd&gt;S&lt;/kbd&gt; &lt;span class="sound"&gt;hihat&lt;/span&gt;&lt;/div&gt;&lt;div data-key="68" class="key"&gt; &lt;kbd&gt;D&lt;/kbd&gt; &lt;span class="sound"&gt;kick&lt;/span&gt;&lt;/div&gt; querySelectorAll 取得 DOM元素後，使用 NodeList.prototype.forEach() 的 method，有可能會在部份瀏覽器不支援。 JS12345// 取得 DOM 元素 =&gt; NodeList 型態const keys = document.querySelectorAll('.key');// NodeList.prototype.forEach() =&gt; IE不支援keys.forEach(key =&gt; key.addEventListener('transitionend',removeTransition)) 可藉由下列方法，將 NodeList 轉換 Array型態，支援度較高。 NodeList 轉換 Array型態123456789// 第一種方法：Array.from()const keys = Array.from(document.querySelectorAll('.key'));// 第二種方法：... 展開運算子( Spread Operator )const keys = [...document.querySelectorAll('.key'))];// 轉換成 Array型態 後，就可以使用 forEach()、map(), concat() …等methodkeys.forEach(key =&gt; key.addEventListener('transitionend',removeTransition)) NodeList.prototype.forEach()Array.from()… 展開運算子(Spread Operator) CSS監聽事件 transitionend透過 CSS transitionend Event ，當 transition 效果結束後，就會觸發此事件， JS1234567891011function removeTransition(e)&#123; console.log(e); //有時會多個 CSS效果 一同執行，參考下圖1 console.log(e.propertyName); //可透過 event.propertyName 取得想要監聽的CSS屬性，參考下圖2 if(e.propertyName !== "transform") return; // 僅針對 transform，不是則停止 /* your code */&#125;const keys = Array.from(document.querySelectorAll('.key'));keys.forEach(key =&gt; key.addEventListener('transitionend',removeTransition)) // transitionend 事件會在 CSS transition 结束后觸發 圖1：同時多個 CSS效果 圖2：event.propertyName 取得 CSS屬性名稱 transitionendMDN-Event reference 一般函式的this(作為 DOM 事件偵聽函式 → 該 DOM)在 removeTransition function裡面有使用 this 去移除CSS屬性，該如何判斷這個 this 是指向誰呢？ 答案是：一般函式的this(作為 DOM 事件偵聽函式 → 該 DOM) this?123456789function removeTransition(e)&#123; if(e.propertyName !== "transform") return; // 僅針對 transform，不是則停止 // 一般函式的this(作為 DOM 事件偵聽函式 → 該 DOM) this.classList.remove('playing'); //移除CSS屬性&#125;const keys = Array.from(document.querySelectorAll('.key'));keys.forEach(key =&gt; key.addEventListener('transitionend',removeTransition)) JS-一次搞懂 JavaScript 的 this 查詢鍵盤的代碼]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-陣列(Array)]]></title>
    <url>%2F2018%2F02%2F02%2FJS-Array%2F</url>
    <content type="text"><![CDATA[Array複習 與 ES6新語法 push、pop、shift、unshift 差異 push：加到陣列末端 pop：移除最末端 shift：移除最前端 unshift：加到陣列前端 1234567891011121314151617var home = ['爸爸', '媽媽'];// push：加到陣列末端var newLength = home.push('老大');console.log(home); // ["爸爸", "媽媽", "老大"]// pop：移除最末端var last = home.pop();console.log(home); // ["爸爸", "媽媽"]// shift：移除最前端var first = home.shift();console.log(home); // ["媽媽"]// unshift：加到陣列前端var newLength = home.unshift('小花');console.log(home); // ["小花", "媽媽"] 排序與反轉 sort與reversesortarr.sort([compareFunction]) 如果 compareFunction 沒有被應用, 元素將被轉換為字串並以Unicode碼位來比較並排序。特別一提，在數值排序中，9 會在 80 前面，但因為數字被轉換成字串，在Unicode順序中 “80” 會在 “9” 前面。 字串比較1234//大寫英文 Unicode 排在 小寫英文 前面var stringArray = ['blue', 'Humpback', 'Beluga', 'alice'];console.log(stringArray.sort()); //["Beluga", "Humpback", "alice", "blue"] 數字比較1234567891011// 數字被轉換成字串var numbers_01 = [1, 30, 4, 21];numbers_01.sort();console.log(numbers_01); // [1, 21, 30, 4]// 用 compareFunction比較，就不會被轉成「字串」var numbers_02 = [1, 30, 4, 21];numbers_02.sort(function(a, b) &#123; return a - b;&#125;);console.log(numbers_02); // [1, 4, 21, 30] reverse將整個陣列中的成員順序反轉。 1234const home = ["0.爸爸", "1.媽媽", "2.老大", "3.老二", "4.老么"];home.reverse();console.log(home); // ["4.老么", "3.老二", "2.老大", "1.媽媽", "0.爸爸"] 另一個情況是字串中的字元，如果要進行反轉的話，並沒有字串中的reverse方法，要用這個陣列的reverse方法加上字串與陣列的互相轉換的split與join方法，可以使用以下的函式: 字串反轉12345function reverseString(str) &#123; return str.split('').reverse().join('');&#125;console.log(reverseString("ABCDEFG")); // "GFEDCBA" slicearr.slice([begin[, end]]) 回傳一個新陣列，為原陣列選擇之 begin 至 end（不含 end）部分的淺拷貝（shallow copy）。 1234567891011121314const home = ["0.爸爸", "1.媽媽", "2.老大", "3.老二", "4.老么"];// begin為空或0，就是全部複製console.log(home.slice()); //["0.爸爸", "1.媽媽", "2.老大", "3.老二", "4.老么"]console.log(home.slice(0)); //["0.爸爸", "1.媽媽", "2.老大", "3.老二", "4.老么"]// 僅 begin 參數console.log(home.slice(2)); //["2.老大", "3.老二", "4.老么"]// 加 end 參數，擷取到 end 的 index「前」console.log(home.slice(2, 3)); //["2.老大"]// 加 end 參數，end index值 超過原陣列個數，沒有關係console.log(home.slice(2, 9999)); //["2.老大", "3.老二", "4.老么"] splicearray.splice(start[, deleteCount[, item1[, item2[, …]]]]) 可刪除既有元素並／或加入新元素來改變一個陣列的內容(會改變原陣列值)。 12345678910111213141516const home = ["0.爸爸", "1.媽媽", "2.老大", "3.老二", "4.老么"];// 會改變原陣例值home.splice(2, 0, '小花'); //在索引 2 開始，插入新增字串 '小花'console.log(home); // ["0.爸爸", "1.媽媽", "小花", "2.老大", "3.老二", "4.老么"]home.splice(2, 1); //在索引 2 開始，刪除 1個 元素console.log(home); // ["0.爸爸", "1.媽媽", "2.老大", "3.老二", "4.老么"]home.splice(2, 3, '巧虎', '琪琪', '桃樂比'); //在索引 2 開始，刪除 3個 元素後，再新增 3個 新元素console.log(home); // ["0.爸爸", "1.媽媽", "巧虎", "琪琪", "桃樂比"]// ES6 展開運算子( Spread Operator )const addArr = ['巧虎', '琪琪', '桃樂比'];home.splice(2, 3, ...addArr); //在索引 2 開始，刪除 3個 元素後，再新增 3個 新元素console.log(home); // ["0.爸爸", "1.媽媽", "巧虎", "琪琪", "桃樂比"] 淺拷貝作法1. ES6 展開運算子( Spread Operator ) 12const aArray = [1, 2, 3];const copyArray = [...aArray]; 它也可以用來組合陣列 12const aArray = [1, 2, 3];const bArray = [5, 6, ...aArray, 8, 9]; // [5, 6, 1, 2, 3, 8, 9] 2. slice 1234const oldArray = [1, 2, 3];const newArray = oldArray.slice(0); // [1, 2, 3]const newArray = oldArray.slice(); // [1, 2, 3] 3. concat 12const oldArray = [1, 2, 3];const newArray = [].concat(oldArray); // [1, 2, 3] ES6- find 與 findIndex find =&gt; 回傳 value findIndex =&gt; 回傳 index 基本寫法123456789101112131415const aArray = [1, 3, 5, 7, 10, 22];// findconst bValue = aArray.find(function (value, index, array)&#123; return value &gt; 6&#125;)console.log(bValue); //回傳第一個滿足條件的「value」：7// findIndexconst cIndex = aArray.findIndex(function (value, index, array)&#123; return value &gt; 6&#125;)console.log(cIndex); //回傳第一個滿足條件的「index」：3 進階應用不過當會用到 find 或 findIndex 時，表示要尋找的條件通常比較複雜一點，才能顯現他們比 indexOf 強大之處。 範例1 從陣列中找出符合條件的 物件 123456789101112131415var inventory = [ &#123;name: 'apples', quantity: 2&#125;, &#123;name: 'bananas', quantity: 0&#125;, &#123;name: 'cherries', quantity: 5&#125;];function isCherries(fruit) &#123; return fruit.name === 'cherries';&#125;// find 回傳第一個滿足條件的「value」console.log(inventory.find(isCherries)); // &#123; name: 'cherries', quantity: 5 &#125;// findIndex 回傳第一個滿足條件的「index」console.log(inventory.findIndex(isCherries)); // 2 範例2 找出質數 1234567891011121314151617function isPrime(element, index, array) &#123; var start = 2; while (start &lt;= Math.sqrt(element)) &#123; if (element % start++ &lt; 1) &#123; return false; &#125; &#125; return element &gt; 1;&#125;// find 回傳第一個滿足條件的「value」console.log([4, 6, 8, 12].find(isPrime)); // undefined, not foundconsole.log([4, 5, 8, 12].find(isPrime)); // 5// findIndex 回傳第一個滿足條件的「index」console.log([4, 6, 8, 12].findIndex(isPrime)); // -1, not foundconsole.log([4, 6, 7, 12].findIndex(isPrime)); // 2 ES6-includes在陣列中尋找是否包含這個值，如果有就會回傳 true，沒有則會回傳false。 12345678// 數字const numArr = [1, 2, 3];console.log(numArr.includes(2)); // true// 字串const strArr = ['老大', '老二', '老么'];console.log(strArr.includes('老二')); // trueconsole.log(strArr.includes('小花')); // false 參考來源MDN-ArrayES6 陣列語法糖ES6學習-陣列数组的扩展]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Array</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-for...in與for...of的差別]]></title>
    <url>%2F2018%2F01%2F30%2FJS-for-of-forin%2F</url>
    <content type="text"><![CDATA[for…of與for…in的差別 總結 建議：在迭代物件屬性時，使用 for...in；在迭代陣列時，使用 for...of。 for...in 輸出的是屬性名稱(key)，for...of 輸出的是值(value) for...of 是 ES6 的新語法。修復了ES5 for…in 的不足 for...of 不能迭代物件，需要透過和 Object.keys() 搭配使用 範例說明參考下列三個範例變化與說明，即可了解 for...of 與 for...in 之間的差別 範例1 單純迭代陣列的話，for...in 輸出的是屬性名稱(key)，for...of 輸出的是值(value) 1234567891011let iterable = [3, 5, 7];// 回傳「key」for (let i in iterable) &#123; console.log(i); // "0", "1", "2"&#125;// 回傳「value」for (let i of iterable) &#123; console.log(i); // 3, 5, 7&#125; 範例2 再來我們在原本的陣列，新增一個屬性 foo，可看到 for...in 有將此屬性 foo 也輸出。 新增陣列的屬性123456789101112let iterable = [3, 5, 7];iterable.foo = 'hello'; //新增foo屬性名稱// 回傳「key」，且會讀取到陣列新增的屬性名稱for (let i in iterable) &#123; console.log(i); // "0", "1", "2", "foo"&#125;// 回傳「value」for (let i of iterable) &#123; console.log(i); // 3, 5, 7&#125; 範例3 再來我們這次在物件和陣列的原型鍊上，分別各新增function，一樣可看到 for...in 也將原型鋉上的function名稱也輸出了。 在 原型鍊上 新增function12345678910111213141516// 在 原型鍊上 新增functionObject.prototype.objCustom = function()&#123;&#125;; //物件 原型鋉Array.prototype.arrCustom = function()&#123;&#125;; //陣列 原型鋉let iterable = [3, 5, 7];iterable.foo = 'hello';// 回傳「key」，且同時會讀取到 物件、陣列 原型鍊上的functionfor (let i in iterable) &#123; console.log(i); // "0", "1", "2", "foo", "arrCustom", "objCustom"&#125;// 回傳「值」for (let i of iterable) &#123; console.log(i); // 3, 5, 7&#125; 由上面三個案例來看，如果只是想單純的迭代取出陣列值的話，建議使用 for...of 會比較好，不過注意此語法為 ES6 新語法。 for..of 迭代 物件(object)如果想用 for...of 來遍歷物件的屬性的話，可以通過和 Object.keys() 搭配使用，先取得物件的所有key的數組，然後再遍歷。 123456789101112131415161718var student=&#123; name:'kanboo', age:16, locate:&#123; country:'tw', city:'taipei', school:'CCC' &#125;&#125;for(var key of Object.keys(student))&#123; //使用Object.keys()方法取得物件的Key的陣列 console.log(key+": "+student[key]);&#125;// "name: kanboo"// "age: 16"// "locate: [object Object]" 參考來源MDN-for…ofjavascript-for of和for in的區別？]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>for of</tag>
        <tag>for in</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-解構賦值(Destructuring Assignment)]]></title>
    <url>%2F2018%2F01%2F28%2FES6-DestructuringAssignment%2F</url>
    <content type="text"><![CDATA[解構賦值(Destructuring Assignment) 基本說明簡單來說，可以想像是鏡子的概念，將右方的資料往左邊送，然後會一個位置對一個值。 陣列 ==對應=&gt; 順序的索引值 物件 ==對應=&gt; 物件的屬性名稱 陣列解構賦值基本用法新舊寫法12345678910//ES5let numbers = [1, 2, 3];let a = numbers[0];let b = numbers[1];let c = numbers[2];console.log(a, b, c); // 1, 2, 3//ES6let [a, b, c] = [1, 2, 3];console.log(a, b, c); // 1, 2, 3 陣列各種情境當變數的數量多於賦予的值時，多出來的那個變數會被賦予 undefined 的值（d = undefined）： 變數 多於 所給的值123// 變數 多於 所給的值let [a, b, c, d] = [1, 2, 3];console.log(a, b, c, d); // 1, 2, 3, undefined 當輸入的變數少於所給的值的時候，只有被指定到的變數會有值，少掉的變數可以直接空過去： 當變數 少於 所給的值1234// 當變數 少於 所給的值let [a, , c] = [1, 2, 3];console.log(a, c); // 1, 3 至於陣例傳值是有順序性，在這個範例中直接將右邊的變數交換到左邊，可以看到是同時交換變數，所以在互換變數值時是非常方便的。 交換值1234// 交換值const a = 1, b = 2;[b, a] = [a, b]; //a=2, b=1 遇到字串則會將字串拆解成一個一個字元，賦予到左方的變數上。 字串12let str = 'kanboo';[a, b, c, d, e, f] = str; 另外也可以運用 ES6 的其餘參數 ，可以看到有個 ...other 的用法 ，這是可以將剩餘的陣列成員通通塞給 other 這個變數，如果沒有相對應的值則這個變數的值會是undefined, 其餘參數12345678let [one, ...other] = [1, 2, 3, 4];console.log(one); // 1console.log(other); // [2, 3, 4]let [a, b, ...z] = ['a'];console.log(a); // 'a'console.log(b); // undefinedconsole.log(z); // [] 物件解構賦值陣列是使用順序的索引值對應，但物件則是使用物件的屬性名稱來做對應(因此沒有順序性)。 在以下範例則是快速將物件值解構在變數上。 1234567// 基本用法const &#123; user, admin &#125; = &#123; user: '平民', admin: '皇帝' &#125;;console.log(user, admin); //"平民","皇帝"// 屬性名稱對換位置也不影響const &#123; admin, user &#125; = &#123; user: '平民', admin: '皇帝' &#125;;console.log(admin, user); //"皇帝", "平民" 如果變數與屬性名都沒有對應的名稱，則變數的值會是 undefined 123// 沒有對應的屬性const &#123; user &#125; = &#123; admin: '皇帝' &#125;;console.log(user); //undefined 而物件的解構方法，還能重新賦予變數的名稱，也可以屬性值來當作變數對應等號後方的屬性值，寫法會是類似這樣: 12const &#123; user: aa, admin: zz &#125; = &#123; user: '平民', admin: '皇帝' &#125;;console.log(aa, zz); //"平民","皇帝" 不可行的寫法和陣列解構賦值不同的是，在陣列解構賦值中，我們可以接受 「變數 少於 所給的值 」： 陣列12let [a, , c] = [1, 2, 3];console.log(a, c); // 1, 3 但是在物件解構賦值中，我們不能像上面這樣寫： 物件12let&#123;a, ,c&#125; = &#123;a:1, b:2, c:3&#125;;console.log(a,c); // Error 只能接受 「變數 多於 所給的值 」 物件12let &#123; a, b, c, d &#125; = &#123; a: 1, c: 3 &#125;;console.log(a, b, c, d); // 1, undefined, 3, undefined 物件解構賦值的用途物件解構賦值的用途相當多，其中在提取 JSON 數據時相當方便： JSON1234567891011let ajax_JSON = &#123; id: 9527, name: 'Kanboo', other: &#123; tel: '1234567', fax: '7654321' &#125;&#125;;let &#123; id, name, other &#125; = ajax_JSON;console.log(id, name, other); // 9527 "Kanboo" &#123;tel: "1234567", fax: "7654321"&#125; 延伸上例，若我只想取得 other 裡的「電話 tel」，取得方式，如下例 JSON12345678910111213141516let ajax_JSON = &#123; id: 9527, name: 'Kanboo', other: &#123; tel: '1234567', fax: '7654321' &#125;&#125;;let &#123; id, name, other: &#123; tel &#125;&#125; = ajax_JSON;console.log(id, name, tel); // 9527 "Kanboo" "1234567" 如此就能夠快速取得 JSON 物件的屬性名和屬性值。 混合使用複雜的物件或混合陣列到物件，如果你能記住之前說的鏡子樣式對映基本原則，其實也很容易就能理解 範例112345let &#123; home: Master, family: [, member]&#125; = &#123; home: '媽媽', family: ['老大', '老二', '老么'] &#125;;console.log(Master, member); // 媽媽 老二 範例21234567891011// 複雜多層次的物件const &#123; prop: x, prop2: &#123; prop3: &#123; nested: [, , b] &#125; &#125;&#125; = &#123; prop: 'Hello', prop2: &#123; prop3: &#123; nested: ['a', 'b', 'c'] &#125; &#125; &#125;;console.log(x, b); // =&gt; Hello c 預設值除了使用鏡射的概念外，為了避免值沒有賦予造成 undefined，可以使用預設值避免此問題。 如以下左方的陣列都先賦予的預設值，當右方的陣列只有一個值時，左方的陣列剩餘內容將會採用預設值。 12345678const [isPass = true] = [];console.log(isPass); // trueconst &#123; message: msg = 'Hello' &#125; = &#123;&#125;;console.log(msg); // "Hello"const &#123; a = 6 &#125; = &#123;&#125;;console.log(a); // 6 要作一個簡單的陷阱題滿簡單的，你可以試看看下面這個範例中到底是賦到了什麼值： 1234const &#123; a = 'kanboo' &#125; = 'hello';const [b = 'kanboo'] = 'hello';console.log(a, b); 函式除了以上的方法外，解構也能使用在函式的參數，使用方式如同將傳入的物件對應到函式參數上。這樣參數一樣能夠能夠自訂變數名稱、順序、預設值等。 123456789function func(&#123; a = 3, b &#125;) &#123; console.log(a + b);&#125;func(&#123; a: 1, b: 2 &#125;); // 3func(&#123; b: 2 &#125;); // 5func(&#123; a: 1 &#125;); // NaNfunc(&#123;&#125;); // NaNfunc(); // Cannot read property 'a' of undefined 當 a 與 b 兩個都有預設值時，NaN 的情況不存在： 123456789function func(&#123; a = 3, b = 5 &#125;) &#123; console.log(a + b);&#125;func(&#123; a: 1, b: 2 &#125;); // 3func(&#123; a: 1 &#125;); // 6func(&#123; b: 2 &#125;); // 5func(&#123;&#125;); // 8func(); // Cannot read property 'a' of undefined 實際上函式傳入參數它自己也可以加預設值，但這情況會讓最後一種 func() 呼叫時與 func({}) 相同結果： 123456789function func(&#123; a = 3, b = 5 &#125; = &#123;&#125;) &#123; console.log(a + b);&#125;func(&#123; a: 1, b: 2 &#125;); // 3func(&#123; a: 1 &#125;); // 6func(&#123; b: 2 &#125;); // 5func(&#123;&#125;); // 8func(); // 8 另一種情況是在函式傳入參數的預設值中給了另一套預設值，這只會在 func()時發揮它的作用： 123456789function func(&#123; a = 3, b = 5 &#125; = &#123; a: 7, b: 11 &#125;) &#123; console.log(a + b);&#125;func(&#123; a: 1, b: 2 &#125;); // 3func(&#123; a: 1 &#125;); // 6func(&#123; b: 2 &#125;); // 5func(&#123;&#125;); // 8func(); // 18 參考來源邁向 JavaScript 勇者之路從ES6開始的JavaScript學習生活陣列解構賦值物件解構賦值]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>解構賦值</tag>
        <tag>Destructuring Assignment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-淺拷貝(Shallow Copy) VS 深拷貝(Deep Copy)]]></title>
    <url>%2F2018%2F01%2F27%2FJS-ShallowCopy-DeepCopy%2F</url>
    <content type="text"><![CDATA[淺拷貝(Shallow Copy) VS 深拷貝(Deep Copy) 基本與物件型別傳值的差異 JavaScript 內建的型別主要可以分成基本型別 (Primitives) 與物件型別 (Object) 兩大類。 而基本型別又分成 string、number、boolean、null、undefined 幾種，除了以上幾種之外，其他都可以歸類至物件型別 (Object) 這二種型別之間的差異，就是在他們的傳值方式 基本型別 =&gt; 傳值(value) 物件型別 =&gt; 傳址(reference) 下面範例來解說他們的差異 基本型別 基本型別是傳 value 基本型別，傳value1234567let a = "爸爸";let b = a;b = "媽媽";console.log(a); //爸爸console.log(b); //媽媽 在修改 b 時並不會改到 a 的值 物件型別 但物件就不同，物件傳的是 reference 物件型別，傳reference1234567let objA = &#123; name: '王大頭' &#125;let objB = objAobjB.name = '盧卡斯'console.log(objA); //"盧卡斯"console.log(objB); //"盧卡斯" 淺拷貝(Shallow Copy) VS 深拷貝(Deep Copy) 淺拷貝：只能達到淺層的複製(第一層)，若有第二層以上的資料的話，就無法達到實際的複製，而是會與舊物件一起共用同一塊記憶體。 深拷貝：會另外創造一個一模一樣的物件，新物件跟原物件不共用記憶體，修改新物件不會改到原物件。 Object.assignObject.assign 是 ES6 的新函式，我們可以用來達成複製的功能 複製物件123456789let obj = &#123;name: '王康寶', age:&#123;child: 18&#125;&#125;let copy = Object.assign(&#123;&#125;, obj);//更改 copy.name 的值copy.name = '盧卡斯';//輸出console.log(obj); //&#123;name: "王康寶", age:&#123;child: 18&#125;&#125;console.log(copy); //&#123;name: "盧卡斯", age:&#123;child: 18&#125;&#125; But Object.assign 並不是那麼的完美，請再看下例 淺拷貝123456789let obj = &#123;name: '王康寶', age:&#123;child: 18&#125;&#125;let copy = Object.assign(&#123;&#125;, obj);copy.name = '盧卡斯';copy.age.child = 99; //更改 copy.age.child 的值//輸出console.log(obj); //&#123;name: "王康寶", age:&#123;child: 99&#125;&#125;console.log(copy); //&#123;name: "盧卡斯", age:&#123;child: 99&#125;&#125; 我們可以看到更改 copy.age.child 值以後，發現 obj.age.child 值也跟著被變掉了，所以 Object.assign 能處理深度，只有一層的物件，沒辦法做到真正的 深拷貝(Deep Copy)，不過如果要複製的物件只有一層的話可以考慮使用他。 另外也可以使用 展開運算子(Spread Operator) 達成複製，不過一樣是 淺層的複製。 展開運算子( Spread Operator )123456789let obj = &#123;name: '王康寶', age:&#123;child: 18&#125;&#125;let copy = &#123;...obj&#125;; //展開運算子(Spread Operator)copy.name = '盧卡斯';copy.age.child = 99; //更改 copy.age.child 的值//輸出console.log(obj); //&#123;name: "王康寶", age:&#123;child: 99&#125;&#125;console.log(copy); //&#123;name: "盧卡斯", age:&#123;child: 99&#125;&#125; 深拷貝的作法jQueryjquery 有提供一個 $.extend 可以用來做 Deep Copy jquery.extend123456789let obj = &#123;name: '王康寶', age:&#123;child: 18&#125;&#125;let copy = $.extend(true, &#123;&#125;, obj); //使用 jquery.extendcopy.name = '盧卡斯';copy.age.child = 99; //更改 copy.age.child 的值//輸出console.log(obj); //&#123;name: "王康寶", age:&#123;child: 18&#125;&#125;console.log(copy); //&#123;name: "盧卡斯", age:&#123;child: 99&#125;&#125; lodashlodash 也有提供 _.cloneDeep 用來做 Deep Copy lodash.cloneDeep123456789let obj = &#123;name: '王康寶', age:&#123;child: 18&#125;&#125;let copy = _.cloneDeep(obj); //使用 lodash.cloneDeepcopy.name = '盧卡斯';copy.age.child = 99; //更改 copy.age.child 的值//輸出console.log(obj); //&#123;name: "王康寶", age:&#123;child: 18&#125;&#125;console.log(copy); //&#123;name: "盧卡斯", age:&#123;child: 99&#125;&#125; 參考來源關於 JS 中的淺拷貝和深拷貝js中的深拷贝和浅拷贝 FB討論串2018/04/26 社團剛好有人詢問此問題，也有大大回覆一些見解，留個紀錄可以回頭查。 簡單重點整理： 可用 JSON.parse(JSON.stringify({})) 偽深拷貝 純資料，可行。 若遇 Function、Set、Map..等型態，失效。 為何要複製function? 目的？ 站在節省記憶體的角度，function能重複利用就重複利用 若是要寫物件導向風格 ES5：寫 Function + prototype ES6：寫 Class JSON複製範例 JSON複製範例12let a = &#123;o:&#123;v:1&#125;&#125;let b = JSON.parse(JSON.stringify(a)); 淺拷貝與深拷貝??]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Shallow Copy</tag>
        <tag>Deep Copy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-展開運算子(Spread Operator)、其餘參數(Rest Operator)]]></title>
    <url>%2F2018%2F01%2F26%2FES6-SpreadOperator-RestOperator%2F</url>
    <content type="text"><![CDATA[展開運算子(Spread Operator)、其餘參數(Rest Operator) 展開運算子( Spread Operator )展開運算子是”把一個陣列展開(expand)成個別數值“的速寫語法，簡單來說，就是把陣列裡面的值，拆解成一個一個。 基本用法1234567//陣列let number = [1,2,3,4,5];console.log(...number); // 1,2,3,4,5//字串let str = 'kanboo'console.log(...str); // "k","a","n","b","o","o" 將二個Array合併(新舊寫法比較)12345678910111213141516//===========過去寫法===========let groupA = ['爸爸', '媽媽'];let groupB = ['老大','老二','老么'];const groupAll = groupA.concat(groupB);console.log(groupAll);// ["爸爸", "媽媽", "老大", "老二", "老么"];//===========新的寫法===========let groupA = ['爸爸', '媽媽'];let groupB = ['老大','老二','老么'];const groupAll = [...groupA, ...groupB]; //拆解完後，再用陣列[]包起來，產生新的陣列console.log(groupAll);// ["爸爸", "媽媽", "老大", "老二", "老么"]; 你也可以用來把陣列展開，傳入函式之中，例如下面加總函式的範例： 將 陣列展開 傳入函式123456function sum(a, b, c) &#123; return a + b + c;&#125;var args = [1, 2, 3];console.log(sum(...args)); // 6 淺層複製另外陣列與物件相同都有著傳參考的特性，所以當把陣列賦予到另一個值上時，修改其中一個另一個也會跟著變動。 傳址：更動groupB 會 影響groupA123456789// 由於傳參考的關係，所以將一個陣列傳到另一個上時// 兩個的值其實是一樣的let groupA = ['老大','老二','老么'];let groupB = groupA;groupB.push('小花');//輸出console.log(groupA); // ['老大','老二','老么','小花'];console.log(groupB); // ['老大','老二','老么','小花']; 由於 展開運算子 它是一個一個將值寫入，所以他也有淺層的複製(shallow copy) 。 淺層複製：更動groupB 不會 影響groupA12345678// 這個屬於淺拷貝，所以不會影響到另一個物件let groupA = ['老大','老二','老么'];let groupB = [...groupA];groupB.push('小花');//輸出console.log(groupA); // ['老大','老二','老么'];console.log(groupB); // ['老大','老二','老么','小花']; 注意 因為是淺層的複製，所以當陣列的值是放 物件 的話，依舊會因為傳參考的特性，而修改其中一個另一個也會跟著變動。 1234567891011121314151617let groupA = [&#123;name:'老大'&#125;,&#123;name:'老二'&#125;,&#123;name:'老三'&#125;];let groupB = [...groupA];groupB.push(&#123;name:'小花'&#125;);//輸出console.log(groupA); // [&#123;name:'老大'&#125;,&#123;name:'老二'&#125;,&#123;name:'老三'&#125;]console.log(groupB); // [&#123;name:'老大'&#125;,&#123;name:'老二'&#125;,&#123;name:'老三'&#125;,&#123;name:'小花'&#125;]debugger;//更改 groupB 第一個NamegroupB[0].name = "爸爸";//注意 groupA 的第一個Name，也會跟著被變動console.log(groupA); // [&#123;name:'爸爸'&#125;,&#123;name:'老二'&#125;,&#123;name:'老三'&#125;]console.log(groupB); // [&#123;name:'爸爸'&#125;,&#123;name:'老二'&#125;,&#123;name:'老三'&#125;,&#123;name:'小花'&#125;] 類陣列轉成純陣列JavaScript 中有許多類陣列，這類陣列有著陣列的外皮，但卻不能使用陣列的方法，這類陣列由於原型不同，所以 不能 使用許多的陣列方法，如： map(), concat() 等等。 其中一種很常見的就是 DOM 陣列，此時我們就可以用 展開運算子 轉為 純陣列，這樣就可以使用陣列的各種方法。 12345// 可以將類陣列轉成陣列let doms = document.querySelectorAll('p');console.log(doms);let spreadDom = [...doms];console.log(spreadDom); 範例 arguments 以前要使用函式的 arguments 時，寫法僅可用 for 或 for..in 依序取得參數值。 arguments傳統寫法123456789function sum() &#123; var total = 0; for( var i=0; i&lt;arguments.length; i++ ) &#123; total += arguments[i]; &#125; return total;&#125;console.log( sum(1, 2, 3, 4, 5) ); // 15 但是若將 arguments 改寫用 陣列的方法(forEach、map、reduce) 的話，程式碼就會出錯。 使用陣列方法，會Error123456789function sum() &#123; var total = 0; arguments.forEach(function(element) &#123; total += element; &#125;); return total;&#125;console.log(sum(1, 2, 3, 4, 5)); //error TypeError: arguments.forEach is not a function 現在可透過 展開運算子 轉為 純陣列，就可使用 陣列的方法(forEach、map、reduce)。 透過「展開運算子」轉換12345678910function sum() &#123; let arg = [...arguments]; //透過 展開運算子 來轉成純陣列 let total = 0; arg.forEach(function(element) &#123; total += element; &#125;); return total;&#125;console.log(sum(1, 2, 3, 4, 5)); //15 其餘參數(Rest Operator)有時候，Function 接受的參數數量不固定，而 其餘參數(Rest Operator) 的功能就是把多的參數併成一個 Array。 範例1 可傳入不固定的參數，1個 or 多個 皆可.. 123456789101112function sum(...numbers) &#123; var result = 0; numbers.forEach(function (number) &#123; result += number; &#125;); return result;&#125;//傳入一個值console.log(sum(1)); // 1//傳入多個值console.log(sum(1, 2, 3, 4, 5)); // 15 範例2 如果function有先定義別的參數，就會將傳入的參數值先給定義好的參數，剩下的就全部塞入其餘參數。 12345678function restArray(x, y, ...others) &#123; console.log("x",x); // x： 1 console.log("y",y); // y： 2 console.log("others",others); // others： [3, 4, 5]&#125;//拆解陣列restArray(1, 2, 3, 4, 5); 其餘參數(Rest parameters)有一個限制，就是這個參數一定是函式的「最後一個」。 你如果放在其餘的參數前，就會產生錯誤。 反過來寫就會Error12345678function restArray(...others, x, y) &#123; console.log("x",x); console.log("y",y); console.log("others",others);&#125;//拆解陣列restArray(1, 2, 3, 4, 5); //error SyntaxError: Rest parameter must be last formal parameter 其餘的參數 與 arguments 不同的是：- arguments 不是真的陣列，其餘參數則「是」。- arguments 不能混用自訂傳入的參數。 參考來源邁向 JavaScript 勇者之路Eddy-展開運算值、其餘參數]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>Spread Operator</tag>
        <tag>Rest Operator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-樣板字串 (Template String)]]></title>
    <url>%2F2018%2F01%2F25%2FES6-TemplateString%2F</url>
    <content type="text"><![CDATA[Template String 樣板字串 基本用法新舊寫法比較123456789101112131415161718192021222324252627const people = ['老大','老二','老么'];//======================過去寫法======================let oldUl = '&lt;ul&gt;' + '&lt;li&gt;我叫做 ' + people[0] + '&lt;/li&gt;' + '&lt;li&gt;我叫做 ' + people[1] + '&lt;/li&gt;' + '&lt;li&gt;我叫做 ' + people[2] + '&lt;/li&gt;' + '&lt;/ul&gt;'; console.log(oldUl);//"&lt;ul&gt;&lt;li&gt;我叫做 老大&lt;/li&gt;&lt;li&gt;我叫做 老二&lt;/li&gt;&lt;li&gt;我叫做 老么&lt;/li&gt;&lt;/ul&gt;"//======================新的寫法======================let newUl = ` &lt;ul&gt; &lt;li&gt;我叫做 $&#123;people[0]&#125;&lt;/li&gt; &lt;li&gt;我叫做 $&#123;people[1]&#125;&lt;/li&gt; &lt;li&gt;我叫做 $&#123;people[2]&#125;&lt;/li&gt; &lt;/ul&gt;`console.log(newUl);// &lt;ul&gt;// &lt;li&gt;我叫做 老大&lt;/li&gt;// &lt;li&gt;我叫做 老二&lt;/li&gt;// &lt;li&gt;我叫做 老么&lt;/li&gt;// &lt;/ul&gt; 甚至可以在 ${} 內使用函式 (${}裡再包${})。 使用.map組字串(結果與上例一樣)12345let newUl = ` &lt;ul&gt; $&#123;people.map(person =&gt; `&lt;li&gt;我叫做 $&#123;person&#125;&lt;/li&gt;`).join('')&#125; &lt;/ul&gt;` 也可以在函式內增添更多的判斷式。 新增if判斷式1234567891011121314151617181920212223242526272829303132const people = [ &#123; name: '老大', friends: 2 &#125;, &#123; name: '老二', friends: 16 &#125;, &#123; name: '老么', friends: 0 &#125;]let newUl = ` &lt;ul&gt; $&#123;people.map((person) =&gt; &#123; if (person.friends) &#123; return `&lt;li&gt;$&#123;person.name&#125; 有 $&#123;person.friends&#125; 朋友&lt;/li&gt;` &#125; else &#123; return `&lt;li&gt;$&#123;person.name&#125; 沒朋友&lt;/li&gt;` &#125; &#125;).join('') &#125; &lt;/ul&gt;`console.log(newUl);// &lt;ul&gt;// &lt;li&gt;老大 有 2 朋友&lt;/li&gt;&lt;li&gt;老二 有 999 朋友&lt;/li&gt;&lt;li&gt;老么 邊緣人&lt;/li&gt;// &lt;/ul&gt; 巢狀 String Template如同上述的方法 ${} 內可以加入函式及其更內層的 Template String，所以也可以在 ${} 插入另一組的函式的 Template String。 在$&#123;&#125;裡呼叫function123456789101112131415161718192021222324252627282930313233343536373839404142434445const travelers = &#123; leader: "爸爸", partner: [ &#123; name: "老大", friends: 2 &#125;, &#123; name: "老二", friends: 16 &#125;, &#123; name: "老么", friends: 0 &#125; ]&#125;;function renderList(people) &#123; return ` &lt;div&gt;上車名單&lt;/div&gt; &lt;ul&gt; $&#123;people.map(person =&gt; `&lt;li&gt;$&#123;person.name&#125;&lt;/li&gt;`).join('')&#125; &lt;/ul&gt; `&#125;let template = ` &lt;div class="template"&gt; &lt;h2&gt;開車：$&#123;travelers.leader&#125;&lt;/h2&gt; $&#123;renderList(travelers.partner)&#125; &lt;/div&gt;`console.log(template);// &lt;div class=\"template\"&gt;// &lt;h2&gt;開車：爸爸&lt;/h2&gt;// // &lt;div&gt;上車名單&lt;/div&gt;// &lt;ul&gt;// &lt;li&gt;老大&lt;/li&gt;&lt;li&gt;老二&lt;/li&gt;&lt;li&gt;老么&lt;/li&gt;// &lt;/ul&gt;// // &lt;/div&gt; 跳脫字元如果有需要插入特殊字元，一樣可以使用 \ 反斜線來插入： 1console.log(`\\`); // "\" 如果要計算字元數，或是需要將字串做額外處理，跳脫字元是不佔字符數的： 1console.log(`\\`.length); // 1 要取得含特殊字元的字串可用 String.raw()： 1console.log(String.raw`\\`.length) // 2 參考來源邁向 JavaScript 勇者之路]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>樣板字串</tag>
        <tag>Template String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-一次搞懂 JavaScript 的 this]]></title>
    <url>%2F2018%2F01%2F24%2FJS-this%2F</url>
    <content type="text"><![CDATA[一次搞懂 JavaScript 的 this 前言在FB直播看到 姚偉揚 老師再說明javascript各種 this 的分辨，在此紀錄各種案例。 FB影片：一次搞懂 JavaScript 的 this主講者：姚偉揚 議程重點 一般函式的 this ES6 箭頭函式的 this Vue 組件的 this bind/apply/call 的 this 一般函式的thisthis 主要是 看函式(function)怎麼執行 的，下列為常見的分辨的方法 直接執行 → global 作為物件的成員函式執行 → 該物件 作為 DOM 事件偵聽函式 → 該 DOM 作為建構函式 → 建構出來的實例 下列為各種this的判斷 範例1 直接呼叫12345function a()&#123; console.log(this);&#125;a(); //window 範例2 作為物件的成員函式執行12345678function a()&#123; console.log(this);&#125;const obj = &#123;&#125;;obj.a = a;obj.a(); //obj 範例3 12345678910const obj = &#123; a()&#123; function b()&#123; console.log(this); &#125; b(); &#125;&#125;obj.a(); //window 因為 b() 是直接執行，並不是以 obj.b() 方式執行。 範例4 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 作為 DOM 事件偵聽函式1234567function a()&#123; console.log(this);&#125;const obj = &#123;a&#125;;btn.addEventListener('click', obj.a); //DOM元素：&lt;button id='btn'&gt;btn&lt;/button&gt; 範例5 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 12345678910111213function a()&#123; console.log(this);&#125;const obj = &#123; b()&#123; return function()&#123; a(); &#125; &#125;&#125;;btn.addEventListener('click', obj.b()); //window 因為 a() 是直接執行。 承上例，執行 obj.b() 後的函式1234567function a()&#123; console.log(this);&#125;btn.addEventListener('click', function()&#123; a(); //window&#125;); 範例6 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 123456789const obj = &#123; b()&#123; return function()&#123; console.log(this); &#125; &#125;&#125;;btn.addEventListener('click', obj.b()); //DOM元素：&lt;button id='btn'&gt;btn&lt;/button&gt; 承上例，執行 obj.b() 後的函式123btn.addEventListener('click', function()&#123; console.log(this);&#125;); 範例7 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 1234567891011function a()&#123; console.log(this);&#125;const obj = &#123; a()&#123; return a; &#125;&#125;;btn.addEventListener('click', obj.a()); //DOM元素：&lt;button id='btn'&gt;btn&lt;/button&gt; 承上例，執行 obj.a() 後的函式123btn.addEventListener('click', function()&#123; console.log(this);&#125;); 可注意觀察 範例5~7 程式碼之間有些微的不同，所造成的this有所不一樣。 善用的方式 另外一種思考的方式，我們在寫物件內的函式時，為了確保 this 能夠正確運作會先將它賦予在另一個變數上 (that, self, vm…)。 123456789101112131415161718var auntie = &#123; name: '漂亮阿姨', callName () &#123; // 先使用另一個變數指向 this，讓內層函式可以正確使用 var that = this; setTimeout(function () &#123; console.log(that); // auntie 這個物件 &#125;, 10); &#125;&#125;auntie.callName(); 箭頭函式的 this口訣： 箭頭函式裡面的this 等於 外面的this 白話文： 箭頭函式裡的this 主要是依據 外層函式(function)裡的this 是什麼就跟著是什麼。 規則 123456function x()&#123; this &lt;= 外層函式的this，規則參考「一般函式的this」 const a = () =&gt; &#123; this &lt;= 依據外層函式的this &#125;&#125; 範例1 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 12345const a = () =&gt; &#123; console.log(this);&#125;btn.addEventListener('click', a); //window 範例2 1234567const obj = &#123; a: () =&gt; &#123; console.log(this); &#125;&#125;obj.a(); //window 範例3 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 12345678function a() &#123; const b = () =&gt; &#123; console.log(this); &#125; b();&#125;btn.addEventListener('click', a); //DOM元素：&lt;button id='btn'&gt;btn&lt;/button&gt; 與 一般函式的範例3 有點類似，雖然 b() 都是直接執行，不過因為箭頭函式裡的this 主要是依據 外層函式(function)裡的this 是什麼就跟著是什麼，所以 a() 的 this 是 DOM元素，所以這裡的 b() 的 this 也會跟著是 DOM元素。 範例4 Q：包了好幾層的箭頭函數的 this 也是指向 windows 嗎? A：從 c() 一層撥一層 直到 function a()，再參照 a() 的 this 是指向誰。 洋蔥式一層一層拆解1234567891011function a()&#123; //this &lt;= 外層函式的this，規則參考「一般函式的this」 const b = () =&gt; &#123; const c = () =&gt; &#123; console.log(this); //&lt;= 依據外層函式的this &#125;; c(); &#125;; b();&#125;; Vue 組件的 this全部皆指向 vue實例 本身 範例1 一般函數12345678910111213141516var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Hello' &#125;, computed: &#123; getMessage: function () &#123; console.log(this); // this 指向 vm 实例 &#125; &#125;, methods: &#123; prompt: function() &#123; console.log(this); // this 指向 vm 实例 &#125; &#125;&#125;) 範例2 箭頭函數123456var vm = new Vue(&#123; el: "#app", methods: &#123; test: () =&gt; console.log(this), //window &#125;,&#125;); 範例3 若是 vue的建立是包在 函數 裡面時，使用 箭頭函數 ，則this要看外層函數的this。 12345678910function init() &#123; //this &lt;= 外層函式的this，規則參考「一般函式的this」 var vm = new Vue(&#123; el: "#app", methods: &#123; test: () =&gt; console.log(this), //&lt;= 依據外層函式的this &#125; &#125;);&#125; 如果在vue裡，寫箭頭函式要使用this的話，因為vue是物件，而不是函式，此時箭頭函式裡的this會指向外層函式的this，所以在vue要使用this的話，建議使用 一般函式 寫法。 bind/apply/call 的 this 一般函式使用 bind/apply/call 時，this 就是所傳入的物件 箭頭函式使用 bind/apply/call 時，this 不會有變化，規則一樣是 依據外層函式(function)裡的this 是什麼就跟著是什麼。 範例1 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 一般函式123456789function add(x, y)&#123; console.log(this);&#125;const b = add.bind(btn);b(3, 5);add.apply(btn, [3, 5]);add.call(btn, 3, 5); 範例2 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 箭頭函式123456789const add = (x, y) =&gt; &#123; console.log(this);&#125;const b = add.bind(btn);b(3, 5);add.apply(btn, [3, 5]);add.call(btn, 3, 5);]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-箭頭函式 (Arrow functions)]]></title>
    <url>%2F2018%2F01%2F23%2FES6-Arrowfunctions%2F</url>
    <content type="text"><![CDATA[箭頭函式 () =&gt; {} 簡短的語法一般使用箭頭函式與 function 的用法大致一致，可以傳入參數、也有大括號包起來，除此之外箭頭函式也有更簡短的寫法如下： 1234567891011121314151617// 正常寫法var callSomeone = (someone) =&gt; &#123; return someone + '上工了'&#125;console.log(callSomeone('伙計'))// 縮寫，單一行陳述不需要 &#123;&#125;var callSomeone = (someone) =&gt; someone + '上工了'console.log(callSomeone('伙計'))// 只有一個參數可以不加括號var callSomeone = someone =&gt; someone + '上工了'console.log(callSomeone('伙計'))// 沒有參數時，一定要有括號var callSomeone = () =&gt; '伙計' + '上工了'console.log(callSomeone('伙計')) 注意不過這個上述有個小地方也要注意一下，在大括號內的 {} 是需要自行加入 return，如果沒有傳入值則會出現 undefined。 12var callSomeone = (someone) =&gt; &#123; someone + '上工了' &#125;console.log(callSomeone('伙計')) // undefined 綁定的 this 不同口訣： 箭頭函式裡面的this 等於 外面的this 白話文： 箭頭函式裡的this 主要是依據 外層函式(function)裡的this 是什麼就跟著是什麼。 規則 123456function x()&#123; this &lt;= 外層函式的this，規則參考「一般函式的this」 const a = () =&gt; &#123; this &lt;= 依據外層函式的this &#125;&#125; 範例 callName 是使用 一般函式callName2 是使用 箭頭函式 1234567891011121314151617181920212223var name = '全域阿婆'var auntie = &#123; name: '漂亮阿姨', callName: function () &#123; // 注意，這裡是 function，以此為基準產生一個作用域 console.log('1', this.name); // 1 漂亮阿姨(外層函式) setTimeout(() =&gt; &#123; console.log('2', this.name); // 2 漂亮阿姨(依據外層函式的this) console.log('3', this); // 3 auntie 這個物件(依據外層函式的this) &#125;, 10); &#125;, callName2: () =&gt; &#123; // 注意，如果使用箭頭函式，this 依然指向 window console.log('4', this.name); // 4 全域阿婆(依據外層函式的this) setTimeout(() =&gt; &#123; console.log('5', this.name); // 5 全域阿婆(依據外層函式的this) console.log('6', this); // 6 window 物件(依據外層函式的this) &#125;, 10); &#125;&#125;auntie.callName();auntie.callName2(); 補充：因為 callName2 的 4 使用箭頭函式，所以 依據外層函式的this 的規則，就指向最外層window。 沒有 arguments 參數注意:箭頭函數裡沒有argument物件，可使用 其餘參數(Rest Operator) 替代 12const other = (...others) =&gt; others;console.log(other(10, 20, 30, 40, 50)) // [10, 20, 30, 40, 50] apply, call, bind 無效this 在 Arrow function 中是被綁定的，所以套用 apply, call, bind 的方法時是無法修改 this。 不能用在建構式由於 this 的是在物件下建立，所以箭頭函式不能像 function 一樣作為建構式的函式，如果嘗試使用此方法則會出現錯誤 (… is not a constructor)。 參考來源邁向 JavaScript 勇者之路]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>箭頭函式</tag>
        <tag>Arrow functions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-立即被呼叫的函式 (IIFE)]]></title>
    <url>%2F2018%2F01%2F16%2FJS-IIFE%2F</url>
    <content type="text"><![CDATA[立即被呼叫的函式 (Immediately Invoked Function Expression, IIFE) 前言在 2018 iT 邦幫忙鐵人賽，看到Kuro大的重新認識 JavaScript 系列文，仔細的閱讀後，紀錄自己觀念不足的部份，也非常推薦給大家觀看此系列文。 Kuro-重新認識 JavaScript 系列 立即被呼叫的函式 (IIFE)IIFE 的好處，就是可以減少「全域變數」的產生，同時也避免了變數名稱衝突的機會。 如果你有去看過 jQuery 的原始碼，就會發現 jQuery 也用了相同的手法將 window 與 undefined 保留起來： 12345(function( window, undefined ) &#123; // 略...&#125;)( window ); 當迴圈遇到 function題目：假設想透過迴圈 + setTimeout 來做到，在五秒之內，每秒鐘依序透過console.log印出：0 1 2 3 4 12345678// 假設想透過迴圈 + setTimeout 來做到// 每秒鐘將 i 的值 console 出來for( var i = 0; i &lt; 5; i++ ) &#123; window.setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125; 真的是這樣嗎？ 我們來看看執行的結果。 執行的結果是， console.log() 會在「一秒鐘之後」同時印出「五次 5」。 1234555555 「切分變數有效範圍的最小單位是 “function” 」「切分變數有效範圍的最小單位是 “function” 」「切分變數有效範圍的最小單位是 “function” 」 很重要，所以要再講三次。 所以我們利用 IIFE 稍微修改一下： IIFE12345678910for( var i = 0; i &lt; 5; i++ ) &#123; (function(x)&#123; // 將原本的 1000 改成 1000 * x window.setTimeout(function() &#123; console.log(x); &#125;, 1000 * x); &#125;)(i);&#125; 像這樣，就可以依序印出我們要的結果囉！ ES6-let、constES6 以後新增了 let 與 const，且改以 { } 作為它的 Scope。 換句話說，將範例中的 for 改為 let 就可以做到保留 i 在執行迴圈當下的「值」的效果： 12345for( let i = 0; i &lt; 5; i++ ) &#123; window.setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125;]]></content>
      <categories>
        <category>JS</category>
        <category>重新認識 JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>重新認識 JavaScript</tag>
        <tag>IIFE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-Callback Function]]></title>
    <url>%2F2018%2F01%2F16%2FJS-CallbackFunction%2F</url>
    <content type="text"><![CDATA[Callback Function &amp; Promise 前言在 2018 iT 邦幫忙鐵人賽，看到Kuro大的重新認識 JavaScript 系列文，仔細的閱讀後，紀錄自己觀念不足的部份，也非常推薦給大家觀看此系列文。 Kuro-重新認識 JavaScript 系列 Callback Function概念就如同： 辦公室電話響了 (事件被觸發 Event fired) -&gt; 接電話 (處理事件 Event Handler) 而寫成程式碼就類似： 12// 註：這裡只是比喻，並沒有電話響這個事件 XDOffice.addEventListener( '電話響', function()&#123; /* 接電話 */ &#125;, false); 可以看到，Office 透過 addEventListener 方法註冊了一個事件，當這個事件被觸發時，它會去執行我們所指定的第二個參數，也就是某個「函式」(接電話)。 換句話說，這個函式只會在滿足了某個條件才會被動地去執行，我們就可以說這是一個 Callback function。 波動拳 (a.k.a. “Callback Hell”)除了事件以外，還有另一個會需要用到 Callback function 的場景，就是「控制多個函式間執行的順序」。 下面舉例從簡單的事情慢慢演變成複雜時，會發生什麼情形 這裡定義了兩個 function： 12345678910var funcA = function()&#123; console.log('function A');&#125;;var funcB = function()&#123; console.log('function B');&#125;;funcA();funcB(); 因為 funcA 與 funcB 都會立即執行，所以執行結果必定為： 12"function A""function B" 但是，假設我們改成這樣，加上一個隨機生成的等待時間： 12345678910111213141516171819var funcA = function()&#123; var i = Math.random() + 1; window.setTimeout(function()&#123; console.log('function A'); &#125;, i * 1000);&#125;;var funcB = function()&#123; var i = Math.random() + 1; window.setTimeout(function()&#123; console.log('function B'); &#125;, i * 1000);&#125;;funcA();funcB(); 這時候就沒辦法確定是 “function A” 會先出現還是 “function B” 會先出現了對吧？ 像這種時候，為了確保執行的順序，就會透過 Callback function 的形式來處理： 1234567891011121314151617181920212223242526// 為了確保先執行 funcA 再執行 funcB// 我們在 funcA 加上 callback 參數var funcA = function(callback)&#123; var i = Math.random() + 1; window.setTimeout(function()&#123; console.log('function A'); // 如果 callback 是個函式就呼叫它 if( typeof callback === 'function' )&#123; callback(); &#125; &#125;, i * 1000);&#125;;var funcB = function()&#123; var i = Math.random() + 1; window.setTimeout(function()&#123; console.log('function B'); &#125;, i * 1000);&#125;;// 將 funcB 作為參數帶入 funcA()funcA( funcB ); 像這樣，無論 funcA 在執行的時候要等多久， funcB 都會等到 console.log(‘function A’); 之後才執行。 不過需要注意的是，當函式之間的相依過深，callback 多層之後產生的「波動拳」維護起來就會很可怕！ 1234567891011getData(function (a) &#123; getMoreData(a, function (b) &#123; getMoreData(b, function (c) &#123; getMoreData(c, function (d) &#123; getMoreData(d, function (e) &#123; ... &#125;); &#125;); &#125;); &#125;);&#125;); 再見 Callback Hell執行順序的問題是一個，還有另一個常見的狀況是這樣，再回到 「Overcooked」 的場景。 用 Overcooked (遊戲名稱：煮過頭) 比喻 同步(Synchronous)的概念假設邊緣人如我，只能自己一人玩 Overcooked，在領完食材原料之後，一樣會有青菜、番茄需要處理。因為只有一個廚師，所以要嘛先處理青菜、要嘛先處理番茄，必須先弄完一項之後再去處理另一項，整個流程會被前一個步驟卡住。像這樣「先完成 A 才能做 B、C、D …」的運作方式我們就會把它稱作「同步」(Synchronous) 。 當我要確保「切青菜、切番茄、擺盤」三個動作都完成之後，我才能繼續「上菜」這個動作。 在面臨這種問題的時候，我要怎麼確保三個動作都完成之後，才繼續執行後面的程式呢？ 最直覺的方式是新增一個變數來管理狀態： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var result = []; //紀錄已完成的事件var step = 3; //全部完成的總數量// 假設 funcA、funcB、funcC 分別代表「切青菜、切番茄、擺盤」function funcA()&#123; window.setTimeout(function()&#123; result.push('A'); //紀錄 A 完成 console.log('A'); if( result.length === step )&#123; funcD(); &#125; &#125;, (Math.random() + 1) * 1000);&#125;function funcB()&#123; window.setTimeout(function()&#123; result.push('B'); //紀錄 B 完成 console.log('B'); if( result.length === step )&#123; funcD(); &#125; &#125;, (Math.random() + 1) * 1000);&#125;function funcC()&#123; window.setTimeout(function()&#123; result.push('C'); //紀錄 C 完成 console.log('C'); if( result.length === step )&#123; funcD(); &#125; &#125;, (Math.random() + 1) * 1000);&#125;function funcD()&#123; console.log('上菜！'); result = [];&#125;funcA();funcB();funcC(); 像上面這樣，當我們依序執行了 funcA()、funcB()、funcC()，由於內部 setTimeout 會等待亂數時間的關係，我們無法得知誰先誰後。 但可以確定的是，當這三個函式執行的時候就會去檢查 result.length === step ，如果成立，就表示三個任務都已經完成，那麼就可以再去呼叫 funcD 執行後續的事情。 如果不希望使用全域變數來污染執行環境的話，甚至可以包裝成一個通用的函式： 閉包的概念12345678910111213141516function serials(tasks, callback) &#123; var step = tasks.length; var result = []; // 檢查的邏輯寫在這裡 function check(r) &#123; result.push(r); if( result.length === step )&#123; callback(); &#125; &#125; tasks.forEach(function(f) &#123; f(check); &#125;);&#125; 那麼改寫一下 funcA()、funcB()、funcC(): 123456789101112131415161718192021222324function funcA(check)&#123; window.setTimeout(function()&#123; console.log('A'); check('A'); &#125;, (Math.random() + 1) * 1000);&#125;function funcB(check)&#123; window.setTimeout(function()&#123; console.log('B'); check('B'); &#125;, (Math.random() + 1) * 1000);&#125;function funcC(check)&#123; window.setTimeout(function()&#123; console.log('C'); check('C'); &#125;, (Math.random() + 1) * 1000);&#125;function funcD()&#123; console.log('上菜！');&#125; 最後呼叫的時候，我們就可以透過這樣呼叫 serials() ： 1serials([funcA, funcB, funcC], funcD); 把想要提前執行的函式以陣列的方式傳進 serials() 作為第一個參數，當陣列中的函式都執行完畢後，才會呼叫第二個參數的 funcD()。 Promise 物件為了解決同步/非同步的問題，自從 ES6 開始新增了一個叫做 Promise 的特殊物件。 簡單來說，Promise 按字面上的翻譯就是「承諾、約定」之意，回傳的結果要嘛是「完成」，要嘛是「拒絕」。 實際寫成 Promise 的程式碼大概像這樣： 1234const myFirstPromise = new Promise((resolve, reject) =&gt; &#123; resolve(someValue); // 完成 reject("failure reason"); // 拒絕&#125;); 要提供一個函式 promise 功能，讓它回傳一個 promise 物件即可： 12345function myAsyncFunction(url) &#123; return new Promise((resolve, reject) =&gt; &#123; // resolve() or reject() &#125;);&#125;; 當 Promise 被完成的時候，我們就可以呼叫 resolve()，然後將取得的資料傳遞出去。 或是說想要拒絕 Promise ， 那麼就呼叫 reject() 來拒絕。 一般來說， Promise 物件會有這幾種狀態： pending: 初始狀態，不是 fulfilled 或 rejected。 fulfilled: 表示操作成功地完成。 rejected: 表示操作失敗。 整個 Promise 流程可以用這張圖表示： 如果我們需要依序串連執行多個 promise 功能的話，可以透過 .then() 來做到。 以剛剛的 funcA()、funcB()、funcC() 來當範例，我們將這三個函式分別透過 Promise 包裝： 1234567891011121314151617181920212223242526function funcA()&#123; return new Promise(function(resolve, reject)&#123; window.setTimeout(function()&#123; console.log('A'); resolve('A'); // 完成 &#125;, (Math.random() + 1) * 1000); &#125;);&#125;function funcB()&#123; return new Promise(function(resolve, reject)&#123; window.setTimeout(function()&#123; console.log('B'); resolve('B'); // 完成 &#125;, (Math.random() + 1) * 1000); &#125;);&#125;function funcC()&#123; return new Promise(function(resolve, reject)&#123; window.setTimeout(function()&#123; console.log('C'); resolve('C'); // 完成 &#125;, (Math.random() + 1) * 1000); &#125;);&#125; 最後透過呼叫 1funcA().then(funcB).then(funcC); 就可以做到等 funcA() 被 「resolve」之後再執行 funcB()，然後 resolve 再執行 funcC() 的順序了。 如果我們不在乎 funcA()、funcB()、funcC() 誰先誰後，只關心這三個是否已經完成呢？ 那就可以透過 Promise.all() 來做到： Promise.all()12345// funcA, funcB, funcC 的先後順序不重要// 直到這三個函式都回覆 resolve 或是「其中一個」 reject 才會繼續後續的行為Promise.all([funcA(), funcB(), funcC()]) .then(function()&#123; console.log('上菜'); &#125;);]]></content>
      <categories>
        <category>JS</category>
        <category>重新認識 JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>重新認識 JavaScript</tag>
        <tag>Callback Function</tag>
        <tag>Callback Hell</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-Events]]></title>
    <url>%2F2018%2F01%2F16%2FJS-Events%2F</url>
    <content type="text"><![CDATA[那些你知道與不知道的事件們 前言在 2018 iT 邦幫忙鐵人賽，看到Kuro大的重新認識 JavaScript 系列文，仔細的閱讀後，紀錄自己觀念不足的部份，也非常推薦給大家觀看此系列文。 Kuro-重新認識 JavaScript 系列 表單相關事件 input 事件： 當 input、 textarea 以及帶有 contenteditable 的元素內容被改變時，就會觸發 input 事件。 change 事件： 當 input、select、textarea、radio、checkbox 等表單元素被改變時觸發。 但與 input 事件不同的是，input 事件會在輸入框輸入內容的當下觸發，而 change 事件則是在目前焦點離開輸入框後才觸發。 submit 事件：當表單被送出時觸發，通常表單驗證都會在這一步處理，若驗證未通過則 return false;。 特殊事件透過 Composition Events 我們可以觀察使用者在輸入框內開啟輸入法 (Input Method Editor, IME) 時，組字或選字的狀態。 這個時候就需要透過 Composition Events 來為輸入框做增強。 compositionstart: 輸入框內開啟輸入法，且正在拼字時觸發。 compositionupdate: 輸入框內開啟輸入法，且正在拼字或選字時更改了內容時觸發。 compositionend: 輸入框內開啟輸入法，拼字或選字完成，正要送出至輸入框時觸發。 可以看到，如果要確認使用者輸入完成並送出文字時，就可以透過 compositionend來做最後確認。 執行的時候像這樣： 開啟console，在input輸入文字：event觸發時機 鍵盤相關事件鍵盤相關事件有下列三種，在大多數情況下會將鍵盤事件註冊在 input 的輸入框上。 keydown 事件: 「壓下」鍵盤按鍵時會觸發 keydown 事件。 keypress 事件: 除了 Shift, Fn, CapsLock 這三種按鍵外按住時會觸發，若按著不放則會連續觸發。 keyup 事件: 「放開」鍵盤按鍵時觸發。 透過 e.keyCode 就可以判斷使用者目前按下的是哪個按鈕 123456textBox.addEventListener('keydown', function(e)&#123; // enter 的 keyCode 是 13 if( e.keyCode === 13 )&#123; formSubmit(); &#125;&#125;, false); 註： keyCode 的對應表可以到這裡查看：https://gist.github.com/tylerbuchea/8011573 滑鼠相關事件 mousedown / mouseup 事件: 這兩個事件分別會在滑鼠點擊了某元素「按下」(mousedown) 按鈕，以及「放開」(mouseup) 按鈕時觸發。 click 事件: 當滑鼠「點擊」了某元素時觸發。 dblclick事件: 當滑鼠「連點兩次」了某元素時觸發。 mouseenter / mousemove / mouseleave 事件： 這三個事件要放在一起看 當滑鼠游標移入了某元素時，會先觸發 mouseenter 事件。 滑鼠游標在這個元素內「移動」時，會連續觸發 mousemove 事件。 直到滑鼠游標離開了這個元素，才觸發 mouseleave 事件。 這些滑鼠相關的事件，都可以透過 event.pageX 與 event.pageY 屬性去取得目前在網頁對應的座標。 介面相關事件 load 事件：註冊在 window 物件上，指的是網頁資源 (包括CSS、JS、圖片等) 全數載入完畢後觸發。如果是 img 元素的 load 事件，則表示是此圖片載入完畢後觸發。 unload 、 beforeunload 事件：與 load 事件相反，unload 與 beforeunload 事件分別會在離開頁面或重新整理時觸發，而 beforeunload 會跳出對話框詢問使用者是否要離開目前頁面。 resize 事件：當瀏覽器 (window) 或指定元素 (element) 的「尺寸變更」時觸發。 scroll 事件：當瀏覽器 (window) 或指定元素 (element) 的「捲軸被拉動」時觸發。 DOMContentLoaded 事件：類似於 load 事件，但不同的是，load 事件是在網頁「所有」資源都已經載入完成後才會觸發，而 DOMContentLoaded 事件是在 DOM 結構被完整的讀取跟解析後就會被觸發，不須等待外部資源讀取完成。 簡單來說， DOMContentLoaded 與 load 的時機可以用這張圖來解釋：]]></content>
      <categories>
        <category>JS</category>
        <category>重新認識 JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>重新認識 JavaScript</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-事件機制的原理]]></title>
    <url>%2F2018%2F01%2F15%2FJS-Bubbling-Capturing%2F</url>
    <content type="text"><![CDATA[事件冒泡 (Event Bubbling) &amp; 事件捕獲 (Event Capturing) 前言在 2018 iT 邦幫忙鐵人賽，看到Kuro大的重新認識 JavaScript 系列文，仔細的閱讀後，紀錄自己觀念不足的部份，也非常推薦給大家觀看此系列文。 Kuro-重新認識 JavaScript 系列 事件冒泡 (Event Bubbling) 圖片來源： Event Flow: capture, target, and bubbling 事件冒泡指的是「從啟動事件的元素節點開始，逐層往上傳遞」，直到整個網頁的根節點，也就是 document。 事件捕獲 (Event Capturing) 圖片來源： Event Flow: capture, target, and bubbling 剛剛說過「事件冒泡」機制是由下往上來傳遞，那麼「事件捕獲」(Event Capturing) 機制則正好相反。 事件傳遞順序既然事件傳遞順序有兩種機制，那我怎麼知道事件是依賴哪種機制執行的？ 答案是：兩種都會執行。 圖片來源: W3C, DOM event flow 開啟console，分別點擊父元素、子元素事件機制的原理 事件監聽 EventTarget.addEventListener()addEventListener() 基本上有三個參數，分別依序是 事件名稱 事件的處理器(事件觸發時執行的 function) Boolean，由這個 Boolean 決定事件是以「捕獲」或「冒泡」機制執行，若不指定則預設為「冒泡」。 1&lt;button id="btn"&gt;Click&lt;/button&gt; 綁定監聽動作12345var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; console.log('HI');&#125;, false); 使用這種方式來註冊事件的好處是可以重複指定多個「處理器」(handler) 給同一個元素的同一個事件： 123456789var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; console.log('HI');&#125;, false);btn.addEventListener('click', function()&#123; console.log('HELLO');&#125;, false); 點擊後 console 出現： 12"HI""HELLO" 若是要解除事件的註冊，則是透過 removeEventListener() 來取消。 removeEventListener() 的三個參數與 addEventListener() 一樣，分別是「事件名稱」、「事件的處理器」以及「捕獲」或「冒泡」的機制。 但是需要注意的是，由於 addEventListener() 可以同時針對某個事件綁定多個 handler，所以透過 removeEventListener() 解除事件的時候，第二個參數的 handler 必須要與先前在 addEventListener() 綁定的 handler 是同一個「實體(記憶體位址) 」。 二個function各自存在不同的記憶體位址12345678910var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; console.log('HI');&#125;, false);// 移除事件，但是沒用btn.removeEventListener('click', function()&#123; console.log('HI');&#125;, false); 像上面這樣，即使執行了 removeEventListener 來移除事件，但 click 時仍會出現 ‘HI’。 因為 addEventListener 與 removeEventListener 所移除的 handler 實際上是兩個不同實體(記憶體位址) 的 function 物件。 同一個function，同個記憶體位址1234567891011var btn = document.getElementById('btn');// 把 event handler 拉出來var clickHandler = function()&#123; console.log('HI');&#125;;btn.addEventListener('click', clickHandler, false);// 移除 clickHandler， ok!btn.removeEventListener('click', clickHandler, false);]]></content>
      <categories>
        <category>JS</category>
        <category>重新認識 JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>重新認識 JavaScript</tag>
        <tag>事件冒泡 (Event Bubbling)</tag>
        <tag>事件捕獲 (Event Capturing)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-Pass by sharing]]></title>
    <url>%2F2018%2F01%2F15%2FJS-Passbysharing%2F</url>
    <content type="text"><![CDATA[JavaScript 是「傳值」或「傳址」？ 前言在 2018 iT 邦幫忙鐵人賽，看到Kuro大的重新認識 JavaScript 系列文，仔細的閱讀後，紀錄自己觀念不足的部份，也非常推薦給大家觀看此系列文。 Kuro-重新認識 JavaScript 系列 「傳值」或「傳址」？所以我說那個 JavaScript 是「傳值」或「傳址」呢？ 在大多數的情況下，基本型別是「傳值」，而物件型別會是「傳址」的方式，但凡事都有例外。 我們來看看下面這個例子： 12345678var coin1 = &#123; value: 10 &#125;;function changeValue(obj) &#123; obj = &#123; value: 123 &#125;;&#125;changeValue(coin1);console.log(coin1); // ？ 猜猜看，經過 changeValue(coin1) 操作後的 coin1 會是什麼？ 答案仍是 { value: 10 } 。 剛剛說過，物件型別會是「傳址」的方式來更新資料，那應該會是 { value: 123 } 才對，為什麼依然不變？ 事實上，JavaScript 不屬於單純的傳值或傳址。更準確一點來說，JavaScript 應該屬於透過 pass by sharing 來傳遞資料。 「傳值」或「傳址」對大多數的開發者來說應該都不陌生，那麼「pass by sharing」又是什麼呢？ Pass by sharing「Pass by sharing」的特點在於，當 function 的參數，如 function changeValue(obj){ … } 中的 obj 被重新賦值的時候，外部變數的內容是不會被影響的。 function裡，重新賦值12345678var coin1 = &#123; value: 10 &#125;;function changeValue(obj) &#123; obj = &#123; value: 123 &#125;;&#125;changeValue(coin1);console.log(coin1); // 此時 coin1 仍是 &#123; value: 10 &#125; 如果不是重新賦值的情況，則又會回到大家所熟悉的狀況： function裡，無 重新賦值123456789var coin1 = &#123; value: 10 &#125;;function changeValue(obj) &#123; // 僅更新 obj.value，並未重新賦值 obj.value = 123;&#125;changeValue(coin1);console.log(coin1); // 此時 coin1 則會變成 &#123; value: 123 &#125; Pass by sharing 說明2用下例說明，因為 b變數 原本是指向 a變數 的記憶體位置，共用同一個記憶體，不過當重新給予 null 值時，b變數 就改指向 null 了，此時 b變數 就不再指向 a變數 的記憶體位置。 完全重新賦值123456var a = &#123;name: "Kanboo"&#125;;var b = a; // b變數 指向 a變數的記憶體位置b = null; // 完全重新賦值console.log(a); // &#123;name: "Kanboo"&#125; 若不是 完全重新賦值 的話，就跟傳址的狀況一樣。 用 b變數 去更新值123456var a = &#123;name: "Kanboo"&#125;;var b = a; // b變數 指向 a變數的記憶體位置b.name = "Lucas";console.log(a); // &#123;name: "Lucas"&#125; JS中是 pass by value 还是 pass by reference]]></content>
      <categories>
        <category>JS</category>
        <category>重新認識 JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>重新認識 JavaScript</tag>
        <tag>Pass by sharing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-物件、陣列以及型別判斷]]></title>
    <url>%2F2018%2F01%2F15%2FJS-Typejudgment%2F</url>
    <content type="text"><![CDATA[物件、陣列以及型別判斷。 前言在 2018 iT 邦幫忙鐵人賽，看到Kuro大的重新認識 JavaScript 系列文，仔細的閱讀後，紀錄自己觀念不足的部份，也非常推薦給大家觀看此系列文。 Kuro-重新認識 JavaScript 系列 基本型別與物件型別JavaScript 內建的型別主要可以分成基本型別 (Primitives) 與物件型別 (Object) 兩大類。而基本型別又分成 string、number、boolean、null、undefined 幾種，除了以上幾種之外，其他都可以歸類至 物件型別 (Object)物件型別 (Object)物件型別 (Object) 判斷屬性是否存在方法1：物件中不存在的屬性，此時會回傳 undefined方法2：hasOwnProperty() 方法不會往上檢查物件的原型鏈(prototype chain)，而 in 運算子，則會繼續往物件原型鏈上檢查。 方法1 物件中不存在的屬性，此時會回傳 undefined 123var obj = &#123;&#125;;console.log( obj.name ); // undefined 但這麼做會有個例外，就是當該屬性剛好就是 undefined 時，這招就沒用了。 除了檢查 undefined 之外，還有 in 運算子 與 hasOwnProperty() 方法。 方法2 雖然兩者都可以檢查物件的屬性是否存在，但hasOwnProperty() 方法不會往上檢查物件的原型鏈(prototype chain)，，只會檢查物件本身是否存在這個屬性，而 in 運算子，則會繼續往物件原型鏈上檢查。 範例11234567891011var obj = &#123; name: 'Object'&#125;;// 透過 in 檢查屬性console.log( 'name' in obj ); // trueconsole.log( 'value' in obj ); // false// 透過 hasOwnProperty() 方法檢查obj.hasOwnProperty('name'); // trueobj.hasOwnProperty('value'); // false 上述範例1，雖然二種檢查結果都一樣，但我們可看下列的範例2，當檢查某一屬性是在原型鋉上時，會有什麼不一樣 範例21234567//toString 為 原型鍊上的 屬性// 透過 in 檢查屬性console.log( 'toString' in obj ); // true// 透過 hasOwnProperty() 方法檢查obj.hasOwnProperty('toString'); // false typeof: 型別判斷檢查變數型別 (正確來講應該是值，變數沒有型別，值才有)，可以透過 typeof 運算子來處理： 12345678910typeof true; // 'boolean'typeof 'Kanboo'; // 'string'typeof 123; // 'number'typeof NaN; // 'number'typeof &#123; &#125;; // 'object'typeof [ ]; // 'object'typeof undefined; // 'undefined'typeof window.alert; // 'function'typeof null; // 'object' 要注意的是，透過 typeof 運算子回傳的東西都是「字串」。 typeof null 為什麼是 “object” ?其實這只是一個 Bug ，所以小心使用 null 。 參考1: Null and typeof參考2: The history of “typeof null” 如何判別是否為陣列當我們利用 typeof 去檢查一個「陣列」時，會得到 “object“ 的結果， typeof [ ]; // &#39;object&#39; 但如果在實務上仍會有需要判斷某變數是否為一個陣列而非物件的時候，可用 isArray() 方法， 12345678Array.isArray([]); // trueArray.isArray([1]); // trueArray.isArray(new Array()); // trueArray.isArray(); // falseArray.isArray(&#123;&#125;); // falseArray.isArray(null); // falseArray.isArray(undefined); // false]]></content>
      <categories>
        <category>JS</category>
        <category>重新認識 JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>重新認識 JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-各種迴圈的用法]]></title>
    <url>%2F2018%2F01%2F09%2FJS-Traverse%2F</url>
    <content type="text"><![CDATA[紀錄各種迴圈的用法。 前言JS常常需要針對 陣列(Array)、物件(Object) 這二種資料進行分析及修改，故整理下列幾種方法， 單純遍歷陣列元素 for forin forEach 判斷是否符合資格 every：遍歷每個元素判斷是否皆符合條件，若其一不符，就回傳 false some： 遍歷每個元素判斷是否皆符合條件，若其一符合，就回傳 true 產生新的陣列 map：遍歷每個元素，進行 加工、校正 filter：遍歷每個元素，保留符合條件(true)的值，不符合，則去除掉。 reduce：遍歷每個元素，依序組合、加總，然後丟給下個元素，最終會回傳一個結果。 for最常見的用法，不多加說明。 範例 12345let arr = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];for (let i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]);&#125; forin可傳入 objec 或 array 型態的資料。 範例 Array型態12345var arr = ["zero","one","two"];for (var key in arr) &#123; console.log(arr[key]);&#125; Object型態12345var obj = &#123;a: 1, b: 2, c: 3&#125;; for (const item in obj) &#123; console.log(obj[item]);&#125; MDN-for…in forEach可用來取代 for 的寫法，讓程式碼更簡短，省略掉定義 i、arr.length…等動作。 語法 123arr.forEach( callback(currentValue, index, array)&#123; /* your code */&#125;); callback currentValue(常用)：原陣列目前所迭代處理中的元素。 index(選用)：原陣列目前處理中的元素之索引。 array(選用)：呼叫 forEach() 方法的陣列。 範例 ES512345const arr = ['a', 'b', 'c'];arr.forEach(function(element) &#123; console.log(element);&#125;); ES612345const arr = ['a', 'b', 'c'];arr.forEach((element) =&gt; &#123; console.log(element);&#125;); MDN-forEach() every對每個陣列元素判斷是否皆符合條件，若其一不符，就回傳 false 語法 123arr.every( callback(currentValue, index, array)&#123; /* your code */&#125;); callback currentValue(常用)：原陣列目前所迭代處理中的元素。 index(選用)：原陣列目前處理中的元素之索引。 array(選用)：呼叫 every() 方法的陣列。 範例 12345678910function isBigEnough(element, index, array) &#123; //是否大於10 return element &gt;= 10;&#125;// 其中 5 沒有大於 10[12, 5, 8, 130, 44].every(isBigEnough); // false// 皆符合大於 10[12, 54, 18, 130, 44].every(isBigEnough); // true MDN-every() some對每個陣列元素判斷是否皆符合條件，若其一符合，就回傳 true 語法 123arr.some( callback(currentValue, index, array)&#123; /* your code */&#125;); callback currentValue(常用)：原陣列目前所迭代處理中的元素。 index(選用)：原陣列目前處理中的元素之索引。 array(選用)：呼叫 some() 方法的陣列。 範例 12345678910function isBiggerThan10(element, index, array) &#123; //是否大於10 return element &gt; 10;&#125;// 全部都無 大於10[2, 5, 8, 1, 4].some(isBiggerThan10); // false// 其中 12 有大於10[12, 5, 8, 1, 4].some(isBiggerThan10); // true MDN-some() map可對每個陣列元素進行 加工、校正 的處理，最後回傳一個 新的陣列。 原先的陣列與後來新產生出的陣列，個數(Array.length) 會一樣多。 語法 123arr.map( callback(currentValue, index, array)&#123; /* your code */&#125;); callback currentValue(常用)：原陣列目前所迭代處理中的元素。 index(選用)：原陣列目前處理中的元素之索引。 array(選用)：呼叫 map() 方法的陣列。 範例1 加工12345678var myArr = [ 1, 2, 3 ];var newArr = myArr.map(function(element) &#123; // 每個數都加1 return element + 1;&#125;);console.log(newArr); // [ 2, 3, 4 ] 範例2 校正123456789101112var myArr = [ 1, 20, 3, 40, 50, 6, 7, 80, 9, 10 ];var newArr = myArr.map(function(element) &#123; // 校正大於10的數字，統一變100 if (element &lt; 10)&#123; return element; &#125;else&#123; return 100; &#125; &#125;);console.log(newArr); // [1, 100, 3, 100, 100, 6, 7, 100, 9, 100] MDN-map() filter遍歷每個元素，保留符合條件(true)的值，不符合，則去除掉。 原先的陣列與後來新產生出的陣列，個數(Array.length)可能不一樣多。 語法 123arr.filter( callback(currentValue, index, array)&#123; /* your code */&#125;); callback currentValue(常用)：原陣列目前所迭代處理中的元素。 index(選用)：原陣列目前處理中的元素之索引。 array(選用)：呼叫 filter() 方法的陣列。 範例 12345678var myArr = [ 1, 20, 3, 40, 50, 6, 7, 80, 9, 10 ];var newArr = myArr.filter(function(element) &#123; // 取得大於50的數 return element &gt;= 50;&#125;);console.log(newArr); // [50, 80] MDN-filter() reduce遍歷每個元素，依序組合、加總，然後丟給下個元素，最終會回傳一個結果。 語法 123arr.reduce( callback(accumlator, currentValue, index, array)&#123; /* your code */&#125;, initialValue) callback accumulator(常用)：用來累積回呼函式回傳值的累加器。 currentValue(常用)：原陣列目前所迭代處理中的元素。 index(選用)：原陣列目前所迭代處理中的元素之索引。 array(選用)：呼叫 reduce() 方法的陣列。 initialValue(常用)：於第一次呼叫 callback 時要傳入的累加器初始值。 範例1 注意reduce第二個參數 0 , 代表的意思是開始執行遍歷前的初始值。 有設定初始值1234567891011121314151617181920var myArr = [ 1, 2, 3 ];// 處理每個元素後等待回傳結果，第一次處理時代入初始值 0var result = myArr.reduce(function(prev, element) &#123; console.log(prev,element); // 與之前的數值加總，回傳後代入下一輪的處理 return prev + element;&#125;, 0);/* prev,element 的執行log，共執行三次第一次：0 1第二次：1 2第三次：3 3*/// 最終結果console.log(result); // 6 範例2 注意此次沒有設定reduce第二個參數, 此時就會自動抓取陣列第一個元素當作初始值。 無初始值12345678910111213141516171819var myArr = [ 1, 2, 3 ];// 處理每個元素後等待回傳結果，第一次處理時代入初始值 0var result = myArr.reduce(function(prev, element) &#123; console.log(prev,element); // 與之前的數值加總，回傳後代入下一輪的處理 return prev + element;&#125;);/* prev,element 的執行log，共執行二次第一次：1 2第二次：3 3*/// 最終結果console.log(result); // 6 範例3 除了一般數字的加總，也可配合判斷式，最終產出一個新的陣列。 1234567891011121314151617181920212223let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];let result_04 = source.reduce((p, c) =&gt; &#123; //includes 判斷是否已存在 if (!p.includes(c)) p.push(c); console.log("p", p); return p;&#125;, []);/*迴圈的執行log，共執行七次p ["Kanboo"]p ["Kanboo", "Jack"]p ["Kanboo", "Jack", "Rabbit"]p ["Kanboo", "Jack", "Rabbit", "Lucas"]p ["Kanboo", "Jack", "Rabbit", "Lucas"]p ["Kanboo", "Jack", "Rabbit", "Lucas"]p ["Kanboo", "Jack", "Rabbit", "Lucas"] *///最終結果console.log("result_04", result_04); // ["Kanboo", "Jack", "Rabbit", "Lucas"] MDN-Reduce()fred-Map、Reduce]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>for</tag>
        <tag>forin</tag>
        <tag>forEach</tag>
        <tag>every</tag>
        <tag>some</tag>
        <tag>map</tag>
        <tag>filter</tag>
        <tag>reduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-ArrayUnique]]></title>
    <url>%2F2018%2F01%2F08%2FJS-ArrayUnique%2F</url>
    <content type="text"><![CDATA[紀錄 ArrayUnique 從早期indexOf的方式到現今各種優化的寫法。 前言下列的各種範例，統一使用的 Array資料，如下 ArrayData1let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"]; forloop + indexOf早期使用的 for迴圈 + indexOf 判斷是否已存在的值。 indexOf123456789let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];let result_01 = [];for (let i = 0; i &lt; source.length; i++) &#123; let el = source[i]; if (result_01.indexOf(el) === -1) result_01.push(el);&#125;console.log("result_01", result_01); // ["Kanboo", "Jack", "Rabbit", "Lucas"] includes在ES6提供了一個新方法：Array.prototype.includes()，判斷陣列中是否已有相同的值？ 有相同的值，回傳 true 無相同的值，回傳 false 123456789let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];let result_02 = [];for (let i = 0; i &lt; source.length; i++) &#123; let el = source[i]; if (!result_02.includes(el)) result_02.push(el);&#125;console.log("result_02", result_02); // ["Kanboo", "Jack", "Rabbit", "Lucas"] MDN-Array.prototype.includes() forEach將原本使用的 for迴圈 ，改使用 forEach 執行，省略掉定義 i、source.length…等動作。 12345678let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];let result_03 = [];source.forEach((el) =&gt; &#123; if (!result_03.includes(el)) result_03.push(el);&#125;);console.log("result_03", result_03); // ["Kanboo", "Jack", "Rabbit", "Lucas"] MDN-arr.forEach reduce()遍歷每個元素，依序組合、加總，然後丟給下個元素，最終會回傳一個結果 12345678910let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];let result_04 = source.reduce((p, c) =&gt; &#123; //includes 判斷是否已存在 if (!p.includes(c)) p.push(c); return p;&#125;, []);console.log("result_04", result_04); // ["Kanboo", "Jack", "Rabbit", "Lucas"] MDN-reduce() Set() + Array.from()Set 對象允許你存儲任何類型的唯一值，無論是原始值或者是對象引用。 Array.from() 會從類陣列(array-like)或是可迭代的物件建立一個新的陣列。 根據上述二種方法的特性，快速達成產生一個 已去除重覆值的新陣列 1234567let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];//1. 將 source資料 丟進 new set，使其產生一個新的 set集合 ，並且已去除重覆的值//2. 然後再將 set集合 丟進 Array.from，將 set集合的資料 轉化成 Array型態。(註：產生新陣列，不影響舊資料)let result_05 = Array.from(new Set(source));console.log("result_05", result_05); // ["Kanboo", "Jack", "Rabbit", "Lucas"] MDN-Array.from()MDN-Set()阮一峰-Set() Set() + Spread... 為 ES6的展開運算子（spread operator），把一個陣列展開(expand)成個別數值 簡寫1234567let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];//1. 將 source資料 丟進 new set，使其產生一個新的 set集合 ，並且已去除重覆的值//2. 用 ...(展開運算子)，將 Set 轉換為 Array(註：...set外圈有個 中框號[]，用來轉換陣列型態)let result_06 = [...new Set(source)];console.log("result_06", result_06); // ["Kanboo", "Jack", "Rabbit", "Lucas"] 補充說明 ... 只是將 陣列、set 的值拆解一個一個的值，並無額外產生新陣列。 12345let number = [1,2,3,4,5];let mySet = new Set([1,2,3,4]);console.log(...number); // 1,2,3,4,5console.log(...mySet); // 1,2,3,4 PJ-…eddy-…]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Array</tag>
        <tag>Unique</tag>
        <tag>Reduce</tag>
        <tag>Set</tag>
        <tag>Spread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS-Nodemailer]]></title>
    <url>%2F2018%2F01%2F03%2FNodeJS-Nodemailer%2F</url>
    <content type="text"><![CDATA[NodeJS如何實現寄信 前言Mail寄送功能使用 Gmail 當作郵件伺服器，所以需先開通權限，開通後，就可以慢慢新增寄信的功能，以及額外優化的部份。 Gmail-低安全性應用程式 nodemailer - 發信功能的介接安裝 1$ npm install nodemailer --save 範例 實現基本寄信的功能，步驟如下 載入 Mail模組 設定 SMTP 相關資料 撰寫Mail相關內容 發送郵件 不過在實際寄信的過程，有出現錯誤訊息為 self signed certificate in certificate chain，此錯誤訊息，將在後面小節額外說明。 起手式1234567891011121314151617181920212223242526272829303132333435363738var express = require('express');var router = express.Router();var nodemailer = require('nodemailer'); // Mail模組//設定 SMTP 相關資料var transporter = nodemailer.createTransport(&#123; service: 'Gmail', secureConnection: true, // 使用SSL方式（安全方式，防止被竊取信息） auth: &#123; user: 'Gmail帳號', // generated ethereal user pass: 'Gmail密碼' // generated ethereal password &#125;, tls: &#123; // 不得檢查服務器所發送的憑證 rejectUnauthorized: false &#125;&#125;);//撰寫Mail相關內容var mailOptions = &#123; from: '"王康寶" &lt;wang.kanboo@gmail.com&gt;', // sender address to: 'wang.kanboo@gmail.com', // list of receivers subject: 'Node測試寄信', // Subject line text: '測試寄信內容', // plain text body html: '&lt;p&gt;HTML version of the message&lt;/p&gt;'&#125;;//發送郵件transporter.sendMail(mailOptions, function (error, info) &#123; if (error) &#123; return console.log(error); &#125; //轉址 res.redirect('/contact/review');&#125;) Nodemailer TLS - 傳輸層安全性協定在實際寄信的過程，有出現錯誤訊息為 self signed certificate in certificate chain，原因為Gmail為HTTPS協定，會發送的 CA 簽名的證書，而Node.js 客戶機驗證CA 簽名的證書，方法是根據CA 的公用證書檢查CA 簽名的證書，不過因為我們沒有 CA 的公用證書，所以我們需增加一個參數 rejectUnauthorized ，去忽略此驗證的動作。 新增 tls 的 rejectUnauthorized12345678910111213//設定 SMTP 相關資料var transporter = nodemailer.createTransport(&#123; service: 'Gmail', secureConnection: true, // 使用SSL方式（安全方式，防止被竊取信息） auth: &#123; user: 'Gmail帳號', // generated ethereal user pass: 'Gmail密碼' // generated ethereal password &#125;,+ tls: &#123;+ // 不得檢查服務器所發送的憑證+ rejectUnauthorized: false+ &#125;&#125;); self signed certificate in certificate chain node js? Allow self-signed certificates nodemailer 新增附件擷取 撰寫Mail相關內容 這一部份，新增 attachments 參數，並且該如何正確取得伺服器電腦上的附件。 注意的點： 附件路徑需設定 完整路徑 可透過 process.cwd() 取得目前專案的目錄，在延伸至放附件的路徑，如：path: process.cwd() + &#39;/public/attach/image.png&#39; 另外可新增 cid 的值，可供 郵件html 渲染出附件檔案。 新增附件12345678910111213141516171819//撰寫Mail相關內容var mailOptions = &#123; from: '"王康寶" &lt;wang.kanboo@gmail.com&gt;', // sender address to: 'wang.kanboo@gmail.com', // list of receivers subject: 'Node測試寄信', // Subject line html: req.body.description + '&lt;br/&gt;&lt;br/&gt;' ++ '&lt;img src="cid:image_001"/&gt;' + // 引用attachments的cid '&lt;br/&gt;' + '來自電子郵件：' + req.body.email, // plain text body+ attachments: [&#123;+ filename: 'text.txt',+ content: '軍整風綠業新！'+ &#125;, &#123;+ filename: 'image.png',+ path: process.cwd() + '/public/attach/image.png', // 附件路徑+ cid: 'image_001' //cid可被郵件使用+ &#125;]&#125;; 結果 What is the right way to set attachments path in nodeMailer? Nodemailer-Attachments CSURF - 阻擋跨站攻擊為了預防 跨站請求偽造 的攻擊，所以我們使用 CSURF模組 來協助我們驗證是否為本伺服器所發出的請求，簡單來說，就是利用 後端session 和 前端cookie 的配合，達成此驗證功能。 安裝 1$ npm install csurf --save 範例 載入模組後，建立CSURF驗證 在 get、post 之前，都需新增 middlewares 的卡控判斷。 在前端表單，新增一段 在 csrfToken的HTML，供驗證使用。 後端.js1234567891011121314151617181920212223242526272829var express = require('express');var router = express.Router();var nodemailer = require('nodemailer'); // Mail模組var csrf = require('csurf'); // 阻擋跨站攻擊(CSURF)// 建立一個cookie供CSURF驗證 - setup route middlewaresvar csrfProtection = csrf(&#123; cookie: true&#125;);//傳入CSURF的驗證router.get('/', csrfProtection, function (req, res) &#123; res.render('contact', &#123; csrfToken: req.csrfToken() //傳入csrfToken驗證資料 &#125;);&#125;);//接收資料時，驗證csrfToken是否正確router.post('/post', csrfProtection, function (req, res) &#123; /* your code */ res.redirect('/contact/review');&#125;); 前端表單：紀錄由後端提供的csrfToken123456789101112&lt;form action="/contact/post" method="post"&gt;+ &lt;input type="hidden" name="_csrf" value="&lt;%= csrfToken %&gt;"&gt; &lt;h1&gt;聯絡我們&lt;/h1&gt; &lt;div&gt; &lt;label for="email"&gt;電子郵件：&lt;/label&gt; &lt;input type="text" name="email" id="email"/&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="submit" value="送出" /&gt; &lt;/div&gt; &lt;/form&gt; CSURF dotenv - 環境變數設定可以將一些比較機密性的資料(帳號、密碼…等)，設置在環境變數裡，這樣的話，就算我們將專案上傳至github等公共環境，也不會將重要的資訊曝露在外。 安裝 1$ npm install dotenv --save 範例 在專案根目錄新增檔案 .env，並在將機密資料設定於此。 修改後端app.js，機密資料 改取自 dotenv環境變數。 .env檔案12gmailUser = Gmail帳號gmailPass = Gmail密碼 後端.js1234567891011121314151617181920var express = require('express');var router = express.Router();var nodemailer = require('nodemailer'); // Mail模組var csrf = require('csurf'); // 阻擋跨站攻擊(CSURF)+require('dotenv').config(); // 環境變數設定//設定 SMTP 相關資料var transporter = nodemailer.createTransport(&#123; service: 'Gmail', secureConnection: true, // 使用SSL方式（安全方式，防止被竊取信息） auth: &#123;+ // 帳密取自 dotenv環境變數+ user: process.env.gmailUser, // generated ethereal user+ pass: process.env.gmailPass // generated ethereal password &#125;, tls: &#123; // do not fail on invalid certs rejectUnauthorized: false &#125;&#125;); dotenv connect-flash - message的暫存器簡單來說，flash是一個暫存器，而且暫存器裡面的值使用過一次即被清空，這樣的特性很方面用來做網站的提示信息。 安裝 1$ npm install connect-flash --save 範例 注意：flash要配合session使用 後端app.js1234567891011121314var express = require('express');var session = require("express-session");var flash = require('connect-flash'); // message的暫存器var app = express();//使用connect-flash前，需先設定session相關設定，才能使用app.use(session(&#123; secret: 'iamkanboo', resave: true, saveUninitialized: true&#125;));app.use(flash()); // 啟用 message的暫存器(session設定完，才use) 驗證欄位是否有填寫，若有卡控訊息，則紀錄在 flash 內，並傳入 render ，供前端渲染畫面。 後端contact.js1234567891011121314151617181920212223router.get('/', csrfProtection, function (req, res) &#123; res.render('contact', &#123; csrfToken: req.csrfToken(), errors: req.flash('errors') //傳入 卡控訊息 &#125;);&#125;);router.post('/post', csrfProtection, function (req, res) &#123; //欄位卡控 if (req.body.username == '') &#123; console.log('username是空的'); req.flash('errors', 'username是空的'); // 紀錄 卡控訊息 res.redirect('/contact'); return; &#125; /* your code */ //轉址 res.redirect('/contact/review');&#125;); 前端：顯示卡控訊息123456789101112131415161718&lt;form action="/contact/post" method="post"&gt; &lt;input type="hidden" name="_csrf" value="&lt;%= csrfToken %&gt;"&gt;+ &lt;%= errors %&gt; &lt;h1&gt;聯絡我們&lt;/h1&gt; &lt;div&gt; &lt;label for="username"&gt;姓 名：&lt;/label&gt; &lt;input type="text" name="username" id="username"/&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="email"&gt;電子郵件：&lt;/label&gt; &lt;input type="text" name="email" id="email"/&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="submit" value="送出訊息" /&gt; &lt;/div&gt;&lt;/form&gt; express4.0之後使用connect-flash應該注意的問題 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Nodemailer</tag>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS-Cookie、Session]]></title>
    <url>%2F2018%2F01%2F02%2FNodeJS-CookieSession%2F</url>
    <content type="text"><![CDATA[紀錄Cookie、Session的差異，以及如何搭配使用。 COOKIE 與 SESSION 的比較與區別 Cookie-數據存放在客戶的瀏覽器上-用戶端的限制約4K-不存放機密資料，避免被他人解析，故僅存放 session id Session-數據放在伺服器上-session資料是 暫存 前端 Cookie寫入 Cookiedocument.cookie = &quot;myName=tom&quot;; 寫入 Cookie，並加入過期時間，document.cookie=&quot;username=bob; expires=Mon, 04 Dec 2017 08:18:32 GMT; path=/&quot;; GMT 時間new Date().toGMTString() 寫入 Cookie，設定 10 秒後失效document.cookie=&quot;username=bob; max-age=10; path=/&quot;; 後端 讀取Cookie、寫入Cookie安裝語法 1$ npm install cookie-parser --save cookie-parser 範例 app.js引用cookie-parser模組12345var express = require('express')var cookieParser = require('cookie-parser') // 解析cookie模組var app = express()app.use(cookieParser()) //解析前端cookie 「讀取」是用 req(Request) 「寫入」是用 res(Response) routes/index.js1234567891011121314151617181920212223242526var express = require('express');var router = express.Router();router.get('/', function (req, res, next) &#123; // 「讀取」是用 req(Request) // 讀取前端的cookies(全部) console.log(req.cookies); // 讀取前端的cookies(單個) console.log(req.cookies.userName); // 「寫入」是用 res(Response) // 後端寫入前端Cookies res.cookie('name', 'lulu', &#123; maxAge: 10000, // 只存在n秒，n秒後自動消失 httpOnly: true // 僅限後端存取，無法使用前端document.cookie取得 &#125;) res.render('index', &#123;title: 'Express'&#125;);&#125;);module.exports = router; 補充：Response.cookie(寫入) res.cookie(name, value [, options]) 參數： name: 設定cookie的名字 value: 設定其值，可能是字串或是轉成JSON格式的物件。 options: 選項參數是一個物件，所以，其屬性放在{}裡，以逗號分隔。 屬性： domain (字串) 適用此cookie的domain name encode (函式) 用於cookie編碼的同步函式，預設encodeURIComponent. expires (日期) cookie的到期日，超過此日期，即失效。 httpOnly (布林) 標記此cookie只能從web server 訪問，以避免不正確的進入來取得竄改。 maxAge (數字) 設定此cookie的生存時間(毫秒為單位)，比方60000(10分鐘後到期，必須重新訪問) path (字串) 適用此cookie的路徑，預設： “/”. secure (布林) 設定此cookie是否只在https使用。 signed (布林) 此cookie是否要設簽章。(如果是true，必須使用cookie-parser設定簽章 ) 官方-req.cookies(讀取)官方-res.cookie(寫入)Cookie在express上的應用 後端 session 儲存在伺服器的暫存資料，此暫存可放在記憶體或資料庫上 session可在cookie上儲存一筆辨識你是誰的 session id 安裝語法 1$ npm install express-session --save express-session session 常用參數 name：設置cookie中，保存session的字段名稱。(預設：connect.sid) store： session 的存儲方式。(預設：存放在內存(記憶體)中，也可以使用redis，mongodb 等) secret(必要選項)： 通過設置的 secret 字符串，來計算hash值並放在cookie 中，使產生的 signedCookie 防篡改。 genid：產生一個新的 session_id 時，所使用的函數。(預設：使用uid2這個npm包) rolling： 每個請求都重新設置一個cookie。(預設：false) resave： 即使 session 沒有被修改，也保存session 值。(預設：true) saveUninitialized：強制將未初始化的session存回 session store，未初始化的意思是它是新的而且未被修改。(預設：true) cookie： 設置存放 session id 的 cookie 的相關選項。 httpOnly：為設置true時，將不允許的 JavaScript 通過 document.cookie 訪問取得資料。 maxAge： number（毫秒），用於指定Set-Cookie的Expires屬性。設置後，Cookie將在指定時間後失效。 path： 用於指定Set-Cookie的Path屬性。默認會被設置為’/‘，即當前域名的根路徑。 secure： 設置為true時，使用非HTTPS連接時，當客戶端將不會回傳的Cookie。 cookie預設值123456default: &#123; path: '/', httpOnly: true, secure: false, maxAge: null &#125; 範例 當User登入後，伺服器先提供一組session id給你，並紀錄在 客戶的瀏覽器的cookie app.js1234567891011121314var express = require('express')var session = require('express-session')var app = express()//提供一組session idapp.use(session(&#123; secret: 'iamkanboo', // resave: true, saveUninitialized: true, cookie:&#123; maxAge: 100*1000 //100秒後過期 &#125;&#125;)) 表單點擊送出後，會將User資料 post 至後端 html架構12345678910111213&lt;body&gt; &lt;!-- 顯示user資料 --&gt; &lt;h1&gt;&lt;%= userName %&gt; &lt;%= email %&gt;&lt;/h1&gt; &lt;!-- 表單填寫區 --&gt; &lt;form method="post" action="/"&gt; &lt;input type="text" name="username" value=""&gt; &lt;input type="text" name="email" value=""&gt; &lt;input type="submit" value="送出"&gt; &lt;/form&gt;&lt;/body&gt; 前端post資料後，會先將user資料寫入 session暫存，再將網址導回index，並且傳入資料供渲染畫面。 index.js12345678910111213141516171819202122232425var express = require('express');var router = express.Router();/* GET home page. */router.get('/', function(req, res, next) &#123; //將user資料傳入index.ejs供渲染畫面 res.render('index', &#123; userName: req.session.username, email: req.session.email &#125;);&#125;);//接收前端傳入的資料router.post('/',function(req,res)&#123; //取得前端資料，並寫入至後端session暫存 req.session.username = req.body.username; req.session.email = req.body.email; //轉址至首頁 res.redirect('/');&#125;)module.exports = router; session 在 express 上的應用 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS-Express+Firebase]]></title>
    <url>%2F2018%2F01%2F01%2FNodeJS-Express-Firebase%2F</url>
    <content type="text"><![CDATA[紀錄如何使用 express + Firebase 設計 RESTful API Todoist 取得Firebase Admin SDK 開啟 專案設定 → 服務帳號 設定方法 安裝NPM npm install firebase-admin --save 複製Admin SDK 設定程式碼片段，貼至 app.js 下載Firebase金鑰(json檔案)，並修改Firebase金鑰路徑 完成設定 once、set 讀取、寫入雖然之前介紹firebase讀取的方式有 once、on 二種，不過在後端的話，只能使用 once 方式，因為 on 在後端並不會有同步更新的效果。 讀取 once12345var fireData = admin.database(); //取得Firebase的databasefireData.ref('todos').once('value', function (snapshot) &#123; console.log(snapshot.val());&#125;) 寫入方式一樣可以使用 set、push 二種。 寫入 set、push123456789var fireData = admin.database(); //取得Firebase的database// 寫法1fireData.ref('todos').set(&#123;title: '待辦清單'&#125;)// 寫法2fireData.ref('todos').push(&#123; content: '要去看電影'&#125;) then 設計思維將資料新增至firebase後，可用 then 接著查看firebase的資料是否有成功新增。 12345678910var fireData = admin.database(); //取得Firebase的database//將資料新增至firebase後，可用 then 接著查看firebase的資料是否有成功新增。fireData.ref('todos').push(&#123;content: '要去看電影'&#125;).then(function () &#123; //讀取todos，查看資料是否有寫入？ fireData.ref('todos').once('value', function (snapshot) &#123; console.log(snapshot.val()); &#125;)&#125;) EJS 整合 Firebase用 todolist 為例，說明如何將firebase上的待辦事項與後端整合，並呈現於網頁上。 範例 firebase資料 取得Firebase的todos資料，並將資料傳入index。 res.render 要放進 firebase function裡面，因為是用AJAX取得資料，所以要確保取得資料後，才進行傳遞參數的動作。 app.js1234567891011121314var fireData = admin.database(); //取得Firebase的database//路由app.get('/', function (req, res) &#123; fireData.ref('todos').once('value', function (snapshot) &#123; // console.log(snapshot.val()); var data = snapshot.val(); //render 要放進firebase function裡面，因為是用AJAX取得資料，所以要確保取得資料後，才進行傳遞參數的動作。 res.render('index', &#123; "todolist": data &#125;); &#125;)&#125;) 取得傳入的資料 todolist，使用ejs的forloop寫法，將資料渲染成HTML。 index.ejs12345678910111213&lt;h1&gt;待辦清單&lt;/h1&gt;&lt;input type="text" id="content" value=""&gt;&lt;input type="submit" id="send" value="送出"&gt;&lt;ul id="list"&gt; &lt;!-- forloop寫法 --&gt; &lt;% for(item in todolist)&#123; %&gt; &lt;li&gt; &lt;%- todolist[item].content %&gt; &lt;input type="button" data-id="&lt;%- item %&gt;" name="" value="刪除"&gt; &lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt; 新增資料API前端畫面輸入 待辦事項 後，點擊 送出 按鈕，此時會將資料 post 給 addTodo 路由，後端處理完後，再將結果傳送給前端更新畫面。 範例 後端app.js1234567891011121314151617181920var fireData = admin.database(); //取得Firebase的database// 新增邏輯app.post('/addTodo', function (req, res) &#123; var content = req.body.content; // 取得前端的content欄位資料 var contentRef = fireData.ref('todos').push(); //先設定寫入的方法為push // 當資料寫入成功後，並使用 then 回傳資料，送至前端渲染畫面 contentRef.set(&#123;"content": content&#125;).then(function () &#123; fireData.ref('todos').once('value', function (snapshot) &#123; // console.log(snapshot.val()); res.send(&#123; "succes": true, "result": snapshot.val(), //todos的資料 "message": "資料新增成功" &#125;); &#125;) &#125;)&#125;) 官方：先設定push的寫法 HTML架構1234567891011121314151617&lt;body&gt; &lt;h1&gt;待辦清單&lt;/h1&gt; &lt;input type="text" id="content" value=""&gt; &lt;input type="submit" id="send" value="送出"&gt; &lt;ul id="list"&gt; &lt;!-- forloop寫法 --&gt; &lt;% for(item in todolist)&#123; %&gt; &lt;li&gt; &lt;%- todolist[item].content %&gt; &lt;input type="button" data-id="&lt;%- item %&gt;" name="" value="刪除"&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;script src="/js/all.js"&gt;&lt;/script&gt;&lt;/body&gt; 前端all.js123456789101112131415161718192021222324252627282930313233343536373839404142434445var send = document.querySelector('#send');var content = document.querySelector('#content');var list = document.querySelector('#list');//新增APIsend.addEventListener('click', function (e) &#123; e.preventDefault(); var xhr = new XMLHttpRequest(); xhr.open('post', '/addTodo'); // 新增資料API xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8'); //取得輸入 待辦事項 var str = content.value; content.value = ""; var todo = JSON.stringify(&#123;"content": str&#125;); // 轉換成字串 xhr.send(todo); //AJAX回傳後的結果 xhr.onload = function () &#123; var originData = JSON.parse(xhr.responseText); // console.log(originData); //重載todoList reloadList(originData); &#125;&#125;)//Reload todoListfunction reloadList(originData) &#123; if (originData.success === false) &#123; alert(originData.message); return; &#125; var data = originData.result; var str = ''; for (item in data) &#123; str += '&lt;li&gt;' + data[item].content + '&lt;input type="button" data-id="' + item + '" name="" value="刪除"&gt;' + '&lt;/li&gt;' &#125; list.innerHTML = str;&#125; 刪除資料API前端點擊 刪除 按鈕，此時會將刪除按鈕的 data-id 資料 post 給 removeTodo 路由，後端處理完後，再將結果傳送給前端更新畫面。 範例 後端app.js12345678910111213141516// 刪除邏輯app.post("/removeTodo", function (req, res) &#123; var _id = req.body.id; // 取得刪除按鈕的 data-id //刪除todos的資料成功後，並使用 then 回傳資料，送至前端渲染畫面 fireData.ref('todos').child(_id).remove().then(function () &#123; fireData.ref('todos').once('value', function (snapshot) &#123; // console.log(snapshot.val()); res.send(&#123; "succes": true, "result": snapshot.val(), "message": "資料刪除成功" &#125;); &#125;) &#125;)&#125;) 在每一個的INPUT(刪除按鈕)上，新增data-id屬性，紀錄firebase的Key值。 HTML架構1234567891011121314151617&lt;body&gt; &lt;h1&gt;待辦清單&lt;/h1&gt; &lt;input type="text" id="content" value=""&gt; &lt;input type="submit" id="send" value="送出"&gt; &lt;ul id="list"&gt; &lt;!-- forloop寫法 --&gt; &lt;% for(item in todolist)&#123; %&gt; &lt;li&gt; &lt;%- todolist[item].content %&gt; &lt;input type="button" data-id="&lt;%- item %&gt;" name="" value="刪除"&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;script src="/js/all.js"&gt;&lt;/script&gt;&lt;/body&gt; 下例 前端all.js ，是針對 ul 進行監聽，進而判斷點擊的元素是否為INPUT(刪除按鈕)，這樣就不用針對 n個的刪除按鈕 建立監聽事件，以達到優化的效果。 前端all.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var send = document.querySelector('#send');var content = document.querySelector('#content');var list = document.querySelector('#list');//刪除APIlist.addEventListener('click', function (e) &#123; //判斷元素是否為 INPUT(刪除按鈕) if (e.target.nodeName !== "INPUT") &#123; return; &#125; var xhr = new XMLHttpRequest(); xhr.open('post', '/removeTodo'); // 刪除API xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8'); //取得輸入 data-id 資料 var id = e.target.dataset.id; var todo = JSON.stringify(&#123;"id": id&#125;); // 轉成字串 xhr.send(todo); //AJAX回傳後的結果 xhr.onload = function () &#123; var originData = JSON.parse(xhr.responseText); // console.log(originData); //重載todoList reloadList(originData); &#125;&#125;)//Reload todoListfunction reloadList(originData) &#123; if (originData.success === false) &#123; alert(originData.message); return; &#125; var data = originData.result; var str = ''; for (item in data) &#123; str += '&lt;li&gt;' + data[item].content + '&lt;input type="button" data-id="' + item + '" name="" value="刪除"&gt;' + '&lt;/li&gt;' &#125; list.innerHTML = str;&#125; 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Firebase</tag>
        <tag>Express</tag>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-基礎用法]]></title>
    <url>%2F2017%2F12%2F30%2FJS-studynotes%2F</url>
    <content type="text"><![CDATA[Selector - 選擇元素 element = document.querySelector(selectors); element 是元素物件。 selectors 是以逗號分隔，包含一個或多個 CSS 選擇器的字串。 選擇單一元素 querySelector12//回傳第一個符合條件的元素var el = document.querySelector('#titleId'); 選擇多個元素 querySelectorAll12//回傳符合條件的元素var el = document.querySelectorAll('.titleClass'); Attribute - 增加標籤屬性 setAttribute 設定 設定 標籤屬性12var el = document.querySelector('.titleClass a');el.setAttribute('href','http://www.yahoo.com.tw'); getAttribute 取得 取得 標籤屬性12var el3 = document.querySelector('.titleClass a').getAttribute('href');console.log(el3); innerHTML - 插入HTML將元素內的html重新覆蓋寫入新的html。 插入HTML123var el = document.getElementById('main');var str = '&lt;h1 class="blue"&gt;1234&lt;/h1&gt;'el.innerHTML = str; createElement - 插入dom元素建立一個新的DOM元素，然後再使用 appendChild 新增子節點，並不會覆蓋原有的DOM元素。 新增dom元素1234567891011121314&lt;h1 class="title"&gt; &lt;em&gt;titile&lt;/em&gt;&lt;/h1&gt;&lt;script &gt; // 建立元素 var sonElement = document.createElement("a"); sonElement.setAttribute('href','www.facebook.com'); sonElement.textContent = '前往Facebook'; // 增加子節點 var fatherElement = document.querySelector('.title'); fatherElement.appendChild(sonElement);&lt;/script&gt; 更新後結果1234&lt;h1 class="title"&gt; &lt;em&gt;titile&lt;/em&gt;+ &lt;a href="www.facebook.com"&gt;前往Facebook&lt;/a&gt;&lt;/h1&gt; 使用 appendChild 要注意的小細節：要留意的是 如果 appendChild 使用時，append 上去的是一個已存在的 node 時，它會做的是搬移，而非複製，所以 appendChild 使用時要複製而非搬移，記得先使用 Node.cloneNode() 這個方法複製 Node Element。參考：PJ - Node Element 在 appendChild 後消失（disappear）!? addEventListener - 事件氣泡、事件捕捉基本語法 element.addEventListener(event, function, useCapture) 第三個參數：可省略，預設為 false。 範例 可試試將第三個參數分別改成 true 、 false，各執行一次，會有什麼不一樣的結果。 html123&lt;div class="warp"&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/div&gt; 預設：事件氣泡-從指定元素往外找12345678910111213var el = document.querySelector('.box');el.addEventListener('click',function()&#123; alert('box'); console.log('box');&#125;,false);var elBody = document.querySelector('.body');elBody.addEventListener('click',function()&#123; alert('body'); console.log('body');&#125;,false);// false (事件氣泡 - event Bubbling) - 從指定元素往外找// true (事件捕捉 - event capturing) - 從最外面找到指定元素 See the Pen addEventListener - 事件氣泡、事件捕捉 by Kanboo (@Kanboo) on CodePen. stopPropagation - 中止冒泡行為依上例 addEventListener-事件氣泡 因素，有時只是想單純針對單一元素監聽，不想因為事件冒泡的行為，而去觸發到其他元素，這時就可利用 stopPropagation 來達成此需求。 123456var el = document.querySelector('.box');el.addEventListener('click',function(e)&#123;+ e.stopPropagation(); // 中止冒泡行為 alert('box'); console.log('box');&#125;,false); 事件監聽優化 &amp; e.target有時子元素可能要上千個，每個都要綁上監聽的話，效能不是很優，這時可從父節點下手，使用 e.target.nodeName 判斷是否為 想監聽的子元素，若是為想監聽的子元素，可再用 e.target.value 或是 e.target.textContent 取得 值。 e.target.nodeName 取得點擊元素的標籤名稱，如：UL、LI、INPUT… e.target.value 取得選取元素的值 範例 當有一個 ul 底下有多個 li 都要監聽的話，這時我們可以利用 addEventListener-事件氣泡 的原理，只要針對 ul 監聽，讓他往上冒泡，當到達 li 時，這時我們就可以針對 li 做事了。 原始寫法1234567891011//取得ul底下的所有li元素var list = document.querySelectorAll('.list li');//forloop，將每個li元素綁上監聽事件(N次)var len = list.length;for(var i = 0;len&gt;i;i++)&#123; list[i].addEventListener('click',checkName,false)&#125;function checkName(e)&#123; console.log(e.target.textContent);&#125; 優化寫法123456789//取得ul元素var list = document.querySelector('.list');//將ul元素綁上監事件(一次)list.addEventListener('click',checkName,false)function checkName(e)&#123; if(e.target.nodeName !== 'LI')&#123;return&#125;; // 判斷是否為li元素 console.log(e.target.textContent);&#125; preventDefault - 取消預設觸發行為比較常用在 a連結的href、Form表單的submit 上，有時可能只是想觸發呼叫Function，而不想使用到原生附與的功能的話，就可利用 preventDefault 達成此需求。 取消預設觸發行為123456var list = document.querySelector('a');list.addEventListener('click',function(e)&#123; e.preventDefault(); //取消預設觸發行為 /* 撰寫你的Code */&#125;) localStorage - 灠瀏器資料儲存基本語法 儲存1localStorage.setItem('countryItem',countryString); 讀取1localStorage.getItem('countryItem'); 範例 localstorage 只能保存 string 資料，所以當資料非字串型態的話，記得轉為字串string。 JSON.stringify() 將 array 轉為 stringJSON.parse() 將 string 轉為 array 1234567891011121314var country = [ &#123;farmer:'王農夫'&#125;];//儲存var countryString= JSON.stringify(country); // 轉字串console.log(countryString);localStorage.setItem('countryItem',countryString);//讀取var getData = localStorage.getItem('countryItem');var getDataAry = JSON.parse(getData); // 轉arrayconsole.log(getDataAry[0].farmer); 補充小知識var data = listData;var data2 = listData || []; //(建議寫法)console.log(‘沒有 []’, data); // 有可能取得資料或 undefinedconsole.log(‘加上 []’, data2); // 有可能 data-* - 透過 dataset 讀取自訂資料 名字絕對不能以 xml 起頭，無論是否用於 xml、 名字絕對不能包含分號（U+003A）、 名字絕對不能包含大寫 A 到大小 Z 的拉丁字母。 可透過 HTMLElement.dataset.testValue 或 HTMLElement.dataset[“testValue”] 訪問 1234567891011121314&lt;div id="user" data-id="1234567890" data-user="johndoe" data-date-of-birth&gt;John Doe&lt;/div&gt;let el = document.querySelector('#user');// el.id == 'user'// el.dataset.id === '1234567890'// el.dataset.user === 'johndoe'// el.dataset.dateOfBirth === ''el.dataset.dateOfBirth = '1960-10-03'; // set the DOB.// 'someDataAttr' in el.dataset === falseel.dataset.someDataAttr = 'mydata';// 'someDataAttr' in el.dataset === true AjAX屬性 readyState: ０：尚未讀取 １：讀取中 ２：已下載完畢 ３：資訊交換中 ４：處理完畢 Status:即HTTP協定的狀態碼 當 readyState == 4，代表有執行完成，但不一定是有正確撈到資料，要配合HTTP status == 200，才代表是正確撈到資料。 範例 利用AJAX傳送(POST)帳號、密碼資料至後端註冊會員帳號。 POST資料123456789101112131415161718192021222324252627282930313233343536373839var send = document.querySelector('.send');send.addEventListener('click',signup,false);function signup()&#123; var emailStr = document.querySelector('.account').value; var passwordStr = document.querySelector('.password').value; //資料丟到物件 var account = &#123;&#125;; account.email = emailStr; account.password = passwordStr; var xhr = new XMLHttpRequest(); xhr.open('post','https://hexschool-tutorial.herokuapp.com/api/signup',true); xhr.setRequestHeader('Content-type','application/json'); //宣告json格式 var data = JSON.stringify(account); //轉成字串 xhr.send(data); // 送出 //ajax完成後，執行此event xhr.onload = function()&#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // 萬事具備 var callbackData = JSON.parse(xhr.responseText); //接收回傳後資料 console.log(callbackData); var veriStr = callbackData.message; if(veriStr =="帳號註冊成功")&#123; alert('帳號註冊成功！！'); &#125;else&#123; alert("帳號註冊失敗！"); &#125; &#125; else &#123; // 似乎有點問題。 // 或許伺服器傳回了 404（查無此頁） // 或者 500（內部錯誤）什麼的。 alert ("伺服器處理錯誤"); &#125; &#125;&#125; ajax回傳的格式12345&#123; "success": true, "result": &#123;'結果'&#125;, "message": "登入成功"&#125; Asynchronous JavaScript And XML]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS-Express]]></title>
    <url>%2F2017%2F12%2F27%2FNodeJS-Express%2F</url>
    <content type="text"><![CDATA[基本語法下列語法為 express 的起手式，後面會慢慢新增功能。 後端app.js123456789101112131415161718192021var express = require('express'); //引用express模組var app = express();/* app.get參數說明 req 是 Request 物件，存放這此請求的所有資訊res 是 Response 物件，用來回應該請求*/// 路由 routeapp.get('/',function(req,res)&#123; // res.send('1234'); res.send('&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hi!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;')&#125;)// 監聽 portvar port = process.env.PORT || 3000;app.listen(port); //執行 node app.js//網頁連結 http://127.0.0.1:3000/ params - 取得指定路徑透過 :name 這個變數，再配合 req.params 搭配使用，可取得路由的值。 PS：設定為變數的重點為前面加個冒號。 後端app.js1234567891011121314//http://127.0.0.1:3000/user/kanbooapp.get('/user/:name', function (req, res) &#123; console.log(req.params); var myName = req.params.name; console.log(myName); if ( myName !== 'kanboo')&#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;'+'查無此人'+'&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'); &#125;else&#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;'+myName+'&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'); &#125;&#125;) 下列範例為可設多個變數(:name、:data)，取得路由的值。 後端app.js12345678910//http://127.0.0.1:3000/user/kanboo/abcdapp.get('/user/:name/:data', function (req, res) &#123; console.log(req.params); var myName = req.params.name; // kanboo var myData = req.params.data; // abcd console.log(myName,myData); res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + myName + '&lt;br&gt;' + myData + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;) query - 取得網址參數以 http://127.0.0.1:3000/user/kanboo?limit=100&amp;q=張惠妹 這段網址為例，我要用從?(問號)切開，前段網址：http://127.0.0.1:3000/user/kanboo後段網址：limit=100&amp;q=張惠妹 要取得前段網址的資料可用 params ，若要取後段網址的資料就要用 query。 下列示範利用 req.query 取得 後段 網址的參數 後端app.js12345678910111213141516171819202122//網址：http://127.0.0.1:3000/user/kanboo?limit=100&amp;q=張惠妹app.get('/user/:name', function (req, res) &#123; console.log(req.params); console.log(req.query); var myName = req.params.name; var limit = req.query.limit; // limit = 100 var q = req.query.q; //q = 張惠妹 console.log(myName); console.log(limit); console.log(q); res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + 'myName:' + myName + '&lt;br&gt;' + '搜尋:' + q + '&lt;br&gt;' + '筆數：' + limit + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//http://127.0.0.1:3000/user/kanboo?limit=100&amp;q=張惠妹 Middleware - 中介層簡單來說，Middleware的功能就有點像卡控機制，例如：我要進去會員頁面時，Middleware可以幫我先確認是否已登入，再看要不要放行？ 範例 當我網址要切換至 http://127.0.0.1:3000/user 頁面時，此時可利用 app.use 先確認是否已登入，再決定是否使用 next() 放行，可讀取到 app.get。 後端app.js12345678910111213141516171819202122232425262728293031//網址：http://127.0.0.1:3000/user/* app.use參數說明 req 是 Request 物件，存放這此請求的所有資訊res 是 Response 物件，用來回應該請求next 用來控制流程，是否可繼續執行*/app.use(function (req, res, next) &#123; //這裡可以撰寫 驗證的Code var isVerification = true; if (isVerification === true) &#123; console.log('驗證成功!!'); next(); &#125;&#125;)/* 注意：使用 app.use 的話，要放在 app.get 的前面，否則就沒有作用！*/app.get('/user', function (req, res) &#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + 'user' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//http://127.0.0.1:3000/user 注意：使用 app.use 的話，要放在 app.get 的前面，否則就沒有作用！ Middleware - 404頁面假設user開到一個錯誤的網址 http://127.0.0.1:3000/alskdjlasdjf，而根本無此網頁的話，這時會客制一個404頁面回應給user知道無此網頁。 範例 利用 res.status(404) 判斷當無此頁面時，回應 抱歉，你的頁面找不到 的訊息給User知道。 後端app.js123456789// 網址：http://127.0.0.1:3000/alskdjlasdjf// 404頁面 app.use(function (req, res, next) &#123; res.status(404).send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + '抱歉，你的頁面找不到' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//http://127.0.0.1:3000/alskdjlasdjf Middleware - 錯誤頁面另一種情形是當user要進入某個頁面時，有可能是程式碼執行有誤，這時我們可以先將畫面切換至一個客制的錯誤頁面，告知User待修復，稍後嘗試。 範例 程式碼執行 cc() 這個Function出錯了，這時利用 app.use 的新參數 err ,接收程式碼的錯誤訊息，並回應User系統有誤待修復。 後端app.js12345678910111213141516// 錯誤程式碼的狀況app.use(function (req, res, next) &#123; cc(); // 執行不存在的Function next(); // 放人通行..&#125;)// 錯誤頁面 app.use(function (err, req, res, next) &#123; console.log(err.stack); res.status(500).send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + '程式有些問題，請稍後嘗試。' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;) Middleware - 中介function呼叫假設我們有很多頁面要進入時，都需要先確認user是否已登入，才能進入頁面的話，這時我們可以將 確認登入程式碼(isLogin) 包成一個 Function，然後在 app.get 插入 isLogin 進行確認。 範例 下列重點為 isLogin 插入的位置，app.get(‘/‘, isLogin, function (req, res){ 程式碼 }) 後端app.js12345678910111213141516171819202122232425262728293031323334353637383940var isLogin = function (req, res, next) &#123; //這裡可以撰寫 驗證的Code var _url = req.url; console.log(_url); console.log(_url !== '/'); if (_url === '/') &#123; console.log('登入成功!!'); next(); &#125; else &#123; console.log('登入失敗!!'); res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + '登入失敗' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'); &#125;&#125;// 開啟頁面前，先驗證 isLogin 是否成功app.get('/', isLogin, function (req, res) &#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + 'Hello' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)// 開啟頁面前，先驗證 isLogin 是否成功app.get('/user', isLogin, function (req, res) &#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + 'Hello' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//http://127.0.0.1:3000///http://127.0.0.1:3000/user static - 載入靜態檔案若我們在頁面需要提供「圖片、txt檔…」等檔案，如下列範例需使用到 img圖檔，我們要先利用 express.static 指定我們的目錄起點在哪，這樣img圖檔的路徑才能使用相對路徑取得資源。 範例 後端app.js12345678910111213141516171819202122var express = require('express');var app = express();//增加靜態檔案的路徑app.use(express.static('public')); // 設定 目錄起點位置app.get('/', function (req, res) &#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + '&lt;img src="/img/logo.png" &gt;'+ 'Hello' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//監聽portvar port = process.env.PORT || 3000;console.log(port);app.listen(port);//執行 node app.js//網頁連結 http://127.0.0.1:3000/ 示意圖 EJS - 樣板語言安裝語法1$ npm install ejs-locals --save 使用方法 宣告 樣板語言 使用 res.render 讀取哪個ejs檔案，如：res.render(‘index‘) 後端app.js1234567891011121314151617var express = require('express');var app = express();//增加靜態檔案的路徑app.use(express.static('public')); // 設定 目錄起點位置//宣告 樣板語言var engine = require('ejs-locals');app.engine('ejs',engine);app.set('views','./views'); // 設定「樣板程式碼」放在哪裡app.set('view engine','ejs'); // 設定「樣板語言」是用哪種？ejs、pug、handlebarsapp.get('/', function (req, res) &#123; res.render('index'); //渲染 index.ejs 的檔案&#125;)//http://127.0.0.1:3000/ 示意圖 EJS - 參數導入除了一般將.ejs檔案渲染成HTML外，有時也會因為條件的不同，要渲染出不一樣的HTML格式，這時就可以透過參數的傳遞，來達成此需求。 範例 下列範例示範 res.render，如何傳送參數以及ejs接收參數的寫法 傳送 參數12345678910app.get('/', function (req, res) &#123; res.render('index', &#123; 'title': '我是傳入的值', 'dog': '狗狗', 'html': '&lt;h1&gt;我是HTML&lt;/h1&gt;', 'show': true, 'course': ['html','js','css'], &#125;);&#125;)//http://127.0.0.1:3000/ ejs接收參數的寫法123456789101112131415161718192021222324&lt;!-- = 是 渲染成字串- 是 渲染成HTML--&gt;&lt;%= html %&gt;=&gt; &lt;h1&gt;我是HTML&lt;/h1&gt;&lt;%- html %&gt;=&gt; 我是HTML&lt;!-- if寫法 --&gt;&lt;% if(show)&#123; %&gt;&lt;h1&gt;條件成立，顯示222!!&lt;/h1&gt;&lt;% &#125; %&gt;&lt;!-- forloop寫法 --&gt;&lt;ul&gt; &lt;% for(var i=0;course.length&gt;i;i++)&#123; %&gt; &lt;li&gt; &lt;%- course[i] %&gt; &lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt; EJS - 設定layout當有很多頁面都有用到共同的元素(如：表頭、表尾…等)，這時我們可以將會一直重覆的區塊取出，撰寫在 layout.ejs，若有其他頁面需要表頭、表尾的部份，我只要將layout.ejs include在頁面即可。 範例 layout.ejs 將共用的部份撰寫在 layout.ejs 新增 &lt;%- body %&gt; 這段語法，代表要放置不同頁面各自的內容。 layout.ejs1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; 表頭共用的部份(logo、navbar...等) &lt;/header&gt; &lt;%- body %&gt; &lt;footer&gt; 表尾共用的部份(作者、版權信息或者相關鏈接...等) &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; search.ejs 在頁面寫入 &lt;% layout(&#39;layout&#39;) %&gt; 這段語法，代表載入共用HTML部份。 接著開始撰寫HTML內容，而撰寫好的HTML，就會放置在layout.ejs檔案裡的&lt;%- body %&gt;位置。 search.ejs搜尋頁面12345678910&lt;!-- 共用元素 --&gt;&lt;% layout('layout') %&gt;&lt;!-- 表單內容 --&gt;&lt;form action="/searchList" method="post" &gt; &lt;input type="text" name="content" id="content" value=""&gt; &lt;input type="submit" id="send" value="送出"&gt;&lt;/form&gt;&lt;script src="/js/all.js"&gt;&lt;/script&gt; body-parser - 取得表單資料(傳統表單)安裝語法 1$ npm install body-parser --save 範例 在search搜尋頁面的 searchText 輸入搜尋文字後，點擊送出按鈕 此時會將表單資料傳送(post)給/searchList 再透過後端 req.body 取得到表單資料，進行後續解析。 search搜尋頁面123456789&lt;form action="/searchList" method="post" &gt; &lt;input type="text" name="searchText" value=""&gt; &lt;input type="submit" value="送出"&gt; &lt;!-- 只有id的話，body-parser無法解析 --&gt; &lt;!-- &lt;input type="text" id="idflied" value=""&gt; --&gt;&lt;/form&gt; 後端app.js123456789101112131415161718192021222324var bodyParser = require('body-parser');// 增加 body 解析app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false&#125;))//搜尋頁面app.get('/search', function (req, res) &#123; res.render('search');&#125;)//http://127.0.0.1:3000/search//傳統表單app.post('/searchList', function (req, res) &#123; //所有body欄位資料 console.log(req.body); //取得某欄位資料 console.log(req.body.searchText); //轉址 res.redirect('search'); // 將畫面導回搜尋頁面&#125;) 搜尋頁面(search) 是使用 app.get接收表單頁面(searchList) 是使用 app.post在searchList處理完資料後，最後記得將畫面導回搜尋畫面 res.redirect(‘search’); body-parser - 取得表單資料(AJAX)若達到頁面不跳轉，就可回應相關訊息，此時就需要透過AJAX的方式，達到此需求。 範例 新增一路由 searchAJAX，用來處理搜尋的相關資料，最後回傳給前端。 後端app.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var express = require('express');var app = express();var bodyParser = require('body-parser');//增加靜態檔案的路徑app.use(express.static('public'));//宣告 樣板語言var engine = require('ejs-locals');app.engine('ejs', engine);app.set('views', './views'); // 樣板放在哪裡？app.set('view engine', 'ejs'); // 宣告樣板是用哪種語言？ejs、pug、handlebars// 增加 body 解析app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false&#125;))//搜尋頁面app.get('/search', function (req, res) &#123; res.render('search');&#125;)//http://127.0.0.1:3000/search//AJAXapp.post('/searchAJAX', function (req, res) &#123; //所有body欄位資料 console.log(req.body); console.log(req.body.list[1]); /* 這裡撰寫程式碼 */ //回傳結果 res.send('Hello!');&#125;)//監聽portvar port = process.env.PORT || 3000;console.log(port);app.listen(port);//執行 node app.js//網頁連結 http://127.0.0.1:3000/ 重點在於我們將原本在搜尋頁面的 send按鈕 要Submit的動作取消 e.preventDefault();，改用 AJAX 方式，將表單的內容資料，利用 post 給 searchAJAX。 前端all.js123456789101112131415161718192021222324252627282930313233var send = document.querySelector('#send');var content = document.querySelector('#content');send.addEventListener('click', function (e) &#123; e.preventDefault(); var str = content.value; console.log(str); var xhr = new XMLHttpRequest(); xhr.open('post', '/searchAJAX'); //發送給哪個路由 //組合表單資料(文字型態) // xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); // var data = 'content=' + str; // content=123&amp;title=abc //組合表單資料(json型態) xhr.setRequestHeader("Content-type", "application/json"); var searchlist = &#123; "content": str, "list": [1, 2, 3] &#125;; var data = JSON.stringify(searchlist); //轉成字串 //發送表單資料給後端app.js處理 xhr.send(data); //取得後端app.js回傳的資料 xhr.onload = function () &#123; console.log(xhr.responseText); &#125;&#125;) Router - 進階設定當我們網站有越來越多頁面的話，不可能把所有網頁的路由判斷在寫app.js裡，這樣會造成程式碼雜亂，導致後續維護不便，所以我們可以將同類型頁面分別包裝在不同js檔裡，並且使用 module(模組) 輸出，可供 app.js 分別載入，以達到程式碼的簡潔易懂。 範例 app.js 分別載入 user模組(個人資料)、cart模組(購物車) ，讓整個app.js變得簡潔易懂。 後端app.js1234567891011121314151617181920var express = require('express');var user = require('./routes/user.js') // 載入 user模組(個人資料)var user = require('./routes/cart.js') // 載入 cart模組(購物車)var app = express();//網址若為 http://127.0.0.1:3000/user/... 之類的話，就會進去user模組執行。app.use('/user',user);//網址若為 http://127.0.0.1:3000/cart/... 之類的話，就會進去cart模組執行。app.use('/cart',cart);//監聽portvar port = process.env.PORT || 3000;app.listen(port);//執行 node app.js//網頁連結 http://127.0.0.1:3000/ 以user模組(個人資料)為例，因外部引用此模組，語法設定為 app.use(‘/user‘,user);所以網址起頭從 http://127.0.0.1:3000//user/ 開始 user.js12345678910111213141516171819202122232425262728293031var express = require('express');var router = express.Router(); // 路由器//因外部引用此模組，語法為 app.use('/user',user);//所以網址起頭從 http://127.0.0.1:3000/user/ 開始router.get('/edit-porfile', function (req, res) &#123; //若網址為 http://127.0.0.1:3000/user/edit-porfile 進行此function console.log('porfile頁面'); res.send('porfile');&#125;)router.get('/photo', function (req, res) &#123; //若網址為 http://127.0.0.1:3000/user/photo 進行此function console.log('photo頁面'); res.send('photo');&#125;)router.get('/card', function (req, res) &#123; //若網址為 http://127.0.0.1:3000/user/card 進行此function console.log('card頁面'); res.send('card');&#125;)/* 原先都是使用 app.get ，要改用成 router.get*/module.exports = router; 注意 user.js，原先都是使用 app.get ，要改用成 router.get express-generator - 應用程式產生器經過上述種種的介紹，了解express各種的使用方式後，之後我們可以利用 Express應用程式產生器 ，自動幫我們生成一個專案的基本架構，就無須從頭到尾慢慢建構。 安裝語法 1$ npm install express-generator -g 建立語法 建立 express 專案資料 1$ express -e project 切換至專案目錄，並安裝 NPM 套件 12$ cd project$ npm install 運行專案 1$ npm start 專案網址：http://127.0.0.1:3000/ 專案初始化 下列為 專案初始化 之程式碼，後面可在依據需求新增其他功能模組，如：express-session、nodemailer(寄信)、csurf(阻擋跨站攻擊)、connect-flash(message暫存器)、dotenv(環境變數設定)、firebase-admin(資料庫)…等 後端app.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var express = require('express');var path = require('path'); // 抓取目錄路徑var favicon = require('serve-favicon'); // 設定iconvar logger = require('morgan'); // 日誌var cookieParser = require('cookie-parser'); // 解析前端cookievar bodyParser = require('body-parser'); // 取得前端表單資料// 自行撰寫頁面部份var index = require('./routes/index'); // 載入 index模組(首頁)var users = require('./routes/users'); // 載入 user模組(個人資料)var app = express();// view engine setup - 樣版語言設定app.set('views', path.join(__dirname, 'views'));app.set('view engine', 'ejs');// uncomment after placing your favicon in /public//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico'))); // 設定icon的路徑app.use(logger('dev'));app.use(bodyParser.json()); // 解析表單資料-jsonapp.use(bodyParser.urlencoded(&#123; extended: false &#125;)); // 解析表單資料-URL-encoded格式app.use(cookieParser()); // 解析前端cookieapp.use(express.static(path.join(__dirname, 'public'))); // 設定 靜態檔案的目錄起點位置// 路由區塊----Startapp.use('/', index); //網址若為 http://127.0.0.1:3000/... ，就會進去 index模組 執行。app.use('/users', users); //網址若為 http://127.0.0.1:3000/user/...，就會進去 user模組 執行。// 路由區塊----End// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; var err = new Error('Not Found'); err.status = 404; next(err);&#125;);// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render('error');&#125;);module.exports = app; 官方：Express應用程式產生器 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Firebase-基礎用法]]></title>
    <url>%2F2017%2F12%2F26%2FFirebase-studynotes%2F</url>
    <content type="text"><![CDATA[ref(路徑)、set(新增)ref()：尋找資料庫路徑(預設：根目錄)set()：新增資料(寫入方式：覆蓋) 新增資料：範例11firebase.database().ref().set('hi'); 結果 新增資料：範例2(物件)1234567891011121314// firebase 全部物件格式，不能陣列內容// 一個班級有兩個學生var school = &#123; student1: &#123; name: 'tom', num: '1' &#125;, student2: &#123; name: 'john', num: '2' &#125;&#125;firebase.database().ref().set(school); 結果 補充 延續範例2，若要再新增 student3 的話，因為 set 寫入的方式是 覆蓋，所以要注意 ref 是否有指定到正確的新增位置，不然有可能會覆蓋到原來的資料。 新增student31234567var student3= &#123; name: 'kanboo', num: '3'&#125;// ref 要先指定到 新增的路徑firebase.database().ref('student3').set(student3); 新增資料：範例3(階層式)123456//寫入資料firebase.database().ref('myName').set('kanboo');firebase.database().ref('yourName').set('alice');firebase.database().ref('allName/name01').set('aa');firebase.database().ref('allName/name02').set('bb');firebase.database().ref('allName/nameList/name01').set('cc'); 結果 once、on 讀取資料 once(讀取一次資料庫的資料) 僅向firebase取得一次性資料，所以當firebase資料有異動，需要再一次呼叫，才會取得更新後的資料。 123456var myNameRef = firebase.database().ref('allName/nameList/name01');// 快照myNameRef.once('value', function (snapshot) &#123; console.log(snapshot.val()); document.getElementById('title').textContent = snapshot.val();&#125;) on(隨時監聽) 當firebase資料有異動時，會即時回傳更新資料。 123456var myNameRef = firebase.database().ref('allName/nameList/name01');//on 隨時監聽myNameRef.on('value', function (snapshot) &#123; console.log(snapshot.val()); document.getElementById('title').textContent = snapshot.val();&#125;) push - 新增資料以 Todolist 為例，因為資料隨時會新增，不可能一次就能把所有資料打齊上傳至database，所以就需要借用 push 功能，將 新資料 加在 現有資料 裡。 Todolist：新增待辦123var todos = firebase.database().ref('todos');todos.push(&#123;content:'要去看電影'&#125;);todos.push(&#123;content:'要去看跑步'&#125;); 結果 push 會自動給一個亂數編號，如果不想產生隨機編號的話，就使用set方式。set 可以給固定的編號，但要注意新增的位置是否指定正確，要小心覆蓋掉已有的資料。 child 子路徑、remove 移除以 Todolist 為例，當完成某項事件時，就要將它從待辦清單 移除。 Todolist：移除待辦123456// child 子路徑：移至根目錄下的 todos var todos = firebase.database().ref().child('todos');// remove 移除：移除todos下的 -L1H5cAAQnE9y72dCpJ7(要去看電影)todos.child('-L1H5cAAQnE9y72dCpJ7').remove(); 結果 在網頁即時顯示firebase資料可以用 on(隨時監聽) 的特性，隨時將firebase最新的資料回傳更新，這樣在開發時，就不用特地再開firebase的網頁觀看資料，節省切換頁面的時間。 HTML1&lt;pre id="content"&gt;&lt;/pre&gt; js12345// 在網頁即時顯示firebase資料var ref = firebase.database().ref();ref.on('value', function (snapshot) &#123; document.getElementById('content').textContent = JSON.stringify(snapshot.val(), null, 3);&#125;) JSON.stringify補充說明 orderbyForeach 排序從firebase取得有 排序 過後的資料，實作語法需要利用 orderByChild 和 forEach 二個函數搭配使用。 people物件資料1234567891011121314151617var people = &#123; "bob": &#123; "height": 178, "old": 18, "weight": 70 &#125;, "casper": &#123; "height": 180, "old": 13, "weight": 80 &#125;, "mike": &#123; "height": 162, "old": 15, "weight": 55 &#125;&#125;; 依「體重」排序12345678var peopleRef = firebase.database().ref('people');// 路徑&gt;&gt;排序('屬性')&gt;&gt;讀取&gt; forEach 依序撈出資料peopleRef.orderByChild('height').once('value', function (snapshot) &#123; // console.log(snapshot.val()); snapshot.forEach(function (item) &#123; console.log(item.val()); &#125;)&#125;) 延伸問題 firebase 只提供一種排序方式，並無 反向 排序的設定，所以若要達成反向排序，需借用 Array.reverse() 的幫忙。 反向範例123456789101112 var peopleRef = firebase.database().ref('people'); // 路徑&gt;&gt;排序('屬性')&gt;&gt;讀取&gt; forEach 依序撈出資料 peopleRef.orderByChild('height').once('value', function (snapshot) &#123; // console.log(snapshot.val());+ var dataArr = []; snapshot.forEach(function (item) &#123; console.log(item.val());+ dataArr.push(item.val()); &#125;) //反向排序+ console.log(dataArr.reverse()); &#125;) firebase排序規則Array.reverse() startAt、endAt、equalTo 過濾條件 過濾條件： startAt() 多少以上 endAt() 多少以下 equalTo() 相等 使用 過濾條件 時，一定要先 排序(orderByChild) 過資料 一個 過濾條件123456789var peopleRef = firebase.database().ref('people');// 將 重量 排序後，篩選出 4500 以上的資料peopleRef.orderByChild('weight').startAt(4500).once('value', function (snapshot) &#123; snapshot.forEach(function (item) &#123; console.log(item.key); console.log(item.val()); &#125;) // console.log(snapshot.val());&#125;) 多個 過濾條件123456789var peopleRef = firebase.database().ref('people');// 將 重量 排序後，篩選出 2500 ~ 3500 之間的資料peopleRef.orderByChild('weight').startAt(2500).endAt(3500).once('value', function (snapshot) &#123; snapshot.forEach(function (item) &#123; console.log(item.key); console.log(item.val()); &#125;) // console.log(snapshot.val());&#125;) limitToFirst、limitToLast 限制筆數 限制筆數： limitToFirst(n) 從 頭 取得 n 筆資料 limitToLast(n) 從 尾 取得 n 筆資料 取得第 1 筆資料12345678var peopleRef = firebase.database().ref('people');peopleRef.orderByChild('weight').limitToFirst(1).once('value', function (snapshot) &#123; snapshot.forEach(function (item) &#123; console.log(item.key); console.log(item.val()); &#125;) // console.log(snapshot.val());&#125;) 取得倒數 5 筆資料12345678var peopleRef = firebase.database().ref('people');peopleRef.orderByChild('weight').limitToLast(5).once('value', function (snapshot) &#123; snapshot.forEach(function (item) &#123; console.log(item.key); console.log(item.val()); &#125;) // console.log(snapshot.val());&#125;) 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>Firebase</category>
      </categories>
      <tags>
        <tag>Firebase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SASS-基礎用法]]></title>
    <url>%2F2017%2F12%2F25%2FSASS-studynotes%2F</url>
    <content type="text"><![CDATA[變數命名(前面加個 $ 字號)123456789101112131415//變數$font-color: bule;$font-m: 16px;$font-l: $font-m * 1.2;$font-s: $font-m * 0.8;.box01 &#123; color: $font-color; font-size: $font-l;&#125;.box02 &#123; color: $font-color; font-size: $font-s;&#125; @import常見的分類123@import mixin //放置所有Sass全域變數與Mixin@import reset //reset.css@import layout //共同框架(如：表頭、表尾) @mixin + @include建立：@mixin + 名稱 { 語法內容} ; 插入：@include + 名稱 ; 建立1234567//圓角效果@mixin circle($size,$bgcolor)&#123; border-radius: 50%; width: $size; height: $size; background-color: $bgcolor;&#125;// @mixin可搭配變數應用 插入123.circlebox&#123; @include circle(100px,red)&#125; @mixin + @content各種載具斷點123456789101112131415161718192021222324252627282930//iPad - 768px@mixin pad &#123; @media(max-width: 768px)&#123; @content; &#125;&#125;//iPad以下 - 767px@mixin mobile &#123; @media(max-width: 767px)&#123; @content; &#125;&#125;//iPhone 6 Plus - 414px (視專案族群)@mixin i6plue &#123; @media(max-width: 414px)&#123; @content; &#125;&#125;//iPhone 6 - 375px (視專案族群)@mixin i6 &#123; @media(max-width: 768px)&#123; @content; &#125;&#125;//iPhone 5、SE - 320px@mixin i5 &#123; @media(max-width: 320px)&#123; @content; &#125;&#125; 使用方式123456789.header&#123; width: 100px; height: 100px; //iPad - 768px @include pad()&#123; height: auto; &#125;&#125; Sass顏色函數常用函數12345678910111213$bg-color: #ff0000;.darken:hover &#123; background: darken($bg-color, 20%); //將紅色調暗10%&#125;.lighten:hover &#123; background: lighten($bg-color, 20%); //將紅色調亮10%&#125;.invert:hover &#123; background: invert($bg-color); //返回一個反相色&#125; 範例 See the Pen Sass-顏色函數 by Kanboo (@Kanboo) on CodePen. 參考文章30天掌握Sass語法SassMe顏色函數]]></content>
      <categories>
        <category>SASS</category>
      </categories>
      <tags>
        <tag>SASS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS-基礎觀念]]></title>
    <url>%2F2017%2F12%2F24%2FNodeJS-studynotes%2F</url>
    <content type="text"><![CDATA[node全域物件：global node的全域物件為 global ，就像網頁的全域物件為 window。 如下圖，在node環境下，不同js檔之間是區隔的，使用到相同的變數名稱是不會互相影響。 require、module exports由於node環境下，不同js檔之間是區隔的，所以若想要在js檔之間達到資料的傳遞的話，方法如下 app.js 引用語法12345//引用 模組var content = require('./data'); //設定預引用的js檔路徑，不用加副檔名console.log(content.data);console.log(content.bark()); 輸出語法有二種，可任意選擇喜歡的寫法，但不能二種寫法同時在同一個js檔裡，因為會互相覆蓋掉。 data.js 輸出語法1234567891011121314151617//第一種：輸出資料var data = 2;//輸出的資料module.exports = &#123; content: data, title: 'big'&#125;;//第二種：輸出資料exports.data = 2;exports.bark = function()&#123; return 'bark!!';&#125; Node核心模組-createServercreateServer的參數： request：接收User的行為，如：request.url 可取得目前網頁網址response：回應User的結果 123456789101112131415var http = require('http');http.createServer(function (request, response) &#123; // 輸出 純文字 // response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); //文字格式 // response.write('hello word!!'); //輸出 HTML response.writeHead(200, &#123;"Content-Type": "text/html"&#125;); //HTML格式 response.write('&lt;h1&gt;hello word!!&lt;/h1&gt;'); response.end();&#125;).listen(8080); //監聽 8080 port 常見的port：21 FTP80 http3389 遠端桌面 Node模組-Path__dirname：取得目前js檔的目錄路徑，如：/Users/kanboo/Desktop/project __filename：取得目前js檔的檔案路徑，如：/Users/kanboo/Desktop/project/app.js 123456789101112131415161718192021var path = require('path');//抓目錄路徑console.log(path.dirname('/xx/yy/zz.js'));//=&gt; /xx/yy//路徑合併console.log(path.join(__dirname,'/xx'));//=&gt; /Users/kanboo/Desktop/project/xx//抓檔名console.log(path.basename('xx/yy/zz.js'));//=&gt; zz.js//抓副檔名console.log(path.extname('xx/yy/zz.js'));//=&gt; .js//分析路徑console.log(path.parse('xx/yy/zz.js'));//=&gt; &#123; root: '', dir: 'xx/yy', base: 'zz.js', ext: '.js', name: 'zz' &#125; Node.js PATH API文件 NPM-nodemonnodemon是一個專為Node.js設計的模組，它的作用是持續監視著你的程式碼，一旦你修改後保存了，nodemon就會重新啟動你的Node.js程式，這樣你只要刷新你的瀏覽器就能看到改動。 安裝語法1npm install -g nodemon 啟動語法12345//原先啟動server的方法node index.js//改用此方法nodemon index.js nodemon 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-IcoMoon]]></title>
    <url>%2F2017%2F12%2F23%2FCSS-icomoon%2F</url>
    <content type="text"><![CDATA[IcoMoon 下載icons 挑選好想要的icons 修改部份設定 產生sass的css檔 修改引用的html語法預設語法為&lt;span class=&quot;icon-book&quot;&gt;&lt;/span&gt;，修改為&lt;i class=&quot;icon-book&quot;&gt;&lt;/i&gt; 下載字體 引入專案 將下載好檔案解壓縮，複製 fonts資料夾 和 style.scss、variables.scss 複製到專案的source資料夾底下 修改sass的檔名和內容 修改variables.scss內容，並更改檔名為 _icomoon_variables.scss 123 //第一行- $icomoon-font-path: "fonts" !default;+ $icomoon-font-path: "../fonts" !default; //fonts資料夾不是在css資料夾底下，所以需回上一層 修改style.scss內容，並更改檔名為 _icomoon.scss 123 //第一行- @import "variables";+ @import "_icomoon_variables"; 主頁 all.css 引入 _icomoon.scss 123 @import "bootstrap"; @import "font-awesome";+ @import "icomoon"; 使用icons語法 123&lt;i class="icon-music"&gt;&lt;/i&gt;&lt;i class="icon-mic"&gt;&lt;/i&gt;&lt;i class="icon-coin-dollar"&gt;&lt;/i&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>icon</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-webfont 字體]]></title>
    <url>%2F2017%2F12%2F22%2FCSS-Webfont%2F</url>
    <content type="text"><![CDATA[使用方法12345//引入字體@import url(//fonts.googleapis.com/earlyaccess/notosansscsliced.css);//設定字體font-family: 'Noto Sans SC Sliced', sans-serif; 範例See the Pen Webfont - 思源體 by Kanboo (@Kanboo) on CodePen. 問題紀錄雖然已有在css設定 font-family: ‘Noto Sans SC Sliced’, sans-serif; ，不過還是沒套用到新的 font-family ，因為CSS權重的問題，還是使用預設的 微體正黑體， 可能是因為 codepen 有額外加 font-family 設定，導致 &lt;style&gt;的CSS權限 大於在 CSS檔裡面的屬性設定 所以若要強制轉換的話，就需要加 !important 1font-family: 'Noto Sans SC Sliced', sans-serif !important; 參考文章谷歌提出字体切片方案Noto Sans SC Sliced]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>webfont</tag>
        <tag>字體</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-Animation 動畫]]></title>
    <url>%2F2017%2F12%2F21%2FCSS-Animation%2F</url>
    <content type="text"><![CDATA[CSS的Animation分為兩個部分，一個是決定動畫該如何跑的 Keyframe，另一個是將動畫載入元素的 Animation。 Keyframes 語法123456789101112//第一種寫法@keyframes 自訂的name &#123; from &#123; ... &#125; to &#123; ... &#125;&#125;//第二種寫法@keyframes 自訂的name &#123; 0% &#123; ... &#125; 50% &#123; ... &#125; 100% &#123; ... &#125;&#125; Animation 屬性1234567//完整語法animation: 自訂的name duration timing-function delay iteration-count direction fill-mode play-state;//常用寫法animation: 自訂的name duration timing-function iteration-count;animation: time 3s linear infinite; Name：@keyframes 動畫名稱。 Duration：動畫時間。 Timing Function：動畫進行的速度曲線。 ease：是預設的。慢進 → 加速 → 減速到結束。 ease-in：慢進 → 加速到結束。 ease-out：快進 → 減速到結束。 ease-in-out：開始跟結束都是慢的狀態。 linear：以相同速度前進。 steps()：無連續的動作，直接跳至各步 ( step ) 的指定 css。 cubic-bezier()：指定動畫滑動的曲線。 Delay：延遲動畫開始的時間。 Iteration Count：動畫重複次數(預設一次)。 infinite(無限) | 次數 Direction：動畫播放方向。 normal ：每次播放都是從 0% 至 100% reverse ：每次播放都是從 100% 至 0% alternate ：播放兩次以上的話，會從 0% 至 100% ，再從 100% 回到 0% ，以此類推 alternate-reverse ：跟 alternate 相反，會先從 100% 開始播放 Fill Mode：控制動畫播放完後的最終狀態。 none ：回到未播放動畫效果前的狀態 forwards ：停在動畫的最後一個狀態上 backwards ：停在動畫的第一個狀態上 (實測不出來) both ：視 animation-direction 來決定停在哪一個狀態上。 Play State：指定動畫播放或暫停。 可以的選項有 running|pause，與影片的播放、暫停是同樣的意思；這在與 JS 搭配時，可妥善控制動畫。 範例翻轉效果 See the Pen CSS Animation-範例1 by Kanboo (@Kanboo) on CodePen. 滾動效果 See the Pen CSS Animation-範例2 by Kanboo (@Kanboo) on CodePen. 參考文章CSS3 動畫基礎CSS3 AnimationAnimation動畫效果]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>動畫</tag>
        <tag>animattion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-練習-自刻時鐘]]></title>
    <url>%2F2017%2F12%2F20%2FCSS-Exercise-Clock%2F</url>
    <content type="text"><![CDATA[練習-自刻時鐘 步驟 先建立骨架(HTML) 12345678&lt;div class="warp"&gt; &lt;div class="clock"&gt; &lt;div class="centerpoint"&gt;&lt;/div&gt; &lt;div class="hour"&gt;&lt;/div&gt; &lt;div class="minute"&gt;&lt;/div&gt; &lt;div class="second"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 將時鐘元件垂直置中 將「圓點、時針、分針、秒針」移至時鐘的中心點。 123456position: absolute;top: 0;bottom: 0;left: 0;right: 0;margin: auto; 修改transform-origin與position位置 下列說明以 時針 為例(分針、秒針比照辦理)： 垂直置中後的 時針 css 12345678910111213$handwidth: 7px;.hour &#123; width: $handwidth; height: 80px; background-color: blue; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;&#125; 先修改 transform-origin 的軸心 12345678910111213.hour &#123; width: $handwidth; height: 80px; background-color: blue;+ //將軸心變更到 中下方 的位置+ transform-origin: 50% 80%; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;&#125; 加上旋轉的動畫效果 123456789101112131415161718192021.hour &#123; width: $handwidth; height: 80px; background-color: blue; //將軸心變更到 中下方 的位置 transform-origin: 50% 80%; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;+ animation: time 25s infinite linear;&#125;+ //旋轉的動畫效果+ @keyframes time &#123;+ to &#123;+ transform: rotate(360deg);+ &#125;+ &#125; 修改 position 位置 此時可以開啟Chrome的開發者工具，先利用工具微調好 時針 的position位置，讓他旋轉效果有繞著時鐘的中心點旋轉後，再將程式碼複製貼回去。 1234567891011121314151617181920212223.hour &#123; width: $handwidth; height: 80px; background-color: blue; //將軸心變更到 中下方 的位置 transform-origin: 50% 80%; position: absolute;- top: 0;+ top: -49px; bottom: 0;- left: 0;+ left: -1px; right: 0; margin: auto; animation: time 25s infinite linear;&#125;//旋轉的動畫效果@keyframes time &#123; to &#123; transform: rotate(360deg); &#125;&#125; 範例See the Pen 練習-自刻時鐘 by Kanboo (@Kanboo) on CodePen.]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>練習</tag>
        <tag>時鐘</tag>
        <tag>clock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 - 語義元素]]></title>
    <url>%2F2017%2F12%2F18%2FHTML5-Semantics%2F</url>
    <content type="text"><![CDATA[重新認識HTML5的語義元素 常用元素&lt;header&gt;區塊標題，不要把它只用來取代 &lt;div class=”header”&gt;它也可以是文章的標題，一頁可以有好多個 &lt;header&gt;，&lt;header&gt; 裡面至少要有一個 h1~h6。 &lt;nav&gt;導覽列。裡面裝的東西應該只有 _主要_ 的navigation links，不要把各種link都丟到&lt;nav&gt;裡面。舉例來說，footer裡面常常會有一排link，那個就不需要包進&lt;nav&gt;。 &lt;main&gt;一個頁面只有一個! 任何 global 都不能放在 main 裡面( e.g. &lt;header&gt; &lt;footer&gt; logo) &lt;section&gt;通常用來把一些相關的元素組合在一起，一般來說，裡面都會包含heading。如果這個區塊的內容可以分成幾個部分的話，那應該使用article。 1234&lt;section&gt; &lt;h2&gt;Section title&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec viverra nec nulla vitae mollis.&lt;/p&gt;&lt;/section&gt; &lt;article&gt;文章中可以脫離其他部分，獨立出來而又完整，甚至可以復用的一部分，通常有自己的標題，當article內嵌article時，裡外層的內容應該是相關的，比如一篇文章和它的留言，而section雖然也具有獨立表達內容的能力，但是對外層有一定的相依性，例如這篇文章中的一個章節。 123456789101112131415&lt;article&gt; &lt;header&gt; &lt;h3&gt; &lt;a href="/my-blog-post"&gt;My blog post&lt;/a&gt; &lt;/h3&gt; &lt;/header&gt; &lt;section&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec viverra nec nulla vitae mollis.&lt;/p&gt; &lt;/section&gt; &lt;footer&gt; &lt;small&gt; Posted on &lt;time datetime="2017-04-29T19:00"&gt;Apr 29&lt;/time&gt; in &lt;a href="/category/code"&gt;Code&lt;/a&gt; &lt;/small&gt; &lt;/footer&gt;&lt;/article&gt; &lt;aside&gt;通常用來包含一些和當前頁面內容有關的額外信息，比如廣告、個人資料信息或相關連結。 &lt;footer&gt;通常包含作者、版權信息或者相關鏈接等。 簡易分辦 &lt;section&gt;&lt;article&gt;&lt;article&gt;: 就算脫離了整體也是一個可以獨立存在、具有完整內容的區塊，例如這篇文章。&lt;section&gt;: 具有獨立表達內容的能力，但是對外層有一定的相依性，例如這篇文章中的一個章節。 下面是簡單的問題，讓我們決定要用 &lt;section&gt; / &lt;article&gt; / &lt;div&gt; 具有完整內容的區塊，而且可以出現在你的閱讀器內嗎? 是的話就是 &lt;article&gt; 跟主要內容是有相關並且列入 outline 裡不會奇怪的? 是的話就是 &lt;section&gt; 跟內容無關或只用來 styling 的? 是的話就是 &lt;div&gt; 建議的架構範例 參考文章结构性元素HTML5 Semantic ElementsHTML5 SemanticsSemantic in HTML5]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>語義架構</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-垂直置中的方法]]></title>
    <url>%2F2017%2F12%2F17%2FCSS-vertical-align%2F</url>
    <content type="text"><![CDATA[整理常用CSS常用的 垂直置中 的方法。 文字的垂直置中方法此方法適用 單行，因為是行高，所以會在行內元素的上下都加上行高的 1/2 ，如果多行，第二行與第一行的間距會變超大，就會導致沒有垂直置中的效果。 123456789// height 和 line-height 要一樣高.div0,.div1 &#123; width: 300px;+ height: 250px;+ line-height: 250px; text-align: center; border: 1px solid #000;&#125; See the Pen 垂直置中 - line-height by Kanboo (@Kanboo) on CodePen. calc &amp; transform使用 calc 動態計算的能力，讓要置中的 div 的 top 屬性，與上方的距離是「50% 的外框高度 + 50% 的 div 高度」，就可以做到垂直置中。 範例1：設定top：50%，再扣掉 div 的 高度/2 方法1：top: calc( 50% - (高度/2) ) 方法2：top: 50%; margin-top: -(高度/2); 方法3：top: 50%; transform: translateY(-50%); 自行計算50%的div高度 1234567891011121314151617181920212223242526272829.redbox &#123; background: #c00; float: left;+ position: relative; //要宣告position，才能使用 top、left width: 30px;- //計算方法1+ height: 30px;+ top: calc(50% - 15px); //高：30/2=15 &#125; .greenbox &#123; background: #0c0; float: left; position: relative; width: 30px;- //計算方法2+ height: 80px;+ top: 50%;+ margin-top: -40px; //高：80/2=40 &#125; .bluebox &#123; background: #00f; float: left; position: relative; width: 30px; height: 50px;- //計算方法3+ top:50%;+ transform: translateY(-50%); &#125; See the Pen 垂直置中 - calc 動態計算1 by Kanboo (@Kanboo) on CodePen. 範例2：將三個div設定寬高各30px，將滑鼠移到黑框內，可觀看效果。 See the Pen 垂直置中 - calc 動態計算2 by Kanboo (@Kanboo) on CodePen. 絕對定位利用絕對位置來指定，要將 上下 的數值都設為 0，再搭配一個 margin:auto，就可以辦到垂直置中。 邏輯：這個方法同時設定top和bottom為0，使得這個div完全不可能符合，最後再透過margin這個指令，讓它達到垂直置中的效果 123456789101112131415161718 .redbox &#123;- // 垂直置中 background: #c00; position: absolute; //要宣告，才能使用 top、left+ top: 0;+ bottom: 0;+ margin: auto; &#125; .bluebox &#123;- // 垂直置中 + 水平置中 background: blue; position: absolute; //要宣告，才能使用 top、left top: 0; bottom: 0;+ left: 0;+ right: 0; margin: auto; &#125; See the Pen 垂直置中 - 絕對定位 by Kanboo (@Kanboo) on CodePen. FlexboxCSS3 最威的盒子模型：Flexbox，使用 align-items 或 align-content 的屬性， 輕輕鬆鬆就可以做到垂直置中的效果喔，Bootstrap 4 也有用喔。 1234567891011121314.div0 &#123;+ display: flex;+ align-items: center;+ justify-content: center; width: 150px; height: 150px; border: 1px solid #000; .redbox &#123; width: 30px; height: 30px; background: #c00; &#125;&#125; See the Pen 垂直置中 - Flexbox by Kanboo (@Kanboo) on CodePen. 參考文章CSS 垂直置中的七個方法CSS垂直置中的方法]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>vertical-align</tag>
        <tag>垂直置中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-transform 2D]]></title>
    <url>%2F2017%2F12%2F16%2FCSS-transform-2D%2F</url>
    <content type="text"><![CDATA[利用 transform 將元素加入 位移、旋轉、縮放和傾斜 的效果。 基本語法transform 屬性可以設定 一個 或 多個 的參數，若設定多個參數的話，中間的區隔使用 空白 即可。 123transform: 第一個參數 第二個參數 ...transform: translate(100px) rotate(20deg); 常用的參數如下列 位移 - translate()、translateX()、translateY() 旋轉 - rotate() 縮放 - scale()、scaleX()、scaleY() 傾斜 - skew()、skewX()、skewY() 位移translate語法 若設定二個，用 逗號 區隔 translate(tx) → 若僅設定一個參數，代表只 位移X translate(tx, ty) 設定 X軸 位移 translateX() 設定 Y軸 位移 translateY() 範例 位移 X軸 50px,位移 Y軸 50px 12345.moved &#123; transform: translate( 50px, 50px); // 上下二段語法，結果一樣 transform: translateX( 50px) translateY( 50px);&#125; See the Pen transform-translate by Kanboo (@Kanboo) on CodePen. 旋轉rotate語法 rotate( 旋轉角度 ) =&gt; rotate( 20deg ) 旋轉30度角 = 30deg旋轉90度角 = 90deg 範例 旋轉45度角 123.rotate &#123; transform: rotate( 45deg);&#125; See the Pen transform-rotate by Kanboo (@Kanboo) on CodePen. 縮放scale語法 參數預設大小為 1 ，若設定 小於 1 就是 縮小，大於 1 就是 放大。 若設定二個，用 逗號 區隔 scale(sx) → 若僅設定一個參數，代表同時縮放 X 和 Y scale(sx, sy) 縮放 X軸 scaleX() 縮放 Y軸 scaleY() 範例 縮小至0.7倍 12345.scaled &#123; transform: scale(0.7); // 上下二段語法，結果一樣 transform: scaleX(0.7) scaleY(0.7);&#125; See the Pen transform-scale by Kanboo (@Kanboo) on CodePen. 傾斜skew語法 若設定二個，用 逗號 區隔 skew(ax) → 若僅設定一個參數，代表只 傾斜X skew(ax, ay) 傾斜 X軸 skewX() 傾斜 Y軸 skewY() 範例 skewed1 傾斜 X , skewed1 傾斜 X 和 Y 1234567891011 .skewed1 &#123; transform: skew(10deg); // 等同 skewX(10deg) transform: skewX(10deg);&#125;.skewed2 &#123; transform: skew(10deg, 10deg); // 等同 skewX(10deg) skewY(10deg) transform: skewX(10deg) skewY(10deg);&#125; See the Pen transform-skew by Kanboo (@Kanboo) on CodePen.]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>transform</tag>
        <tag>2D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-transform-origin 軸心]]></title>
    <url>%2F2017%2F12%2F15%2FCSS-transform-origin%2F</url>
    <content type="text"><![CDATA[在學習 transform 之前，先了解 transform-origin 軸心 怎麼變化？ 說明在撰寫CSS transform 時，預設的 軸心 是在Box的正中央位置(如下圖)， 所以要製作一些比較特別的效果的話，如：時間、開門 …等 就利用變更軸心的位置，再配合 transform 來達成。 1transform-origin: x y; 範例：利用 transform: rotate(90deg) 旋轉 90度，呈現因 軸心位置不同 ，而旋轉的結果有何不一樣。 C 軸心： 正中間(預設) F 軸心： 右下角 E 軸心： 左邊中間 See the Pen transform-origin 更改軸心 by Kanboo (@Kanboo) on CodePen. 其他範例teaching transform-originTransform Origin Examples 參考文章CSS沒有極限 - CSS transform-origin]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>transform</tag>
        <tag>transform-origin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Browsersync]]></title>
    <url>%2F2017%2F12%2F15%2FHexo-Browsersync%2F</url>
    <content type="text"><![CDATA[實現撰寫文章時，可自動刷新頁面預覽，不用再手動F5了。 前言實現刷新功能，需要完成的事情有： 安裝套件 Hexo-Browsersync 解決文章太長-渲染失敗Bug 執行 hexo server，即可。 操作步骤1.安裝套件1$ npm install hexo-browsersync --save 2.修正Bug 安裝 hexo-renderer-jade 插件 1$ npm install hexo-renderer-jade --save 在你的 node_modules 文件夾裡找到 hexo-renderer-pug 的文件夾，然後將裡面 lib/renderer.js 的其中一行代碼 註解 掉： 1//pugRenderer.compile = pugCompile; 新增 _config.yml 的設定。 參考：issue 新增路徑：~/blog/_config.yml12server: compress: true #開啟壓縮 3.執行1$ hexo s 啟動 hexo server 後，你會看到下列的訊息 12345678INFO Start processing[Browsersync] Access URLs: -------------------------------------- UI: http://localhost:3001 -------------------------------------- UI External: http://192.168.1.135:3001 --------------------------------------INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. port:3001 可修改 browsersync 相關設定。port:4000 Blog的預覽畫面。 參考文章Hexo 实现实时预览编辑Hexo不重新生成也可预览修正渲染不全問題]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Browsersync</tag>
        <tag>頁面自動刷新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-複製功能]]></title>
    <url>%2F2017%2F12%2F15%2FHexo-clipboard%2F</url>
    <content type="text"><![CDATA[實現程式碼區塊，可進行 Ctrl + C 前言實現複製功能，需要完成的事情有： 下载插件clipboard.js 插入JavaScript 插入主题中 操作步骤1.下載插件clipboard.js將下載好的 clipboard.js 放置下列路徑， 目錄zclip 為此次 新增 。 ~blog/themes/next/source/lib/zclip/clipboard.min.js clipboard.js下載位址：GitHub 2.新增JavaScript新增 文件 custom.js ，目錄如下： 新增JS文件位置：~/blog/themes/next/source/js/src/custom.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//此函数用于创建复制按钮function createCopyBtns() &#123; var $codeArea = $("figure table"); //查看页面是否具有代码区域，没有代码块则不创建 复制按钮 if ($codeArea.length &gt; 0) &#123; //复制成功后将要干的事情 function changeToSuccess(item) &#123; $imgOK = $("#copyBtn").find("#imgSuccess"); if ($imgOK.css("display") == "none") &#123; $imgOK.css(&#123; opacity: 0, display: "block" &#125;); $imgOK.animate(&#123; opacity: 1 &#125;, 1000); setTimeout(function() &#123; $imgOK.animate(&#123; opacity: 0 &#125;, 2000); &#125;, 2000); setTimeout(function() &#123; $imgOK.css("display", "none"); &#125;, 4000); &#125;; &#125;; //创建 全局复制按钮，仅有一组。包含：复制按钮，复制成功响应按钮 //值得注意的是：1.按钮默认隐藏，2.位置使用绝对位置 position: absolute; (position: fixed 也可以，需要修改代码) $(".post-body").before('&lt;div id="copyBtn" style="opacity: 0; position: absolute;top:0px;display: none;line-height: 1; font-size:1.5em"&gt;&lt;span id="imgCopy" &gt;&lt;i class="fa fa-paste fa-fw"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span id="imgSuccess" style="display: none;"&gt;&lt;i class="fa fa-check-circle fa-fw" aria-hidden="true"&gt;&lt;/i&gt;&lt;/span&gt;'); //创建 复制 插件，绑定单机时间到 指定元素，支持JQuery var clipboard = new Clipboard('#copyBtn', &#123; target: function() &#123; //返回需要复制的元素内容 return document.querySelector("[copyFlag]"); &#125;, isSupported: function() &#123; //支持复制内容 return document.querySelector("[copyFlag]"); &#125; &#125;); //复制成功事件绑定 clipboard.on('success', function(e) &#123; //清除内容被选择状态 e.clearSelection(); changeToSuccess(e); &#125;); //复制失败绑定事件 clipboard.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger); &#125;); //鼠标 在复制按钮上滑动和离开后渐变显示/隐藏效果 $("#copyBtn").hover( function() &#123; $(this).stop(); $(this).css("opacity", 1); &#125;, function() &#123; $(this).animate(&#123; opacity: 0 &#125;, 2000); &#125; ); &#125;&#125;//感应鼠标是否在代码区$("figure").hover( function() &#123; //-------鼠标活动在代码块内 //移除之前含有复制标志代码块的 copyFlag $("[copyFlag]").removeAttr("copyFlag"); //在新的（当前鼠标所在代码区）代码块插入标志：copyFlag $(this).find(".code").attr("copyFlag", 1); //获取复制按钮 $copyBtn = $("#copyBtn"); if ($copyBtn.lenght != 0) &#123; //获取到按钮的前提下进行一下操作 //停止按钮动画效果 //设置为 显示状态 //修改 复制按钮 位置到 当前代码块开始部位 //设置代码块 左侧位置 $copyBtn.stop(); $copyBtn.css("opacity", 0.8); $copyBtn.css("display", "block"); $copyBtn.css("top", parseInt($copyBtn.css("top")) + $(this).offset().top - $copyBtn.offset().top + 2); // $copyBtn.css("right", -$copyBtn.width() - 3); $copyBtn.css("right", 0); &#125; &#125;, function() &#123; //-------鼠标离开代码块 //设置复制按钮可见度 2秒内到 0 $("#copyBtn").animate(&#123; opacity: 0 &#125;, 2000); &#125;);//页面载入完成后，创建复制按钮$(document).ready(function() &#123; createCopyBtns();&#125;); 3.更新主题新增 文件custom.swig，目錄如下： 新增位置：~/blog/themes/next/layout/_custom/custom .swig12&lt; script type = "text/javascript" src = "/lib/zclip/clipboard.min.js" &gt;&lt;/ script &gt; &lt; script type = "text/javascript" src = "/js/src/custom.js" &gt;&lt;/ script &gt; 修改 文件_layout.swig，目錄如下： 修改位置：~/blog/themes/next/layout/ _layout .swig12345678910111213141516&lt;!doctype html&gt;...&lt; html class = "&#123;&#123; html_class | lower &#125;&#125;" lang = "&#123;&#123; config.language &#125;&#125;" &gt;&lt; head &gt; ...&lt;/ head &gt;&lt; body itemscope itemtype = "http://schema.org/WebPage" lang = "&#123;&#123; page.lang || page.language || config.language &#125;&#125;" &gt; ... ... &#123;% include '_third-party/mathjax.swig' %&#125; &#123;% include '_third-party/scroll-cookie.swig' %&#125; &#123;% include '_third-party/exturl.swig' %&#125;+ &#123;% include '_custom/custom.swig' %&#125;&lt;/ body &gt;&lt;/ html &gt; 在文件中前一行插入文件引用，如第15行效果。1&#123;% include &apos;_custom/custom.swig&apos; %&#125; 參考文章HEXO優化之（二）—-添加複制功能]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>clipboard</tag>
        <tag>複製</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-留言版]]></title>
    <url>%2F2017%2F12%2F13%2FHexo-Comment%2F</url>
    <content type="text"><![CDATA[前言 新增 Hexo 的留言版，需要完成的事情有： 註冊 Disqus 的帳號 新建 Disqus 的 website 配置 Hexo 操作步骤1.註冊 Disqus 的帳號Disqus網址：https://disqus.com/ 打開鏈接後， 可以直接用Facebook，Twitter以及Google 登錄，也可以用郵箱註冊後登錄。 2.建立 Disqus website 點擊 GET STARTED 開始建立 website 點擊下面 I want to install Disqus on my site 填寫 Website Name，這是 短名稱，用於和 Hexo連結的 Key值。 直接點擊 Configure Disqus 填寫 Website URL ，這是你 Blog的網址 建立完成畫面 3.配置 Hexo主題配置主題 下面的 config.yml 文件，路徑： ~blog/themes/next/_config.yml 將 Disqus下的 enable 設定為 true 。 同時填寫您的 shortname(短名稱)。 count 用於指定是否顯示評論數量。 12345# Disqusdisqus: enable: true shortname: kanbooBlog count: true 上述步驟設置完成後，更新Blog 123$ hexo clean$ hexo g$ hexo d 參考資料Hexo 集成Disqus 評論Hexo搭建博客系列：（六）Hexo添加Disqus評論Next-评论系统]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Comment</tag>
        <tag>Disqus</tag>
        <tag>留言版</tag>
        <tag>評論</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-文章置頂]]></title>
    <url>%2F2017%2F12%2F13%2FHexo-Topfeatures%2F</url>
    <content type="text"><![CDATA[前言解決Hexo置頂問題，需要完成的事情有： 將目前 node_modules/hexo-generator-index/lib/generator.js 程式碼替換 在需要置頂的文章的前事中添加頂值，值越大越置頂。 操作步骤 替換 generator.js 程式碼 12345678910111213141516171819202122232425'use strict';var pagination = require('hexo-pagination');module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if (a.top &amp;&amp; b.top) &#123; // 兩篇文章top都有定義 if (a.top == b.top) return b.date - a.date; // 若top值一样則按照文章日期降序排 else return b.top - a.top; // 否則按照top值降序排 &#125; else if (a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定義，那麼将有top的排在前面 return -1; &#125; else if (!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都沒定義按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 若找不到 node_modules/hexo-generator-index/lib/generator.js 的話，請先安裝 hexo-generator-index。 指令： npm i --save hexo-generator-index 在需要置顶的文章的中添加 top 值，值越大越置顶。 123title: Hexo-文章置頂date: 2017-12-13 09:29:37top: 100 參考資料hexo置顶功能Hexo文章置顶]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Top</tag>
        <tag>置頂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-transition 轉場效果]]></title>
    <url>%2F2017%2F12%2F12%2FCSS-Transition%2F</url>
    <content type="text"><![CDATA[轉場是從 A 狀態，轉變成 B 狀態，中間的過程，就叫轉場，在 CSS 中叫做 transition。 語法1234567891011transition: property duration timing-function delay;transition: 套用的屬性 花費時間 時間速率 等待時間;transition: all 2s ease-out 1s;// 等同於：transition-property: all; // default: alltransition-duration: 2s; // default: 0；2s 表示 2 秒；2ms 表示 2 毫秒。transition-timing-function: ease-out;transition-delay: 1s; // 開始進行轉場效果之前，所要等待的時間。 transition-timing-function 時間速率 See the Pen transition 各種速率 by Kanboo (@Kanboo) on CodePen. 範例範例 1：hoverSee the Pen Transition - hover by Kanboo (@Kanboo) on CodePen. 範例 2：設定Two CSS propertiesSee the Pen Transition - 設定Two CSS properties by Kanboo (@Kanboo) on CodePen. 特別的點：12//設定二個 CSS屬性，設定不同 時間、速率..等transition: background .2s linear, border-radius 1s ease-in 1s; 上面案例，特別於在 :hover 時，有改變 背景色 和 圓角 效果，不過在 transition 的設定，分別針對 二個屬性設定不同的時間、速率…等 參考資料[CSS][Transition] 轉場效果 CSS3轉場效果(transitions) CSS transition 各種速率]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>transition</tag>
        <tag>動畫</tag>
        <tag>轉場效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-切版練習]]></title>
    <url>%2F2017%2F12%2F11%2FCSS-RWDlayout%2F</url>
    <content type="text"><![CDATA[紀錄練習切版時，遇到卡卡的問題 icon 利用 position 位移示意圖 重點 row 的 position 設置 relative; icon 的 position 設置 absolute; 移動 icon 的位置， top 、 left 將 icon 移進去在 input 時，input 需增加 左邊padding，保留位置給 icon。 HTML 程式碼123456&lt;div class="row"&gt; &lt;label for="email"&gt;Email Address*&lt;/label&gt; &lt;label for="email" class="icon"&gt;&lt;i class="fa fa-envelope-o" aria-hidden="true"&gt;&lt;/i&gt;&lt;/label&gt; &lt;input type="email" name="email" id="email"&gt;&lt;/div&gt; SCSS 程式碼12345678910111213141516171819//記得input的左邊要留padding,保留一些位置給iconinput &#123; padding: 6px 0 6px 28px;&#125;//位移 icon 至 input 裡.row &#123; position: relative; .icon &#123; position: absolute; top: 26px; left: 9px; font-size: 16px; z-index: 10; color: rgba(61, 17, 1, 0.5); &#125;&#125; codepen範例: LoginForm 緞帶效果 重點 .tag-wrap 為 藍色框線 .tag 為 紅色框線(熱賣) .tag-wrap 的 position 設置 absolute ，並且位移要超出原有的框架，才能做出緞帶效果; 新增 .tag 的 width、background-color…等屬性 利用 transform ，位移翻轉 .tag 移動好 .tag 後，在 .tag-wrap 新增 overflow: hidden;， 將多餘的部份隱藏 利用 .tag 的偽元素 :before、:after，新增 小三角 ▲ html 程式碼123456789101112&lt;div class="card"&gt; &lt;!-- 不影響結構 --&gt; &lt;div class="tag-wrap"&gt; &lt;div class="tag"&gt; 熱賣!! &lt;/div&gt; &lt;/div&gt; &lt;!-- 主要結構 --&gt; &lt;div class="card-block"&gt; &lt;/div&gt;&lt;/div&gt; SCSS 程式碼1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.card &#123; width: 230px; height: 200px; position: relative;&#125;//緞帶效果.tag-wrap &#123; $p: 5px; $size: 80px; position: absolute; //位移要超出原有的框架，才能做出緞帶效果 top: -$p; right: -$p; //超出的部份隱藏 overflow: hidden; width: $size * 2; height: $size * 2; //查看位置 border: 1px solid blue; .tag &#123; position: relative; width: $size*2; background-color: orange; padding-top: 0.25rem; padding-bottom: 0.25rem; text-align: center; margin-top: -$p * 2; color: white; //rotate為旋轉、translate為移動、skew為傾斜、scale為縮放 transform: translateX(50%) rotate(45deg) translateY(150%); //查看位置 border: 1px solid red; &amp;:before &#123; content: ""; position: absolute; //利用 加粗邊框 + 邊框上方顏色，達到小三角的效果 border: $p solid transparent; border-top-color: darken(orange, 15%); bottom: -10px; left: 6px; &#125; &amp;:after &#123; content: ""; position: absolute; //利用 加粗邊框 + 邊框上方顏色，達到小三角的效果 border: $p solid transparent; border-top-color: darken(orange, 15%); bottom: -10px; right: 14px; &#125; &#125;&#125; codepen範例: CSS-緞帶效果(乾淨版本)codepen範例: CSS-緞帶效果 觀念補充六角範例從 Sketch 設計到 CSS 切版 本日範例：https://codepen.io/Wcc723/pen/zEYXdN 本日設計參考：https://codepen.io/Wcc723/pen/pWzxXO transform CSS 程式碼123456789101112/* rotate為旋轉skew為傾斜scale為縮放translate為移動 *//* 範例1：移動X軸 → 旋轉 → 移動Y軸 */transform: translateX(150%) rotate(45deg) translateY(50%);/* 範例2：旋轉 → 移動X軸 → 移動Y軸 */transform: rotate(45deg) translateX(150%) translateY(50%); 上列 CSS程式碼 「範例1 、 範例2」，雖然同樣都做了「移動X軸、移動Y軸、旋轉」的動作，但是因為 執行順序 不同，所以二個範例呈現出來的結果也會不一樣。 上述程式碼範例： transform_執行順序 transform基本介紹1.CSS transform 概觀2.CSS transform 軸線的謊言3.CSS transform-origin4.CSS transform-3D的透視 SCSS顏色函數範例123456789.box&#123; background: rgba(#000,.5); //變半透明 background: invert(#f00); //變反向色彩 background: lighten(#06C, 30%); //變亮 background: darken(#06C,15%); //變暗 background: saturate(#06C,50%); //提高飽和度 background: desaturate(#06C,50%); //降低飽和度 background: grayscale(#06C); //灰階&#125; SCSS相關 linear-gradient讓顏色有漸層效果 CSS 程式碼1background-image: linear-gradient(165deg, white, white 50%, $bg-color 50%); background: linear-gradient( 方向, 第一個顏色, 第二個顏色, … ); 背景色 — 线性渐变背景色 — 漸層效果 繪製幾何圖形(支援度不高) 1clip-path: polygon(0 0, 280px 0, 370px 100%, 0% 100%); CSS clip-path 生成器利用CSS繪製更多形狀不可思议的CSS之CLIP-PATH]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>transform</tag>
        <tag>translateX</tag>
        <tag>rotate</tag>
        <tag>translateY</tag>
        <tag>SCSS</tag>
        <tag>linear-gradient</tag>
        <tag>clip-path</tag>
        <tag>position</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS - 常用筆記]]></title>
    <url>%2F2017%2F11%2F13%2FCSS-ForgetfulNotes%2F</url>
    <content type="text"><![CDATA[背景圖123456789101112131415/* 圖片滿版 */.img-cover &#123; background-image: url(./bg.png); background-position: center; background-size: cover; background-repeat: no-repeat;&#125;/* 圖片居中 */.img-contain &#123; background-image: url(./bg.png); background-position: center; background-size: contain; background-repeat: no-repeat;&#125; 其他背景圖範例：固定、滿版、置中background-attachment是背景固定模式的屬性註：作为背景的圖片是撑不起元素的，須額外需要给div新增「寬、高」 圓角123456div.circle&#123; width:80px; height:80px; border-radius:50%; background-color:blue;&#125; 2個重點： 圓的直徑，長寬 一定要等長 border-radius:50% 參考網址： 圓角詳解、CSS3技巧之形狀 區塊陰影、文字立體感12345678/* 外層的陰影 */box-shadow: 1px 1px 5px rgba(0,0,0,0.3);/* 內層的陰影(多加 inset) */box-shadow: inset 1px 1px 5px rgba(0,0,0,0.3);/* 文字的陰影 */text-shadow: 1px 1px 1px rgba(0,0,0,0.5); 參考網址： 玩转box-shadow、文字立體感 a 連結取消 a 連結下底線123a &#123; text-decoration: none;&#125; :hover 移至 a 連結的效果123a:hover &#123; border-bottom: 3px solid #00cc99;&#125; 註：a 連結 預設display為inline，但為了讓 User有更好的操作體驗，會變更成 block，增加「寬、高」範圍，讓 User較易點擊到目標連結。 斷點123456@media (max-width: 768px) &#123; //iPad&#125;@media (max-width: 767px) &#123; //iPhone&#125; 新單位：高度vh、寬度vwvh 代表的是view height，也就是螢幕可視範圍高度的百分比；vw 表示的是view width，也就是螢幕可是範圍寬度的百分比。 ul ol list-style取消樣式ol,ul {list-style: none;} 設定樣式list-style: circle; 其他樣式參考：CSS list-style 指定滑鼠游標的型態cursor: pointer; /*手型，表示超連結*/ 參考網址： 游標的型態]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>筆記</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Search]]></title>
    <url>%2F2017%2F10%2F18%2FHexo-Search%2F</url>
    <content type="text"><![CDATA[前言在新增 Hexo 的 Local Search 時，參考下列的連結文章，跟著步驟安裝及設定即可，不過剛裝好後，發現搜尋功能無法正常使用，後來有查到原因，在此紀錄一下Debug過程。 Local SearchHexo博客添加站內搜索 安裝順序安裝hexo-generator-searchdb在站點的根目錄下執行以下命令 1$ npm install hexo-generator-searchdb --save 編輯站點配置文件(Hexo)新增以下內容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 編輯主題配置文件(Next)啟用本地搜索功能： 123# Local searchlocal_search: enable: true 問題紀錄 點了搜尋後，畫面一直轉圈圈沒停止，查看Console也沒出現Error 查看XHR，目前我有10篇文章，卻只產生三筆entry，且其中一筆entry的content內容沒產生 並且有此錯誤訊息 後來針對有問題那篇文章複製內容，貼到 notepad++ 看看，發現有一亂碼，將亂碼刪除後，Local Search就可以正常運作了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC-讓終端機變好看]]></title>
    <url>%2F2017%2F10%2F15%2FMAC-iTerm2-Zsh%2F</url>
    <content type="text"><![CDATA[前言在安裝 MAC終端機高亮的過程，主要是參考下列的文章，跟著步驟安裝及設定即可，不過安裝過程中，還是有遇到卡卡的地方，所以特別記一下 卡卡的歷程。 為 MAC 的 Terminal 上色 - 透過 iTerm 2 和 Oh My Zsh 高亮你的終端機 讓 MAC 終端機變好看 iterm2-solarized 原文 問題紀錄zsh指令失效安裝完zsh，在使用相關shell命令，出現了zsh: command not found Nodezsh: command not found: hexo等一系列error zsh 和bash 的環境變量bash的環境變量是.bash_profile文件。zsh的環境變量是.zshrc文件。 字面意思是相關命令沒有沒有找到，其實就是bash shell 以及 zsh shell是 兩種讀取系統環境變量，簡單來說就是說 node、Hexo…等套件 是在使用 bash 時候，安裝好的，所以會設定在 .bash_profile裡，後來改使用 zsh shell 的時候，你並沒有把相關的環境變量的配置設置到 .zshrc 中（功能上類似bash 的.bash_profile），所以 .zshrc 沒有配置相關環境變量設置，就把bash 中.bash_profile 全部環境變量加入 .zshrc 就好。 加入方法：123456#打開 zsh 的設定檔open ~/.zshrc# 最后一行加入下面指令# 解決OSX使用oh-my-zsh後.bash_profile自定義失效source ~/.bash_profile zsh: command not foundzsh: command not found解决OSX使用oh-my-zsh后.bash_profile自定义失效 安裝字型原先是跟著最上面文章教學，安裝 字型(Meslo LG M Regular for Powerline)，再修改相關設定後，此字型在 iTerm 上，顯示箭頭是正常的，不過在VScode上面，顯示 箭頭 卻還是有亂碼，所以去Google一下，結果如下 先安裝 字型 1234# 安裝字型$ git clone git://github.com/powerline/fonts ~/.powerline_fonts$ cd ~/.powerline_fonts$ ./install.sh iTerm設定 字型iTerm –&gt; Preferences –&gt; Profiles –&gt; Text –&gt; Change Font推薦使用 Source Code Pro (Adobe的）與 Ubuntu Mono，這兩個字型都相當適合寫程式使用。 VSCode設定 字型在設定參數裡，新增下列二行 12"terminal.integrated.fontFamily": "Source Code Pro for Powerline","terminal.integrated.fontSize": 14 安裝Powerline專屬字型美化你的終端機]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>iTerm2</tag>
        <tag>ZSH</tag>
        <tag>終端機</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-備份]]></title>
    <url>%2F2017%2F10%2F14%2FHexo-backup%2F</url>
    <content type="text"><![CDATA[前言簡單來說，實現備份方法就是利用 二個分支線 個別放我們要的檔案，一個分支線 放 發佈的文章，另一個分支線 放 備份的檔案， master: 利用 hexo deploy 直接推送，存放由 hexo 產生的靜態頁面 hexo: 利用 git command 推送，存放部落格原始碼 由於 Github Page 本身限制頁面主要分支必須為 master，因此考慮增設分支 hexo 用以存放部落格原始碼。 重點提醒當環境都設定好以後，日後不管是在哪一台電腦上撰寫文件、發佈文件、備份檔案，都是在 hexo 分支上hexo 分支上hexo 分支上 因為很重要，所以說三次。 初次備份環境建立此動作僅需在第一台撰寫Blog電腦上執行即可，如果日後換新電腦或要在不同台電腦撰寫Blog的話，請參考下面的 更換環境 的操作。 實作步驟 新建 hexo 分支 1$ git branch hexo 將檔案備份至 hexo 分支 1$ git push origin hexo github上設定 hexo 為 默認分支 日後不同電腦clone下來時，不用再特別切換 hexo 分支 確認 配置hexo deploy 的参数 確認 branch參數一定是設定 master 分支,因為日後操作都在 hexo 分支上， 至於要發佈文件的話，就靠指令 hexo d 幫我們建立發佈的文章。 1234deploy:type: gitrepository: https://github.com/用戶名/用戶名.github.io.gitbranch: master 更換環境執行步驟如果是第一次在新電腦的話，請先參考下列動作，先建立Blog的環境。 12345678910111213#1.克隆到本地$ git clone https://github.com/用户名/用户名.github.io.git Kanbooblog#2.切換到blog目錄;$ cd blog目錄#3.確認目前分支是否為hexo，若不是，則切換備份的分支分稱(hexo)$ git checkout Hexo#4.安装各种npm包$ npm install -g hexo-cli$ npm install$ npm install hexo-deployer-git --save 可能遇到的問題1.warning: LF will be replaced by CRLF在 Windows 中廣泛使用來標識一行的結束。而在Linux / UNIX系統中只有換行符。也就是說在Windows中的換行符為CRLF，而在linux的下的換行符為：LF，當執行 git指令 時，系統提示：LF將被轉換成CRLF。 解決方法： 1$ git config --global core.autocrlf false git提示警告：LF將被CRLF替換Hexo Git部署警告”warning： LF will be replaced by CRLF”的去除方法 部落格更新與部署新文章日後在不同電腦上要新增文件的話，就重覆下列的動作即可。 拉取遠端版本庫上的更新內容 1$ git pull 修改部落格配置或撰寫新文章 添加變更並推送 12345678910$ hexo clean# 產生發佈的文件$ hexo g # 發佈至github-master$ hexo d # 備份至github-Hexo$ git add .$ git commit -m "message"$ git push origin hexo 參考網站Hexo利用Github分支在不同电脑上写博客 實現不同電腦上 Hexo 部落格的同步 hexo备份小技巧]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>備份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-環境建置]]></title>
    <url>%2F2017%2F10%2F14%2FHexo-Create%2F</url>
    <content type="text"><![CDATA[前言建立Hexo環境，需要完成的事情有： 建置github空間 安裝 Node.js（如果還沒有的話） 安裝 Hexo 初始化 Hexo，並在目標資料夾建立所需檔案 安裝 hexo-deployer-git (很重要) 在_config.yml 中設定 Git 等資訊 空間：GitHub因為Blog需要上傳至雲端，所以這裡使用github的免費空間。 創建github page倉庫的名字 要和 你的帳號 一樣，如：用戶名.github.io 進入github page項目設置頁面選擇Settings 創建一個默認的頁面直接選擇Launch automatic -&gt; Continue to layouts page generator -&gt; Publish page,其他東西都不用修改。 查看效果至此，你的github page已經創建完成，你可以訪問自己的站點了。如：https://用戶名.github.io/ Hexo安裝安裝 Hexo 相當簡單；然而，在安裝前您必須先檢查下列您的電腦是否已經安裝下列軟體： Node.js Git 若您的電腦已經安裝上述的必備軟體，那麼恭喜您！只需要透過 npm 即可完成 Hexo 的安裝。 1$ npm install -g hexo-cli 建立123$ hexo init yourname # ( 初始化新的 Hexo )$ cd yourname # ( 進入您剛剛建立的 Hexo 資料夾當中 )$ npm install #（ 安裝 Hexo ) yourname 就是指在電腦裡的檔案名稱，可以隨意取，例如「myhexoblog」 設定進入您 Hexo 主目錄下之後，先找到 _config.yml 這個檔案！ 123456title: Kanboo Notes (輸入您的標題)subtitle: 健忘筆記本 （輸入您的至理名言）description:(輸入您的網站描述)author: Kanboo （輸入您的姓名）language: zh-TW （輸入您所使用的語言）timezone: (留空可以使用系統時間！) 同樣 _config.yml 這個檔案底下，找到 deploy 設定github 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/用戶名/用戶名.github.io.git branch: master 用戶名 就是指你自己的github帳號，記得改對，然後按存檔。 撰寫文件及常用指令撰寫文件至於內文採用的 Markdown 格式不難學，只需要記幾個常用的指令，遇到不懂的再上網查就好。 123456789斜體： *斜體* 粗體： **粗體** 粗斜體： ***粗斜體*** 刪除線：~~刪除~~ 引言： &gt; 引言 章節： # 章節 次級章節（以此類推）： ## 次級章節 表格（註1）：|一行|一行|疊| 插入超連結： [超連結文字](網址) 插入外部圖片： ![圖片描述](圖片網址) Markdown文件Markdown CheatsheetMarkdown 寫表格 指令1234567$ hexo new "postName" #新建文章$ hexo clean #清除快取$ hexo generate #生成靜態頁面至public目錄$ hexo server #開啟預覽訪問端口（默認端口4000，'ctrl + c'關閉server）$ hexo deploy #將.deploy目錄部署到GitHub$ hexo help #查看幫助$ hexo version #查看Hexo的版本 指令簡寫 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 更換Blog主題(NexT)主要完成的步驟如下： 安裝 Blog主題(NexT) _config.yml 修改theme:NexT NexT細項功能設定 如果啟用 分類、標籤 的話，並不會自動幫你建立，可參考下列協助產生 1234新建分類、標籤、關於頁面：$ hexo new page ‘categories’$ hexo new page ‘tags’$ hexo new page ‘about’ hexo-generator-category 產生分類頁$ npm install hexo-generator-category --save hexo-generator-tag 產生標籤頁$ npm install hexo-generator-tag --save 參考網站Hexo搭建GitHub博客 系列文章Github Pages + Hexo搭建博客當個部落客McK-Note Hexo 官網NexT 官網]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LiveCoding-切個垂直時間軸]]></title>
    <url>%2F2017%2F10%2F12%2Flivecoding-timeline%2F</url>
    <content type="text"><![CDATA[教學來源Youtube：直播 - 切個垂直時間軸 GitHub 分支：https://goo.gl/VEbWkm 參考版型：https://goo.gl/rqjErS 螢幕吸顏色 Sip：https://goo.gl/Vh6YIo LiveCoding 官方網站：https://goo.gl/weYx5q LiveCoding Youtube 頻道：https://goo.gl/Hyih3u LiveCoding 臉書粉絲專頁：https://goo.gl/yhDg0l 排版小技巧紀錄 切版過程中，可常利用新增「外層的紅框線」，先確認位置是否正確，事後再拿掉。 border: 1px solid rgba(255, 0, 0, .3) CSS之calc可做運算式運算 calc(50% — 10px / 2) z-index z-index 記得搭配 position : relative 、 absolute 使用 z-index 數字越大的在越上面，反之則在越下面 行高 1234H3&#123; height: 45px; line-height: 45px;&#125; 深入 CSS 之 line-height 應用 時間紀錄點頭像(10分開始) 頭像+白色圓外框+黑色的陰影(12分30秒) 時間軸的 垂直中線 位置的偏移(14分30秒開始) 按鈕(載入更多)(28分19秒開始) 時間軸的icon(38分30秒開始) 資訊卡之小箭頭(1時3分30秒) 使用 CSS Arrow Please，再修改部份css 將 資訊卡區塊 開始變 左右 排版(1時7分 開始) 可用的方法有： 針對左右給不同的 class 用 js 控制 用 nth-child 12345678910/* content底下的第一子元素是:&lt;i&gt;第二個是&lt;button&gt;第三個是&lt;div 資訊卡&gt; *//* 從content底下的子元素，從第3個元素開始並每次加2的倍數(奇數) */:nth-child(2n + 3)/* 從content底下的子元素，從第4個元素開始並每次加2的倍數(偶數) */:nth-child(2n + 4) 用 js 動態新增資訊卡(1h 15分 開始) 123456789101112// 在div底下// 新增img HTML$('&lt;div /&gt;').append ($('&lt;img /&gt;')// 新增 info 的Class$('&lt;div /&gt;').addClass ('info')// 新增 data-time 屬性$('&lt;div /&gt;').attr ('data-time', "2017-10-10")// 新增 純文字$('&lt;div /&gt;').text('我是單純顯示的文字') 資訊卡之圖片(1時28分 開始) 123456789101112131415.content &#123; content屬性設定 .img &#123; img屬性設定 +h3 &#123; h3屬性設定-特例 &#125; &#125; .h3 &#123; h3屬性設定 &#125;&#125; 注意： img 底下有加一個 +h3 的設定 另外 img 平行也有一個 h3 的設定 這裡的觀念為 CSS權重，下列有二個 h3 的設定 1234567img+h3&#123; 屬性設定-特例&#125;h3&#123; 屬性設定&#125; 雖然CSS通常都是 權重一樣大 的話，就是 後面 蓋掉 前面 的屬性，但是 img+h3 權重 &gt; h3 權重，所以 img+h3 不會被後面 單一個h3 屬性蓋掉。 CSS權重 改寫 RWD的格式(1時34分30秒) js 塞入html方式 改寫用 object(json格式)(1時50分 開始)]]></content>
      <categories>
        <category>切版</category>
      </categories>
      <tags>
        <tag>排版</tag>
        <tag>LiveCoding</tag>
        <tag>timeline</tag>
        <tag>切版</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tool-gulp]]></title>
    <url>%2F2017%2F10%2F09%2FTool-gulp%2F</url>
    <content type="text"><![CDATA[gulp環境安裝安裝 Global Gulp 環境npm install gulp -g 如果無法安裝 Global Gulp 環境，請用以下並輸入系統密碼sudo npm install gulp -g 有沒有加入 -g 差異在哪裡呢？ 有加入 “-g”：這是安裝全域的套件也就是安裝在目前的電腦上目的是啟用 “gulp” 這個指令 沒有加入：這是 local 套件安裝的指令是裝在目前的專案資料夾內目的是執行 gulp 時可以取用的套件 總結：只有 npm install gulp -g 才會使用到全域的指令，在教學中， -g 也只會出現一次喔～其餘 gulp 套件只會用到 “npm install –save”。 gulp設定 建立 npm 環境 (package.json用於紀錄安裝什麼套件) npm init 建立 專案用的gulp環境 npm install gulp --save-dev 註1：最後面加 –save 代表將安裝紀錄，記在 package.json註2：安裝完後，會產生node_modules 資料夾(裡面會有許多npm的相依套件) 新增一個檔案：gulpfile.js (用於撰寫預執行的任務) 可搭配 Bower 一起建置開發環境。 1234567npm install gulp-sass --save -&gt;給「正式環境」使用npm install gulp-sass --save-dev -&gt;給「開發環境」使用--save-dev是你開發時候依賴的東西，--save是你發布之後還依賴的東西。比如，你寫ES6代碼，如果你想編譯成ES5發布那麼babel就是devDependencies。如果你用了jQuery，由於發布之後還是依賴jQuery，所以是dependencies。 gulp+bower 設定範本已建置完成範本：gulp-setting 當上述都已設定好，只要將設定檔放置新專案資料夾後，依序執行下列指令即可 123bower installnmp installgulp]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS - float排版問題]]></title>
    <url>%2F2017%2F10%2F04%2FCSS-float%2F</url>
    <content type="text"><![CDATA[紀錄一下 float排版問題 問題：在練習Bootstrap3將表單驗證功能加進去，卻遇到畫面「跑版」的問題，目前是查到 「名稱」底下的&lt;div class=&quot;help-block with-errors&quot;&gt;&lt;/div&gt;所導致。 可能原因為 float？ margin？ 問題點：1.單點 「名稱」欄位，就會造成下方欄位跑版。2.若同時有驗證 左右二邊，欄位又有對齊了。 codepen：排版偏移程式碼解決： 如上圖所述，第一個「名稱」腳變長，造成第三個「Email」排不進去被往後推，導致第四個「聯絡電話」也被往後推擠，造成排版歪掉。 解法為 外層用 row 包起來，清除float的浮動(clearfix)。 codepen：修正後程式碼]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>排版</tag>
        <tag>float</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS - Flex]]></title>
    <url>%2F2017%2F09%2F30%2FCSS-Flex%2F</url>
    <content type="text"><![CDATA[常用屬性 概念圖 Flex 外容器屬性：flex-direction：決定 flex 主軸線 方向[ row | row-reverse | column | column-reverse ] justify-content：主要軸線(左右)的對齊[ flex-start | flex-end | center | space-between | space-around ] align-items：交錯軸線(上下)的對齊[ flex-start | flex-end | center | baseline | stretch ] Flex 內元件屬性：align-self：單一個物件的交錯軸對齊[ auto | flex-start | flex-end | center | baseline | stretch ] 參考網站圖解：CSS Flex 屬性一點也不難 CSS Flexbox Layout 學習心得筆記]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Flex</tag>
        <tag>排版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS - 排版重點整理]]></title>
    <url>%2F2017%2F09%2F30%2FCSS-Layout%2F</url>
    <content type="text"><![CDATA[[display屬性]每一個html標籤都有一個預設的display屬性，通常是block(區塊元素)或者是inline(行內元素)。 block：會從新的一行開始且在占據網頁的一整行，具自己個寬高。 inline：無法設定寬高，依照包含的內容先是寬度。 inline-block：可設定寬高，但又不占據一整行。 none：不顯示，可用來跟使用者互動。 [定位] position，設定區塊的座標方式。如下[position] left/top/right/bottom，設定區塊的左/上/右/下的座標。 z-index，設定區塊的重疊時的顯示優先權。 overflow，當內容超出區塊範圍時候的顯示方式。 [position] static:預設，各元素不用設定即是static，遵守網頁規則由左至右，由上至下。 relative:依照原來存在位置進行調整。absolute:會找上一層(找不到再往上找)有誰設定過 position，依照這個父元素進行位置調整，如果都沒有那就依body進行調整。 fixed:依目前看得網頁進行定位。若是要對齊容器內（div）的對位置，採用absolute比較方便。不用特別計算跟父容器的距離。 [float]設定區塊間的流動方式，像是doc當中的文繞圖。 left:往網頁左邊流動。 right:往網頁右邊流動。 clear:both ：清除流動關係。 [區塊] width，設定區塊寬度。width:1080px; height，設定區塊高度。height:500px; float，設定區塊流動方向。float:left; clear，解除區塊流動。 margin，設定區塊外間距離。如下[margin]。 padding，設定區塊內距。同margin。 [margin設定] margin:10px 20px 30px 40px; 依序為上 右 下 左 margin:10xp 20px 30px; 上 右 下 ?–&gt;找對面的來補,所以是找右的設定來補 margin:10px 20px; 依序為上下 左右 margin:10px; 全都一樣 [背景] background-color，背景顏色 background-image，背景圖案 background-attachment，背景是否固定不動 background-repeat，背景是否重複 background-position，背景位置 [邊框] border-color，四邊的顏色 border-style，四邊的樣式 border-width，四邊的寬度 border-top-color，上邊框的顏色，top可以置換成為right、bottom、left。 border-top-style，上邊框的樣式，top可以置換成為right、bottom、left。 border-top-width，上邊框的寬度，top可以置換成為right、bottom、left。 border-top，上邊框的顏色、樣式與寬度。top可以置換成為right、bottom、left。 border，寬度、樣式、顏色。 [文字] font-family，設定字型 font-size，字體大小 color，字體顏色 line-height，文字行高 font-weight，文字粗體 text-decoration，文字底線 word-spacing，間距 letter-spacing，間距 text-aling，水平對齊方向 text-indent，字首縮排]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>排版</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown常用寫法(置頂)]]></title>
    <url>%2F2017%2F09%2F30%2FMarkDownWrite%2F</url>
    <content type="text"><![CDATA[將常用的 MarkDown 紀錄在這， Ctrl + C 、 Ctrl + V 比較方便。 文字加顏色藍色字 1&lt;font color=&quot;blue&quot;&gt;藍色字&lt;/font&gt; 紅色的字 1&lt;font color=&quot;red&quot;&gt;紅色的字&lt;/font&gt; 20px 的字 1&lt;font style=&quot;color:#f90;font-size:20px;&quot;&gt;20px的字&lt;/font&gt; MARKDOWN/HTML 常用語法小結 文字增加背景色塊站点配置文件 主题配置文件 站点配置文件 主题配置文件 1234&lt;span id="inline-blue"&gt;站点配置文件&lt;/span&gt;&lt;span id="inline-purple"&gt;主题配置文件&lt;/span&gt;&lt;span id="inline-yellow"&gt;站点配置文件&lt;/span&gt;&lt;span id="inline-green"&gt;主题配置文件&lt;/span&gt; 自定義樣式下列 自定義樣式，參考 超深度优化 文本置中引用我不是一個偉大的程式設計師,我只是一個具有良好習慣的優秀程式設計師。 123&#123;% cq %&#125;我不是一個偉大的程式設計師,我只是一個具有良好習慣的優秀程式設計師。&#123;% endcq %&#125; 数字塊1.左邊是效果。2.我是第二行。 客制 CSS 文件位置：~/blog/themes/next/source/css/\_custom/custom.styl1234&lt;span id="inline-toc"&gt;1.&lt;/span&gt;&lt;span id="inline-toc"&gt;2.&lt;/span&gt;` label標籤default 12&#123;% label default@default %&#125;` primary 1&#123;% label primary@primary %&#125; success 1&#123;% label success@success %&#125; info 1&#123;% label info@info %&#125; warning 1&#123;% label warning@warning %&#125; danger 1&#123;% label danger@danger %&#125; note 標籤default no-icon 1&lt;div class="note default no-icon"&gt;default no-icon&lt;/div&gt; default 1&lt;div class="note default"&gt;default&lt;/div&gt; primary 1&lt;div class="note primary"&gt;primary&lt;/div&gt; success 1&lt;div class="note success"&gt;success&lt;/div&gt; info 1&lt;div class="note info"&gt;info&lt;/div&gt; warning 1&lt;div class="note warning"&gt;warning&lt;/div&gt; danger 1&lt;div class="note danger"&gt;danger&lt;/div&gt; 引用内容 客制 CSS 文件位置：~/blog/themes/next/source/css/\_custom/custom.styl12&lt;blockquote class="question"&gt;内容&lt;/blockquote&gt; 程式碼行內height: 50px; 1`height: 50px;` 區段區段寫法123456```[language] [title] [url] [link-text]- [language] 是代碼語言的名稱，用來設置代碼塊顏色高亮，非必須；- [title] 是頂部左邊的說明，非必須；- [url] 是頂部右邊的超鏈接地址，非必須；- [link text] 如它的字面意思，超鏈接的名稱，非必須。``` 上述 4 項應該是根據 空格 來分隔，而不是 []，故請不要加 []。除非如果你想寫後面兩個，但不想寫前面兩個，那麼就必須加 [] 了，要這樣寫： [] [] [url] [link text]。 MarkDown 寫法： CSS12345678``` CSS.container &#123; max-width: 960px; margin: 0 auto; /* 起手式 */ margin-top: 10px;`&#125;``` js12345678910111213``` js.container &#123; function checkList(e) &#123; var num = e.target.dataset.num; // console.log(e.target.nodeName); if (e.target.nodeName !== &apos;LI&apos;) &#123; return &#125;; country.splice(num, 1); updateList(); &#125;&#125;``` 可支援的語法： 連結 插入圖片 內部圖片 1&#123;% asset_img logo.png logo %&#125; 外部圖片 1![Mario](https://goo.gl/2Dty9K) 文字超連結 More info: Writing Google 連結：Google 123More info: [Writing](https://hexo.io/docs/writing.html)Google 連結：[Google](https://www.google.com.tw/) 項目標籤 符號 序列 1 序列 2 序列 3 123- 序列 1- 序列 2- 序列 3 Check 序列 1 序列 2 序列 3 序列 4 1234- [ ] 序列 1- [ ] 序列 2- [ ] 序列 3- [ ] 序列 4 數字 序列 1 序列 2 序列 3 序列 4 12341. 序列 12. 序列 23. 序列 34. 序列 4 重點標示Strong emphasis, aka bold, with asterisks or underscores. Combined emphasis with asterisks and underscores. Strikethrough uses two tildes. Scratch this. 12345Strong emphasis, aka bold, with **asterisks** or **underscores**.Combined emphasis with **asterisks and _underscores_**.Strikethrough uses two tildes. ~~Scratch this.~~]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
</search>
