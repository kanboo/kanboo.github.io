<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS30-04-Array-Cardio-Day-1]]></title>
    <url>%2F2018%2F02%2F16%2FJS30-04-Array-Cardio-Day-1%2F</url>
    <content type="text"><![CDATA[練習運用 Array 的各種函式 目標 共提供四組資料 inventors：first(名)、last(姓) 、year(出生日期)、passed(死亡日期) wiki網站的html ：網址連結 people：逗點分隔的姓名(firstName, lastName) data：提供的一組包含重覆資料的陣列 根據不同需求條件篩選出正確的資料 練習題目inventors 的資料： 篩選出於 1500~1599 年間出生的 inventor (year in 1500-1599) 將 inventors 的 firstname 與 lastname 組合成一個陣列 將 inventors 依據「生日」由大至小排序 加總所有 inventor 的年齡 將 inventors 依據「年齡」由大至小排序 wiki網站的html：網址連結 列出wiki中巴黎所有包含’de’的路名 people 的資料： 依據lastName排序所有people的資料 data 的資料： 分別計算data內每個種類的數量 成品 [DEMO] | [GitHub] inventors 題目inventors資料1234567891011121314const inventors = [ &#123; first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 &#125;, &#123; first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 &#125;, &#123; first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 &#125;, &#123; first: 'Marie', last: 'Curie', year: 1867, passed: 1934 &#125;, &#123; first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 &#125;, &#123; first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 &#125;, &#123; first: 'Max', last: 'Planck', year: 1858, passed: 1947 &#125;, &#123; first: 'Katherine', last: 'Blodgett', year: 1898, passed: 1979 &#125;, &#123; first: 'Ada', last: 'Lovelace', year: 1815, passed: 1852 &#125;, &#123; first: 'Sarah E.', last: 'Goode', year: 1855, passed: 1905 &#125;, &#123; first: 'Lise', last: 'Meitner', year: 1878, passed: 1968 &#125;, &#123; first: 'Hanna', last: 'Hammarström', year: 1829, passed: 1909 &#125;]; Q：篩選出於 1500~1599 年間出生的 inventor (year in 1500-1599) A：透過 filter 篩選出符合條件的資料，最終回傳一個新陣列 filter1234567891011121314// Array.prototype.filter()// 1. Filter the list of inventors for those who were born in the 1500's/* 解法 */const bornArr = inventors.filter(function(inventor)&#123; if (inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600)&#123; return true; &#125;&#125;)/* 簡化語法 */const bornArr = inventors.filter( inventor =&gt; inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600)console.table(bornArr); Q：將 inventors 的 firstname 與 lastname 組合成一個陣列 A：透過 map 將原始資料加工後，最終回傳一個新陣列 map123456789101112131415// Array.prototype.map()// 2. Give us an array of the inventors' first and last names/* 解法 */const newInventors = inventors.map(function(inventor)&#123; return inventor.first + ' ' + inventor.last&#125;)/* 簡化語法 */const newInventors = inventors.map( inventor =&gt; inventor.first + ' ' + inventor.last);/* 簡化語法(Template String) */const newInventors = inventors.map( inventor =&gt; `$&#123;inventor.first&#125; $&#123;inventor.last&#125;`); //Template Stringconsole.log(newInventors); Q：將 inventors 依據「生日」由大至小排序 A： 依照「生日」大小重新排序(return值： -1 排前面 , 1 排後面) sort12345678910111213141516// Array.prototype.sort()// 3. Sort the inventors by birthdate, oldest to youngest/* 解法 */const sortInventors = inventors.sort(function(a, b)&#123; if ( a.year &gt; b.year)&#123; return 1 &#125;else&#123; return -1 &#125;&#125;)/* 簡化語法 */const sortInventors = inventors.sort( (a, b) =&gt; a.year &gt; b.year ? 1 : -1 )console.table(sortInventors) Q：加總所有 inventor 的年齡 A： 籍由 reduce 加總所有的年齡 reduce123456789101112// Array.prototype.reduce()// 4. How many years did all the inventors live?/* 解法 */const totalYears = inventors.reduce(function(total, inventor)&#123; return total + (inventor.passed - inventor.year)&#125;, 0) /* 簡化語法 */const totalYears = inventors.reduce( (total, inventor) =&gt; total + (inventor.passed - inventor.year) , 0)console.log(totalYears); Q：將 inventors 依據「年齡」由大至小排序 A：依照「年齡」大小重新排序(return值： -1 排前面 , 1 排後面) 123456789101112131415161718192021222324// 5. Sort the inventors by years lived/* 解法 */const sortYearsLived = inventors.sort(function(a, b)&#123; const aYearCount = a.passed - a.year; const bYearCount = b.passed - b.year; if ( aYearCount &gt; bYearCount) &#123; return -1 &#125;else&#123; return 1 &#125;&#125;)/* 簡化語法 */const sortYearsLived = inventors.sort( (a, b) =&gt; &#123; const aYearCount = a.passed - a.year; const bYearCount = b.passed - b.year; return aYearCount &gt; bYearCount ? -1 : 1&#125;)console.table(sortYearsLived); wiki-html 題目Q：列出wiki中巴黎所有包含’de’的路名 A：練習 展開運算子(Spread Operator)、map()、filter()、includes() 搭配使用 method組合運用123456789101112131415// 6. create a list of Boulevards in Paris that contain 'de' anywhere in the name// https://en.wikipedia.org/wiki/Category:Boulevards_in_Paris/* 解法 */const category = document.querySelector('.mw-category');//將 nodeList 轉為 Array型態const Links = [...category.querySelectorAll('a')]; //展開運算子(Spread Operator)//可以執行完 map 後，緊接著執行 filterconst de = Links .map( link =&gt; link.textContent) .filter( tName =&gt; tName.includes('de'))console.log(de); people 題目Q：依據 lastName 排序所有people的資料 A：練習 解構賦值(Destructuring Assignment)、sort() 運用 123456789101112131415161718192021222324252627// 7. sort Exercise// Sort the people alphabetically by last nameconst people = ['Beck, Glenn', 'Becker, Carl', 'Beckett, Samuel', 'Beddoes, Mick', 'Beecher, Henry', 'Beethoven, Ludwig', 'Begin, Menachem', 'Belloc, Hilaire', 'Bellow, Saul', 'Benchley, Robert', 'Benenson, Peter', 'Ben-Gurion, David', 'Benjamin, Walter', 'Benn, Tony', 'Bennington, Chester', 'Benson, Leana', 'Bent, Silas', 'Bentsen, Lloyd', 'Berger, Ric', 'Bergman, Ingmar', 'Berio, Luciano', 'Berle, Milton', 'Berlin, Irving', 'Berne, Eric', 'Bernhard, Sandra', 'Berra, Yogi', 'Berry, Halle', 'Berry, Wendell', 'Bethea, Erin', 'Bevan, Aneurin', 'Bevel, Ken', 'Biden, Joseph', 'Bierce, Ambrose', 'Biko, Steve', 'Billings, Josh', 'Biondo, Frank', 'Birrell, Augustine', 'Black, Elk', 'Blair, Robert', 'Blair, Tony', 'Blake, William'];/* 解法 */const sortPeople = people.sort(function(a, b)&#123; const [aLast, aFirst] = a.split(', '); //解構賦值(Destructuring Assignment) const [bLast, bFirst] = b.split(', '); //解構賦值(Destructuring Assignment) if(aLast &gt; bLast)&#123; return 1 &#125;else&#123; return -1 &#125;&#125;)/* 簡化語法 */const sortPeople = people.sort( (a, b) =&gt; &#123; const [aLast, aFirst] = a.split(', '); //解構賦值(Destructuring Assignment) const [bLast, bFirst] = b.split(', '); //解構賦值(Destructuring Assignment) return aLast &gt; bLast ? 1 : -1&#125;)console.log(sortPeople); data 題目Q：分別計算data內每個種類的數量 A：練習 reduce() 運用 12345678910111213141516// 8. Reduce Exercise// Sum up the instances of each of theseconst data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck' ];/* 解法 */const dataCount = data.reduce( (counts, item) =&gt; &#123; if(!counts[item])&#123; counts[item] = 0; &#125; counts[item] += 1; return counts;&#125;, &#123;&#125;)console.log(dataCount)]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-03-CSS-Variables]]></title>
    <url>%2F2018%2F02%2F15%2FJS30-03-CSS-Variables%2F</url>
    <content type="text"><![CDATA[利用 CSS變數 與 JS 即時更新圖片的 內距、邊框色、模糊 效果 目標 使用 CSS變數 功能 透過 JS 更改 CSS變數值，達到即時更新 內距、邊框色、模糊 的效果 實踐步驟 在 CSS 的 :root 宣告 CSS變數 宣告方法：使用兩個-符號，代表「變數」，如：--spacing 使用方法：使用var()代表「使用變數」，如：var(--spacing) 分別監聽(change、mousemove)三個 input 的值 利用 dataset 取得自定義的資料，如：this.dataset.sizing 透過 document.documentElement.style.setProperty(&#39;--base&#39;, &#39;#fff&#39;); 更改CSS的變數 成品 [DEMO] | [GitHub] CSS學習紀錄使用 CSS的變數 功能，不過在 IE 上，好像還不支援。 CSS變數說明1234567891011121314151617/* 在CSS 的 :root(全局)設定 變數 */:root &#123; --base: #ffc600; --spacing: 50px; --blur: 10px;&#125;/* 使用CSS變數方法：var(變數名稱) */img &#123; padding: var(--spacing); background: var(--base); filter: blur(var(--blur)); /* CSS濾鏡效果：模糊 */&#125;.hl &#123; color: var(--base);&#125; :root 偽元素(全局):root 這個偽元素是文檔的根元素，等同於 &lt;html&gt; 標籤，所以常用於聲明全局的CSS變量： 設定變數(全局)123：root &#123; --color：#fff ;&#125; 在CSS style要使用時，用 var(變數名稱)，如下： 在CSS使用變數123img &#123; background： var(--color);&#125; 若是要在 JS 使用的話，語法如下： 用JS更改CSS變數12// ：root = 文檔的根元素 = &lt;html&gt; = document.documentElementdocument.documentElement.style.setProperty('--color', '#000'); CSS Variables filter 濾鏡CSS3的濾鏡功能，其中 blur 是高斯模糊，參數越高越模糊 MDN-filter JS學習紀錄dataset利用 dataset 可取得自定義的資料，另外也可使用 getAttribute 取得資料。 HTML1&lt;input id="blur" type="range" name="blur" value="10" data-sizing="px"&gt; JS取得dataset123456//方法1document.querySelector('#blur').dataset.sizing // 輸出：pxdocument.querySelector('#blur').dataset[sizing] // 輸出：px//方法2document.querySelector('#blur').getAttribute('data-sizing'); // 輸出：px MDN-dataset style.setProperty下列三種方法，皆可達到更改CSS的效果，不過實務上用方法2，會比較容易帶 參數 及 可讀性 較佳。 12345678910const DOM = document.querySelector('img');//方法1DOM.setAttribute("style", `padding: 10px`)//方法2DOM.style.setProperty('padding', '10px');//方法3DOM.style.padding = '10px'; MDN-setProperty]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-02-JS-and-CSS-Clock]]></title>
    <url>%2F2018%2F02%2F14%2FJS30-02-JS-and-CSS-Clock%2F</url>
    <content type="text"><![CDATA[利用 JS 與 CSS 搭配作出時鐘效果 目標 顯示目前時間 利用 JS 與 CSS 搭配作出時鐘效果 實踐步驟 先調整時鐘的 CSS樣式 修改前： 新增CSS修改語法： 1234transform: rotate(90deg); /* 將 時、分、秒針 從 45分 旋轉至 12點 方向 */transform-origin: 100% 50%; /* 將旋轉的原點移位 */transition: all 0.05s cubic-bezier(0, 2.95, 1, 1); /* 讓秒針有跳動的效果 */border-radius: 50%; /* 原先是 長方形 ，修改成 圓角 ，比較像 時針 */ 修改後： 取得目前時間，並每秒更新一次 利用 setInterval(setDate, 1000) 每秒更新 使用 new Date() 取得目前 時、分、秒 一個圓共 360deg，分別依照 時、分、秒 計算出各自的角度 秒針：(360 / 60) * seconds + 90 分針：(360 / 60) * seconds + 90 時針：(360 / 12) * seconds + 90 補充說明：最後有加 90 是因原先都指向45分的位置，為了指向12點方向，所以有先用CSS旋轉90度 rotate(90deg)。 最後用 JS 透過 element.style 修改 時、分、秒 的角度 element.style.tranform = &quot;roate( 角度 )&quot; 成品 [DEMO] | [GitHub] JS學習紀錄setInterval()如果需要一直持續循環作動，使用 setInterval，例如網頁上每一秒鐘就更新一次時間。 語法：setInterval(callback, time) 12//每秒刷新時間setInterval(setDate,1000); Date()取得時間的函數 12345const nowDate = new Date();nowDate.getSeconds(); //取得當前秒nowDate.getMinutes(); //取得當前分鐘nowDate.getHours(); //取得當前小時 element.style一開始想說要改 CSS 屬性，就很直覺的使用 第一種 方法，學習過程中，得知 第二種 方法也行。 修改CSS：第一種1secondHand.setAttribute("style", `transform: rotate($&#123;secondDegrees&#125;deg)`) 修改CSS：第二種1secondHand.style.transform = `rotate($&#123;secondDegrees&#125;deg)` 延伸：transform:rotate的彈跳問題當秒針旋轉一圈之後，要開始旋轉第二圈時，角度的計算變化會是 444°→90°→96°，重點就在 444° 變成 90° 時，本來rotate 都是順時針旋轉，但 444°→90° 那一瞬間會是 逆時針 轉回去，而造成秒針跳動有點怪異，所以解決方式如下 在角度計算 444°→90° 重新循環時，將 transition 屬性關掉，由於距離短，時間短，將逆時針迴旋的過程瞬間完成。 修正秒針跳動的效果1234567891011121314const nowDate = new Date();//秒針const seconds = nowDate.getSeconds();const secondDegrees = (360 / 60) * seconds + 90;// 修正秒針跳動的效果if(secondDegrees === 90)&#123; secondHand.style.transition = 'all 0s';&#125;else&#123; secondHand.style.transition = 'all 0.05s cubic-bezier(0, 2.95, 1, 1)';&#125;secondHand.style.transform = `rotate($&#123;secondDegrees&#125;deg)` 延伸問題參考：soyaine、GuaHsu]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-01-JavaScript-Drum-Kit]]></title>
    <url>%2F2018%2F02%2F13%2FJS30-01-JavaScript-Drum-Kit%2F</url>
    <content type="text"><![CDATA[按下鍵盤時，觸發聲音及特效 目標 按下鍵盤時，播放聲音、顯示CSS效果 播放完畢後，移除CSS效果 實踐步驟 先監聽 鍵盤 的 keydown Event 利用 e.keyCode 取得符合的 audio標籤 和 div標籤 audio 標籤 =&gt; 播放 聲音 div 標籤 =&gt; 顯示 CSS效果 監聽 CSS 的 transitionend Event (transitionend 事件會在 transition 结束后觸發) e.propertyName !== &quot;transform&quot; 僅針對 transform 繼續做事，不是則停止 若為 transform，則移除 CSS效果 成品 [DEMO] | [GitHub] JS學習紀錄HTML5標籤 HTMLMediaElement透過 js 取得 HTMLMediaElement 元素，來進行影音的播放。 HTML1&lt;audio data-key="65" src="sounds/clap.wav"&gt;&lt;/audio&gt; JS12345//取得 HTMLMediaElement 元素const audio = document.querySelector(`audio[data-key="$&#123;keyCode&#125;"]`);audio.currentTime = 0 ; //設定音效從 0 秒開始audio.play(); // 播放音效 MDN-HTMLMediaElementHTMLMediaElement.playHTMLMediaElement.currentTime DOM元素 Element.classList透過 classList 新增、移除、切換 CSS屬性，就像jQuery的 addClass、removeClass 一樣。 HTML1234&lt;div data-key="65" class="key"&gt; &lt;kbd&gt;A&lt;/kbd&gt; &lt;span class="sound"&gt;clap&lt;/span&gt;&lt;/div&gt; JS123456//取得 DOM 元素const key = document.querySelector(`.key[data-key="$&#123;keyCode&#125;"]`);key.classList.add('playing'); //新增CSS屬性key.classList.remove('playing'); //移除CSS屬性key.classList.toggle('playing'); //切換CSS屬性 Element.classList DOM元素 NodeList使用 querySelectorAll 取得的DOM，返回的結果是 NodeList 型態，非 Array 型態，所以不能使用 Array的method，若要使用Array的method的話，就需轉換成Array型態。 HTML123456789101112&lt;div data-key="65" class="key"&gt; &lt;kbd&gt;A&lt;/kbd&gt; &lt;span class="sound"&gt;clap&lt;/span&gt;&lt;/div&gt;&lt;div data-key="83" class="key"&gt; &lt;kbd&gt;S&lt;/kbd&gt; &lt;span class="sound"&gt;hihat&lt;/span&gt;&lt;/div&gt;&lt;div data-key="68" class="key"&gt; &lt;kbd&gt;D&lt;/kbd&gt; &lt;span class="sound"&gt;kick&lt;/span&gt;&lt;/div&gt; querySelectorAll 取得 DOM元素後，使用 NodeList.prototype.forEach() 的 method，有可能會在部份瀏覽器不支援。 JS12345// 取得 DOM 元素 =&gt; NodeList 型態const keys = document.querySelectorAll('.key'); // NodeList.prototype.forEach() =&gt; IE不支援keys.forEach(key =&gt; key.addEventListener('transitionend',removeTransition)) 可藉由下列方法，將 NodeList 轉換 Array型態，支援度較高。 NodeList 轉換 Array型態123456789// 第一種方法：Array.from()const keys = Array.from(document.querySelectorAll('.key')); // 第二種方法：... 展開運算子( Spread Operator )const keys = [...document.querySelectorAll('.key'))]; // 轉換成 Array型態 後，就可以使用 forEach()、map(), concat() …等methodkeys.forEach(key =&gt; key.addEventListener('transitionend',removeTransition)) NodeList.prototype.forEach()Array.from()… 展開運算子(Spread Operator) CSS監聽事件 transitionend透過 CSS transitionend Event ，當 transition 效果結束後，就會觸發此事件， JS1234567891011function removeTransition(e)&#123; console.log(e); //有時會多個 CSS效果 一同執行，參考下圖1 console.log(e.propertyName); //可透過 event.propertyName 取得想要監聽的CSS屬性，參考下圖2 if(e.propertyName !== "transform") return; // 僅針對 transform，不是則停止 /* your code */&#125;const keys = Array.from(document.querySelectorAll('.key')); keys.forEach(key =&gt; key.addEventListener('transitionend',removeTransition)) // transitionend 事件會在 CSS transition 结束后觸發 圖1：同時多個 CSS效果 圖2：event.propertyName 取得 CSS屬性名稱 transitionendMDN-Event reference 一般函式的this(作為 DOM 事件偵聽函式 → 該 DOM)在 removeTransition function裡面有使用 this 去移除CSS屬性，該如何判斷這個 this 是指向誰呢？ 答案是：一般函式的this(作為 DOM 事件偵聽函式 → 該 DOM) this?123456789function removeTransition(e)&#123; if(e.propertyName !== "transform") return; // 僅針對 transform，不是則停止 // 一般函式的this(作為 DOM 事件偵聽函式 → 該 DOM) this.classList.remove('playing'); //移除CSS屬性&#125;const keys = Array.from(document.querySelectorAll('.key')); keys.forEach(key =&gt; key.addEventListener('transitionend',removeTransition)) JS-一次搞懂 JavaScript 的 this]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-陣列(Array)]]></title>
    <url>%2F2018%2F02%2F02%2FJS-Array%2F</url>
    <content type="text"><![CDATA[Array複習 與 ES6新語法 push、pop、shift、unshift 差異 push：加到陣列末端 pop：移除最末端 shift：移除最前端 unshift：加到陣列前端 1234567891011121314151617var home = ['爸爸', '媽媽'];// push：加到陣列末端var newLength = home.push('老大');console.log(home); // ["爸爸", "媽媽", "老大"]// pop：移除最末端var last = home.pop();console.log(home); // ["爸爸", "媽媽"]// shift：移除最前端var first = home.shift();console.log(home); // ["媽媽"]// unshift：加到陣列前端var newLength = home.unshift('小花');console.log(home); // ["小花", "媽媽"] 排序與反轉 sort與reversesortarr.sort([compareFunction]) 如果 compareFunction 沒有被應用, 元素將被轉換為字串並以Unicode碼位來比較並排序。特別一提，在數值排序中，9 會在 80 前面，但因為數字被轉換成字串，在Unicode順序中 “80” 會在 “9” 前面。 字串比較1234//大寫英文 Unicode 排在 小寫英文 前面var stringArray = ['blue', 'Humpback', 'Beluga', 'alice'];console.log(stringArray.sort()); //["Beluga", "Humpback", "alice", "blue"] 數字比較1234567891011// 數字被轉換成字串var numbers_01 = [1, 30, 4, 21];numbers_01.sort();console.log(numbers_01); // [1, 21, 30, 4]// 用 compareFunction比較，就不會被轉成「字串」var numbers_02 = [1, 30, 4, 21];numbers_02.sort(function(a, b) &#123; return a - b;&#125;);console.log(numbers_02); // [1, 4, 21, 30] reverse將整個陣列中的成員順序反轉。 1234const home = ["0.爸爸", "1.媽媽", "2.老大", "3.老二", "4.老么"];home.reverse();console.log(home); // ["4.老么", "3.老二", "2.老大", "1.媽媽", "0.爸爸"] 另一個情況是字串中的字元，如果要進行反轉的話，並沒有字串中的reverse方法，要用這個陣列的reverse方法加上字串與陣列的互相轉換的split與join方法，可以使用以下的函式: 字串反轉12345function reverseString(str) &#123; return str.split('').reverse().join('');&#125;console.log(reverseString("ABCDEFG")); // "GFEDCBA" slicearr.slice([begin[, end]]) 回傳一個新陣列，為原陣列選擇之 begin 至 end（不含 end）部分的淺拷貝（shallow copy）。 1234567891011121314const home = ["0.爸爸", "1.媽媽", "2.老大", "3.老二", "4.老么"];// begin為空或0，就是全部複製console.log(home.slice()); //["0.爸爸", "1.媽媽", "2.老大", "3.老二", "4.老么"]console.log(home.slice(0)); //["0.爸爸", "1.媽媽", "2.老大", "3.老二", "4.老么"]// 僅 begin 參數console.log(home.slice(2)); //["2.老大", "3.老二", "4.老么"]// 加 end 參數，擷取到 end 的 index「前」console.log(home.slice(2, 3)); //["2.老大"]// 加 end 參數，end index值 超過原陣列個數，沒有關係console.log(home.slice(2, 9999)); //["2.老大", "3.老二", "4.老么"] splicearray.splice(start[, deleteCount[, item1[, item2[, …]]]]) 可刪除既有元素並／或加入新元素來改變一個陣列的內容(會改變原陣列值)。 12345678910111213141516const home = ["0.爸爸", "1.媽媽", "2.老大", "3.老二", "4.老么"];// 會改變原陣例值home.splice(2, 0, '小花'); //在索引 2 開始，插入新增字串 '小花'console.log(home); // ["0.爸爸", "1.媽媽", "小花", "2.老大", "3.老二", "4.老么"]home.splice(2, 1); //在索引 2 開始，刪除 1個 元素console.log(home); // ["0.爸爸", "1.媽媽", "2.老大", "3.老二", "4.老么"]home.splice(2, 3, '巧虎', '琪琪', '桃樂比'); //在索引 2 開始，刪除 3個 元素後，再新增 3個 新元素console.log(home); // ["0.爸爸", "1.媽媽", "巧虎", "琪琪", "桃樂比"]// ES6 展開運算子( Spread Operator )const addArr = ['巧虎', '琪琪', '桃樂比'];home.splice(2, 3, ...addArr); //在索引 2 開始，刪除 3個 元素後，再新增 3個 新元素console.log(home); // ["0.爸爸", "1.媽媽", "巧虎", "琪琪", "桃樂比"] 淺拷貝作法1. ES6 展開運算子( Spread Operator ) 12const aArray = [1, 2, 3];const copyArray = [...aArray]; 它也可以用來組合陣列 12const aArray = [1, 2, 3];const bArray = [5, 6, ...aArray, 8, 9]; // [5, 6, 1, 2, 3, 8, 9] 2. slice 1234const oldArray = [1, 2, 3];const newArray = oldArray.slice(0); // [1, 2, 3]const newArray = oldArray.slice(); // [1, 2, 3] 3. concat 12const oldArray = [1, 2, 3];const newArray = [].concat(oldArray); // [1, 2, 3] ES6- find 與 findIndex find =&gt; 回傳 value findIndex =&gt; 回傳 index 基本寫法123456789101112131415const aArray = [1, 3, 5, 7, 10, 22];// findconst bValue = aArray.find(function (value, index, array)&#123; return value &gt; 6&#125;)console.log(bValue); //回傳第一個滿足條件的「value」：7// findIndexconst cIndex = aArray.findIndex(function (value, index, array)&#123; return value &gt; 6&#125;)console.log(cIndex); //回傳第一個滿足條件的「index」：3 進階應用不過當會用到 find 或 findIndex 時，表示要尋找的條件通常比較複雜一點，才能顯現他們比 indexOf 強大之處。 範例1 從陣列中找出符合條件的 物件 123456789101112131415var inventory = [ &#123;name: 'apples', quantity: 2&#125;, &#123;name: 'bananas', quantity: 0&#125;, &#123;name: 'cherries', quantity: 5&#125;];function isCherries(fruit) &#123; return fruit.name === 'cherries';&#125;// find 回傳第一個滿足條件的「value」console.log(inventory.find(isCherries)); // &#123; name: 'cherries', quantity: 5 &#125;// findIndex 回傳第一個滿足條件的「index」console.log(inventory.findIndex(isCherries)); // 2 範例2 找出質數 1234567891011121314151617function isPrime(element, index, array) &#123; var start = 2; while (start &lt;= Math.sqrt(element)) &#123; if (element % start++ &lt; 1) &#123; return false; &#125; &#125; return element &gt; 1;&#125;// find 回傳第一個滿足條件的「value」console.log([4, 6, 8, 12].find(isPrime)); // undefined, not foundconsole.log([4, 5, 8, 12].find(isPrime)); // 5// findIndex 回傳第一個滿足條件的「index」console.log([4, 6, 8, 12].findIndex(isPrime)); // -1, not foundconsole.log([4, 6, 7, 12].findIndex(isPrime)); // 2 ES6-includes在陣列中尋找是否包含這個值，如果有就會回傳 true，沒有則會回傳false。 12345678// 數字const numArr = [1, 2, 3];console.log(numArr.includes(2)); // true// 字串const strArr = ['老大', '老二', '老么'];console.log(strArr.includes('老二')); // trueconsole.log(strArr.includes('小花')); // false 參考來源MDN-ArrayES6 陣列語法糖ES6學習-陣列数组的扩展]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Array</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-for...in與for...of的差別]]></title>
    <url>%2F2018%2F01%2F30%2FJS-for-of-forin%2F</url>
    <content type="text"><![CDATA[for…of與for…in的差別 總結 建議：在迭代物件屬性時，使用 for...in；在迭代陣列時，使用 for...of。 for...in 輸出的是屬性名稱(key)，for...of 輸出的是值(value) for...of 是 ES6 的新語法。修復了ES5 for…in 的不足 for...of 不能迭代物件，需要透過和 Object.keys() 搭配使用 範例說明參考下列三個範例變化與說明，即可了解 for...of 與 for...in 之間的差別 範例1 單純迭代陣列的話，for...in 輸出的是屬性名稱(key)，for...of 輸出的是值(value) 1234567891011let iterable = [3, 5, 7];// 回傳「key」for (let i in iterable) &#123; console.log(i); // "0", "1", "2"&#125;// 回傳「value」for (let i of iterable) &#123; console.log(i); // 3, 5, 7&#125; 範例2 再來我們在原本的陣列，新增一個屬性 foo，可看到 for...in 有將此屬性 foo 也輸出。 新增陣列的屬性123456789101112let iterable = [3, 5, 7];iterable.foo = 'hello'; //新增foo屬性名稱// 回傳「key」，且會讀取到陣列新增的屬性名稱for (let i in iterable) &#123; console.log(i); // "0", "1", "2", "foo"&#125;// 回傳「value」for (let i of iterable) &#123; console.log(i); // 3, 5, 7&#125; 範例3 再來我們這次在物件和陣列的原型鍊上，分別各新增function，一樣可看到 for...in 也將原型鋉上的function名稱也輸出了。 在 原型鍊上 新增function12345678910111213141516// 在 原型鍊上 新增functionObject.prototype.objCustom = function()&#123;&#125;; //物件 原型鋉Array.prototype.arrCustom = function()&#123;&#125;; //陣列 原型鋉let iterable = [3, 5, 7];iterable.foo = 'hello';// 回傳「key」，且同時會讀取到 物件、陣列 原型鍊上的functionfor (let i in iterable) &#123; console.log(i); // "0", "1", "2", "foo", "arrCustom", "objCustom"&#125;// 回傳「值」for (let i of iterable) &#123; console.log(i); // 3, 5, 7&#125; 由上面三個案例來看，如果只是想單純的迭代取出陣列值的話，建議使用 for...of 會比較好，不過注意此語法為 ES6 新語法。 for..of 迭代 物件(object)如果想用 for...of 來遍歷物件的屬性的話，可以通過和 Object.keys() 搭配使用，先取得物件的所有key的數組，然後再遍歷。 123456789101112131415161718var student=&#123; name:'kanboo', age:16, locate:&#123; country:'tw', city:'taipei', school:'CCC' &#125;&#125;for(var key of Object.keys(student))&#123; //使用Object.keys()方法取得物件的Key的陣列 console.log(key+": "+student[key]);&#125;// "name: kanboo"// "age: 16"// "locate: [object Object]" 參考來源MDN-for…ofjavascript-for of和for in的區別？]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>for of</tag>
        <tag>for in</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-解構賦值(Destructuring Assignment)]]></title>
    <url>%2F2018%2F01%2F28%2FES6-DestructuringAssignment%2F</url>
    <content type="text"><![CDATA[解構賦值(Destructuring Assignment) 基本說明簡單來說，可以想像是鏡子的概念，將右方的資料往左邊送，然後會一個位置對一個值。 陣列 ==對應=&gt; 順序的索引值 物件 ==對應=&gt; 物件的屬性名稱 陣列解構賦值基本用法新舊寫法12345678910//ES5let numbers = [1, 2, 3];let a = numbers[0];let b = numbers[1];let c = numbers[2];console.log(a,b,c); // 1, 2, 3//ES6let [a, b, c] = [1, 2, 3];console.log(a, b, c); // 1, 2, 3 陣列各種情境當變數的數量多於賦予的值時，多出來的那個變數會被賦予 undefined 的值（d = undefined）： 變數 多於 所給的值123// 變數 多於 所給的值let [a, b, c, d] = [1, 2, 3];console.log(a, b, c, d); // 1, 2, 3, undefined 當輸入的變數少於所給的值的時候，只有被指定到的變數會有值，少掉的變數可以直接空過去： 當變數 少於 所給的值1234// 當變數 少於 所給的值let [a, , c] = [1,2,3];console.log(a, c); // 1, 3 至於陣例傳值是有順序性，在這個範例中直接將右邊的變數交換到左邊，可以看到是同時交換變數，所以在互換變數值時是非常方便的。 交換值123// 交換值const a = 1, b = 2;[b, a] = [a, b] //a=2, b=1 遇到字串則會將字串拆解成一個一個字元，賦予到左方的變數上。 字串12let str = 'kanboo';[a, b, c, d, e, f] = str; 另外也可以運用ES6的其餘參數 ，可以看到有個 ...other 的用法 ，這是可以將剩餘的陣列成員通通塞給 other 這個變數，如果沒有相對應的值則這個變數的值會是undefined, 其餘參數12345678let [one, ...other] = [1, 2, 3, 4];console.log(one); // 1console.log(other); // [2, 3, 4]let [a, b, ...z] = ['a'];console.log(a); // 'a'console.log(b); // undefinedconsole.log(z); // [] 物件解構賦值陣列是使用順序的索引值對應，但物件則是使用物件的屬性名稱來做對應(因此沒有順序性)。 在以下範例則是快速將物件值解構在變數上。 1234567// 基本用法const &#123; user, admin &#125; = &#123; user: "平民", admin: "皇帝" &#125;console.log(user, admin); //"平民","皇帝"// 屬性名稱對換位置也不影響const &#123; admin, user &#125; = &#123; user: "平民", admin: "皇帝" &#125;console.log(admin, user); //"皇帝", "平民" 如果變數與屬性名都沒有對應的名稱，則變數的值會是 undefined 123// 沒有對應的屬性const &#123; user &#125; = &#123; admin: "皇帝" &#125;console.log(user); //undefined 而物件的解構方法，還能重新賦予變數的名稱，也可以屬性值來當作變數對應等號後方的屬性值，寫法會是類似這樣: 12const &#123; user: aa, admin: zz &#125; = &#123; user: "平民", admin: "皇帝" &#125;console.log(aa, zz); //"平民","皇帝" 不可行的寫法和陣列解構賦值不同的是，在陣列解構賦值中，我們可以接受 「變數 少於 所給的值 」： 陣列12let [a, , c] = [1, 2, 3];console.log(a, c); // 1, 3 但是在物件解構賦值中，我們不能像上面這樣寫： 物件12let&#123;a, ,c&#125; = &#123;a:1, b:2, c:3&#125;;console.log(a,c); // Error 只能接受 「變數 多於 所給的值 」 物件12let&#123;a, b, c, d&#125; = &#123;a:1, c:3&#125;;console.log(a, b, c, d); // 1, undefined, 3, undefined 物件解構賦值的用途物件解構賦值的用途相當多，其中在提取 JSON 數據時相當方便： JSON1234567891011let ajax_JSON = &#123; id: 9527, name: "Kanboo", other:&#123; tel: "1234567", fax: "7654321" &#125;&#125;let &#123;id, name, other&#125; = ajax_JSON;console.log(id, name, other); 如此就能夠快速取得 JSON 物件的屬性名和屬性值。 混合使用複雜的物件或混合陣列到物件，如果你能記住之前說的鏡子樣式對映基本原則，其實也很容易就能理解 範例112let &#123; home: Master, family: [ , member] &#125; = &#123; home: '媽媽', family: ['老大', '老二', '老么']&#125;console.log( Master, member ); // 媽媽 老二 範例21234567891011// 複雜多層次的物件const &#123; prop: x, prop2: &#123; prop3: &#123; nested: [ , , b] &#125; &#125;&#125; = &#123; prop: "Hello", prop2: &#123; prop3: &#123; nested: ["a", "b", "c"]&#125;&#125;&#125;console.log(x, b); // =&gt; Hello c 預設值除了使用鏡射的概念外，為了避免值沒有賦予造成 undefined，可以使用預設值避免此問題。 如以下左方的陣列都先賦予的預設值，當右方的陣列只有一個值時，左方的陣列剩餘內容將會採用預設值。 12345678const [ isPass = true ] = []console.log(isPass); // trueconst &#123; message: msg = 'Hello' &#125; = &#123;&#125;console.log(msg); // "Hello"const &#123; a = 6 &#125; = &#123;&#125;console.log(a); // 6 要作一個簡單的陷阱題滿簡單的，你可以試看看下面這個範例中到底是賦到了什麼值： 1234const &#123; a ='kanboo' &#125; = 'hello'const [ b ='kanboo' ] = 'hello'console.log( a, b) 函式除了以上的方法外，解構也能使用在函式的參數，使用方式如同將傳入的物件對應到函式參數上。這樣參數一樣能夠能夠自訂變數名稱、順序、預設值等。 123456789function func(&#123;a = 3, b&#125;) &#123; console.log(a + b);&#125;func(&#123;a: 1, b: 2&#125;) // 3func(&#123;b: 2&#125;) // 5func(&#123;a: 1&#125;) // NaNfunc(&#123;&#125;) // NaNfunc() // Cannot read property 'a' of undefined 當a與b兩個都有預設值時，NaN 的情況不存在： 123456789function func(&#123;a = 3, b = 5&#125;) &#123; console.log(a + b);&#125;func(&#123;a: 1, b: 2&#125;) // 3func(&#123;a: 1&#125;) // 6func(&#123;b: 2&#125;) // 5func(&#123;&#125;) // 8func() // Cannot read property 'a' of undefined 實際上函式傳入參數它自己也可以加預設值，但這情況會讓最後一種 func() 呼叫時與 func({}) 相同結果： 123456789function func(&#123;a = 3, b = 5&#125; = &#123;&#125;) &#123; console.log(a + b);&#125;func(&#123;a: 1, b: 2&#125;) // 3func(&#123;a: 1&#125;) // 6func(&#123;b: 2&#125;) // 5func(&#123;&#125;) // 8func() // 8 另一種情況是在函式傳入參數的預設值中給了另一套預設值，這只會在func()時發揮它的作用： 123456789function func(&#123;a = 3, b = 5&#125; = &#123;a: 7, b: 11&#125;) &#123; console.log(a + b);&#125;func(&#123;a: 1, b: 2&#125;) // 3func(&#123;a: 1&#125;) // 6func(&#123;b: 2&#125;) // 5func(&#123;&#125;) // 8func() // 18 參考來源邁向 JavaScript 勇者之路從ES6開始的JavaScript學習生活陣列解構賦值物件解構賦值]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>解構賦值</tag>
        <tag>Destructuring Assignment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-淺拷貝(Shallow Copy) VS 深拷貝(Deep Copy)]]></title>
    <url>%2F2018%2F01%2F27%2FJS-ShallowCopy-DeepCopy%2F</url>
    <content type="text"><![CDATA[淺拷貝(Shallow Copy) VS 深拷貝(Deep Copy) 基本與物件型別傳值的差異 JavaScript 內建的型別主要可以分成基本型別 (Primitives) 與物件型別 (Object) 兩大類。 而基本型別又分成 string、number、boolean、null、undefined 幾種，除了以上幾種之外，其他都可以歸類至物件型別 (Object) 這二種型別之間的差異，就是在他們的傳值方式 基本型別 =&gt; 傳值(value) 物件型別 =&gt; 傳址(reference) 下面範例來解說他們的差異 基本型別 基本型別是傳 value 基本型別，傳value1234567let a = "爸爸";let b = a;b = "媽媽";console.log(a); //爸爸console.log(b); //媽媽 在修改 b 時並不會改到 a 的值 物件型別 但物件就不同，物件傳的是 reference 物件型別，傳reference1234567let objA = &#123; name: '王大頭' &#125;let objB = objAobjB.name = '盧卡斯'console.log(objA); //"盧卡斯"console.log(objB); //"盧卡斯" 淺拷貝(Shallow Copy) VS 深拷貝(Deep Copy) 淺拷貝：只複製指向某個物件的指標，而不複製物件本身，新舊物件還是共用同一塊記憶體。 深拷貝：會另外創造一個一模一樣的物件，新物件跟原物件不共用記憶體，修改新物件不會改到原物件。 Object.assignObject.assign 是 ES6 的新函式，我們可以用來達成複製的功能 複製物件123456789let obj = &#123;name: '王康寶', age:&#123;child: 18&#125;&#125;let copy = Object.assign(&#123;&#125;, obj);//更改 copy.name 的值copy.name = '盧卡斯';//輸出console.log(obj); //&#123;name: "王康寶", age:&#123;child: 18&#125;&#125;console.log(copy); //&#123;name: "盧卡斯", age:&#123;child: 18&#125;&#125; But Object.assign 並不是那麼的完美，請再看下例 淺拷貝123456789let obj = &#123;name: '王康寶', age:&#123;child: 18&#125;&#125;let copy = Object.assign(&#123;&#125;, obj);copy.name = '盧卡斯';copy.age.child = 99; //更改 copy.age.child 的值//輸出console.log(obj); //&#123;name: "王康寶", age:&#123;child: 99&#125;&#125;console.log(copy); //&#123;name: "盧卡斯", age:&#123;child: 99&#125;&#125; 我們可以看到更改 copy.age.child 值以後，發現 obj.age.child 值也跟著被變掉了，所以 Object.assign 能處理深度，只有一層的物件，沒辦法做到真正的 深拷貝(Deep Copy)，不過如果要複製的物件只有一層的話可以考慮使用他。 另外也可以使用 展開運算子(Spread Operator) 達成複製，不過一樣是 淺層的複製。 展開運算子( Spread Operator )123456789let obj = &#123;name: '王康寶', age:&#123;child: 18&#125;&#125;let copy = &#123;...obj&#125;; //展開運算子(Spread Operator)copy.name = '盧卡斯';copy.age.child = 99; //更改 copy.age.child 的值//輸出console.log(obj); //&#123;name: "王康寶", age:&#123;child: 99&#125;&#125;console.log(copy); //&#123;name: "盧卡斯", age:&#123;child: 99&#125;&#125; 深拷貝的作法jQueryjquery 有提供一個 $.extend 可以用來做 Deep Copy jquery.extend123456789let obj = &#123;name: '王康寶', age:&#123;child: 18&#125;&#125;let copy = $.extend(true, &#123;&#125;, obj); //使用 jquery.extendcopy.name = '盧卡斯';copy.age.child = 99; //更改 copy.age.child 的值//輸出console.log(obj); //&#123;name: "王康寶", age:&#123;child: 18&#125;&#125;console.log(copy); //&#123;name: "盧卡斯", age:&#123;child: 99&#125;&#125; lodashlodash 也有提供 _.cloneDeep 用來做 Deep Copy lodash.cloneDeep123456789let obj = &#123;name: '王康寶', age:&#123;child: 18&#125;&#125;let copy = _.cloneDeep(obj); //使用 lodash.cloneDeepcopy.name = '盧卡斯';copy.age.child = 99; //更改 copy.age.child 的值//輸出console.log(obj); //&#123;name: "王康寶", age:&#123;child: 18&#125;&#125;console.log(copy); //&#123;name: "盧卡斯", age:&#123;child: 99&#125;&#125; 參考來源關於 JS 中的淺拷貝和深拷貝js中的深拷贝和浅拷贝]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Shallow Copy</tag>
        <tag>Deep Copy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-展開運算子(Spread Operator)、其餘參數(Rest Operator)]]></title>
    <url>%2F2018%2F01%2F26%2FES6-SpreadOperator-RestOperator%2F</url>
    <content type="text"><![CDATA[展開運算子(Spread Operator)、其餘參數(Rest Operator) 展開運算子( Spread Operator )展開運算子是”把一個陣列展開(expand)成個別數值“的速寫語法，簡單來說，就是把陣列裡面的值，拆解成一個一個。 基本用法1234567//陣列let number = [1,2,3,4,5];console.log(...number); // 1,2,3,4,5//字串let str = 'kanboo'console.log(...str); // "k","a","n","b","o","o" 將二個Array合併(新舊寫法比較)12345678910111213141516//===========過去寫法===========let groupA = ['爸爸', '媽媽'];let groupB = ['老大','老二','老么'];const groupAll = groupA.concat(groupB);console.log(groupAll);// ["爸爸", "媽媽", "老大", "老二", "老么"];//===========新的寫法===========let groupA = ['爸爸', '媽媽'];let groupB = ['老大','老二','老么'];const groupAll = [...groupA, ...groupB]; //拆解完後，再用陣列[]包起來，產生新的陣列console.log(groupAll);// ["爸爸", "媽媽", "老大", "老二", "老么"]; 你也可以用來把陣列展開，傳入函式之中，例如下面加總函式的範例： 將 陣列展開 傳入函式123456function sum(a, b, c) &#123; return a + b + c;&#125;var args = [1, 2, 3];console.log(sum(...args)); // 6 淺層複製另外陣列與物件相同都有著傳參考的特性，所以當把陣列賦予到另一個值上時，修改其中一個另一個也會跟著變動。 傳址：更動groupB 會 影響groupA123456789// 由於傳參考的關係，所以將一個陣列傳到另一個上時// 兩個的值其實是一樣的let groupA = ['老大','老二','老么'];let groupB = groupA;groupB.push('小花');//輸出console.log(groupA); // ['老大','老二','老么','小花'];console.log(groupB); // ['老大','老二','老么','小花']; 由於 展開運算子 它是一個一個將值寫入，所以他也有淺層的複製(shallow copy) 。 淺層複製：更動groupB 不會 影響groupA12345678// 這個屬於淺拷貝，所以不會影響到另一個物件let groupA = ['老大','老二','老么'];let groupB = [...groupA];groupB.push('小花');//輸出console.log(groupA); // ['老大','老二','老么'];console.log(groupB); // ['老大','老二','老么','小花']; 注意 因為是淺層的複製，所以當陣列的值是放 物件 的話，依舊會因為傳參考的特性，而修改其中一個另一個也會跟著變動。 1234567891011121314151617let groupA = [&#123;name:'老大'&#125;,&#123;name:'老二'&#125;,&#123;name:'老三'&#125;];let groupB = [...groupA];groupB.push(&#123;name:'小花'&#125;);//輸出console.log(groupA); // [&#123;name:'老大'&#125;,&#123;name:'老二'&#125;,&#123;name:'老三'&#125;]console.log(groupB); // [&#123;name:'老大'&#125;,&#123;name:'老二'&#125;,&#123;name:'老三'&#125;,&#123;name:'小花'&#125;]debugger;//更改 groupB 第一個NamegroupB[0].name = "爸爸";//注意 groupA 的第一個Name，也會跟著被變動console.log(groupA); // [&#123;name:'爸爸'&#125;,&#123;name:'老二'&#125;,&#123;name:'老三'&#125;]console.log(groupB); // [&#123;name:'爸爸'&#125;,&#123;name:'老二'&#125;,&#123;name:'老三'&#125;,&#123;name:'小花'&#125;] 類陣列轉成純陣列JavaScript 中有許多類陣列，這類陣列有著陣列的外皮，但卻不能使用陣列的方法，這類陣列由於原型不同，所以 不能 使用許多的陣列方法，如： map(), concat() 等等。 其中一種很常見的就是 DOM 陣列，此時我們就可以用 展開運算子 轉為 純陣列，這樣就可以使用陣列的各種方法。 12345// 可以將類陣列轉成陣列let doms = document.querySelectorAll('p');console.log(doms);let spreadDom = [...doms];console.log(spreadDom); 範例 arguments 以前要使用函式的 arguments 時，寫法僅可用 for 或 for..in 依序取得參數值。 arguments傳統寫法123456789function sum() &#123; var total = 0; for( var i=0; i&lt;arguments.length; i++ ) &#123; total += arguments[i]; &#125; return total;&#125;console.log( sum(1, 2, 3, 4, 5) ); // 15 但是若將 arguments 改寫用 陣列的方法(forEach、map、reduce) 的話，程式碼就會出錯。 使用陣列方法，會Error123456789function sum() &#123; var total = 0; arguments.forEach(function(element) &#123; total += element; &#125;); return total;&#125;console.log(sum(1, 2, 3, 4, 5)); //error TypeError: arguments.forEach is not a function 現在可透過 展開運算子 轉為 純陣列，就可使用 陣列的方法(forEach、map、reduce)。 透過「展開運算子」轉換12345678910function sum() &#123; let arg = [...arguments]; //透過 展開運算子 來轉成純陣列 let total = 0; arg.forEach(function(element) &#123; total += element; &#125;); return total;&#125;console.log(sum(1, 2, 3, 4, 5)); //15 其餘參數(Rest Operator)有時候，Function 接受的參數數量不固定，而 其餘參數(Rest Operator) 的功能就是把多的參數併成一個 Array。 範例1 可傳入不固定的參數，1個 or 多個 皆可.. 123456789101112function sum(...numbers) &#123; var result = 0; numbers.forEach(function (number) &#123; result += number; &#125;); return result;&#125;//傳入一個值console.log(sum(1)); // 1//傳入多個值console.log(sum(1, 2, 3, 4, 5)); // 15 範例2 如果function有先定義別的參數，就會將傳入的參數值先給定義好的參數，剩下的就全部塞入其餘參數。 12345678function restArray(x, y, ...others) &#123; console.log("x",x); // x： 1 console.log("y",y); // y： 2 console.log("others",others); // others： [3, 4, 5]&#125;//拆解陣列restArray(1, 2, 3, 4, 5); 其餘參數(Rest parameters)有一個限制，就是這個參數一定是函式的「最後一個」。 你如果放在其餘的參數前，就會產生錯誤。 反過來寫就會Error12345678function restArray(...others, x, y) &#123; console.log("x",x); console.log("y",y); console.log("others",others);&#125;//拆解陣列restArray(1, 2, 3, 4, 5); //error SyntaxError: Rest parameter must be last formal parameter 其餘的參數 與 arguments 不同的是：- arguments 不是真的陣列，其餘參數則「是」。- arguments 不能混用自訂傳入的參數。 參考來源邁向 JavaScript 勇者之路Eddy-展開運算值、其餘參數]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>Spread Operator</tag>
        <tag>Rest Operator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-樣板字串 (Template String)]]></title>
    <url>%2F2018%2F01%2F25%2FES6-TemplateString%2F</url>
    <content type="text"><![CDATA[Template String 樣板字串 基本用法新舊寫法比較123456789101112131415161718192021222324252627const people = ['老大','老二','老么'];//======================過去寫法======================let oldUl = '&lt;ul&gt;' + '&lt;li&gt;我叫做 ' + people[0] + '&lt;/li&gt;' + '&lt;li&gt;我叫做 ' + people[1] + '&lt;/li&gt;' + '&lt;li&gt;我叫做 ' + people[2] + '&lt;/li&gt;' + '&lt;/ul&gt;'; console.log(oldUl);//"&lt;ul&gt;&lt;li&gt;我叫做 老大&lt;/li&gt;&lt;li&gt;我叫做 老二&lt;/li&gt;&lt;li&gt;我叫做 老么&lt;/li&gt;&lt;/ul&gt;"//======================新的寫法======================let newUl = ` &lt;ul&gt; &lt;li&gt;我叫做 $&#123;people[0]&#125;&lt;/li&gt; &lt;li&gt;我叫做 $&#123;people[1]&#125;&lt;/li&gt; &lt;li&gt;我叫做 $&#123;people[2]&#125;&lt;/li&gt; &lt;/ul&gt;`console.log(newUl);// &lt;ul&gt;// &lt;li&gt;我叫做 老大&lt;/li&gt;// &lt;li&gt;我叫做 老二&lt;/li&gt;// &lt;li&gt;我叫做 老么&lt;/li&gt;// &lt;/ul&gt; 甚至可以在 ${} 內使用函式 (${}裡再包${})。 使用.map組字串(結果與上例一樣)12345let newUl = ` &lt;ul&gt; $&#123;people.map(person =&gt; `&lt;li&gt;我叫做 $&#123;person&#125;&lt;/li&gt;`).join('')&#125; &lt;/ul&gt;` 也可以在函式內增添更多的判斷式。 新增if判斷式1234567891011121314151617181920212223242526272829303132const people = [ &#123; name: '老大', friends: 2 &#125;, &#123; name: '老二', friends: 16 &#125;, &#123; name: '老么', friends: 0 &#125;]let newUl = ` &lt;ul&gt; $&#123;people.map((person) =&gt; &#123; if (person.friends) &#123; return `&lt;li&gt;$&#123;person.name&#125; 有 $&#123;person.friends&#125; 朋友&lt;/li&gt;` &#125; else &#123; return `&lt;li&gt;$&#123;person.name&#125; 沒朋友&lt;/li&gt;` &#125; &#125;).join('') &#125; &lt;/ul&gt;`console.log(newUl);// &lt;ul&gt;// &lt;li&gt;老大 有 2 朋友&lt;/li&gt;&lt;li&gt;老二 有 999 朋友&lt;/li&gt;&lt;li&gt;老么 邊緣人&lt;/li&gt;// &lt;/ul&gt; 巢狀 String Template如同上述的方法 ${} 內可以加入函式及其更內層的 Template String，所以也可以在 ${} 插入另一組的函式的 Template String。 在$&#123;&#125;裡呼叫function123456789101112131415161718192021222324252627282930313233343536373839404142434445const travelers = &#123; leader: "爸爸", partner: [ &#123; name: "老大", friends: 2 &#125;, &#123; name: "老二", friends: 16 &#125;, &#123; name: "老么", friends: 0 &#125; ]&#125;;function renderList(people) &#123; return ` &lt;div&gt;上車名單&lt;/div&gt; &lt;ul&gt; $&#123;people.map(person =&gt; `&lt;li&gt;$&#123;person.name&#125;&lt;/li&gt;`).join('')&#125; &lt;/ul&gt; `&#125;let template = ` &lt;div class="template"&gt; &lt;h2&gt;開車：$&#123;travelers.leader&#125;&lt;/h2&gt; $&#123;renderList(travelers.partner)&#125; &lt;/div&gt;`console.log(template);// &lt;div class=\"template\"&gt;// &lt;h2&gt;開車：爸爸&lt;/h2&gt;// // &lt;div&gt;上車名單&lt;/div&gt;// &lt;ul&gt;// &lt;li&gt;老大&lt;/li&gt;&lt;li&gt;老二&lt;/li&gt;&lt;li&gt;老么&lt;/li&gt;// &lt;/ul&gt;// // &lt;/div&gt; 跳脫字元如果有需要插入特殊字元，一樣可以使用 \ 反斜線來插入： 1console.log(`\\`); // "\" 如果要計算字元數，或是需要將字串做額外處理，跳脫字元是不佔字符數的： 1console.log(`\\`.length); // 1 要取得含特殊字元的字串可用 String.raw()： 1console.log(String.raw`\\`.length) // 2 參考來源邁向 JavaScript 勇者之路]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>樣板字串</tag>
        <tag>Template String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-一次搞懂 JavaScript 的 this]]></title>
    <url>%2F2018%2F01%2F24%2FJS-this%2F</url>
    <content type="text"><![CDATA[一次搞懂 JavaScript 的 this 前言在FB直播看到 姚偉揚 老師再說明javascript各種 this 的分辨，在此紀錄各種案例。 FB影片：一次搞懂 JavaScript 的 this主講者：姚偉揚 議程重點 一般函式的 this ES6 箭頭函式的 this Vue 組件的 this bind/apply/call 的 this 一般函式的thisthis 主要是 看函式(function)怎麼執行 的，下列為常見的分辨的方法 直接執行 → global 作為物件的成員函式執行 → 該物件 作為 DOM 事件偵聽函式 → 該 DOM 作為建構函式 → 建構出來的實例 下列為各種this的判斷 範例1 直接呼叫12345function a()&#123; console.log(this);&#125;a(); //window 範例2 作為物件的成員函式執行12345678function a()&#123; console.log(this);&#125;const obj = &#123;&#125;;obj.a = a;obj.a(); //obj 範例3 12345678910const obj = &#123; a()&#123; function b()&#123; console.log(this); &#125; b(); &#125;&#125;obj.a(); //window 因為 b() 是直接執行，並不是以 obj.b() 方式執行。 範例4 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 作為 DOM 事件偵聽函式1234567function a()&#123; console.log(this);&#125;const obj = &#123;a&#125;;btn.addEventListener('click', obj.a); //DOM元素：&lt;button id='btn'&gt;btn&lt;/button&gt; 範例5 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 12345678910111213function a()&#123; console.log(this);&#125;const obj = &#123; b()&#123; return function()&#123; a(); &#125; &#125;&#125;;btn.addEventListener('click', obj.b()); //window 因為 a() 是直接執行。 承上例，執行 obj.b() 後的函式1234567function a()&#123; console.log(this);&#125;btn.addEventListener('click', function()&#123; a(); //window&#125;); 範例6 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 123456789const obj = &#123; b()&#123; return function()&#123; console.log(this); &#125; &#125;&#125;;btn.addEventListener('click', obj.b()); //DOM元素：&lt;button id='btn'&gt;btn&lt;/button&gt; 承上例，執行 obj.b() 後的函式123btn.addEventListener('click', function()&#123; console.log(this);&#125;); 範例7 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 1234567891011function a()&#123; console.log(this);&#125;const obj = &#123; a()&#123; return a; &#125;&#125;;btn.addEventListener('click', obj.a()); //DOM元素：&lt;button id='btn'&gt;btn&lt;/button&gt; 承上例，執行 obj.a() 後的函式123btn.addEventListener('click', function()&#123; console.log(this);&#125;); 可注意觀察 範例5~7 程式碼之間有些微的不同，所造成的this有所不一樣。 善用的方式 另外一種思考的方式，我們在寫物件內的函式時，為了確保 this 能夠正確運作會先將它賦予在另一個變數上 (that, self, vm…)。 123456789101112131415161718var auntie = &#123; name: '漂亮阿姨', callName () &#123; // 先使用另一個變數指向 this，讓內層函式可以正確使用 var that = this; setTimeout(function () &#123; console.log(that); // auntie 這個物件 &#125;, 10); &#125;&#125;auntie.callName(); 箭頭函式的 this口訣： 箭頭函式裡面的this 等於 外面的this 白話文： 箭頭函式裡的this 主要是依據 外層函式(function)裡的this 是什麼就跟著是什麼。 規則 123456function x()&#123; this &lt;= 外層函式的this，規則參考「一般函式的this」 const a = () =&gt; &#123; this &lt;= 依據外層函式的this &#125;&#125; 範例1 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 12345const a = () =&gt; &#123; console.log(this);&#125;btn.addEventListener('click', a); //window 範例2 1234567const obj = &#123; a: () =&gt; &#123; console.log(this); &#125;&#125;obj.a(); //window 範例3 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 12345678function a() &#123; const b = () =&gt; &#123; console.log(this); &#125; b();&#125;btn.addEventListener('click', a); //DOM元素：&lt;button id='btn'&gt;btn&lt;/button&gt; 與 一般函式的範例3 有點類似，雖然 b() 都是直接執行，不過因為箭頭函式裡的this 主要是依據 外層函式(function)裡的this 是什麼就跟著是什麼，所以 a() 的 this 是 DOM元素，所以這裡的 b() 的 this 也會跟著是 DOM元素。 範例4 Q：包了好幾層的箭頭函數的 this 也是指向 windows 嗎? A：從 c() 一層撥一層 直到 function a()，再參照 a() 的 this 是指向誰。 洋蔥式一層一層拆解1234567891011function a()&#123; //this &lt;= 外層函式的this，規則參考「一般函式的this」 const b = () =&gt; &#123; const c = () =&gt; &#123; console.log(this); //&lt;= 依據外層函式的this &#125;; c(); &#125;; b();&#125;; Vue 組件的 this全部皆指向 vue實例 本身 範例1 一般函數12345678910111213141516var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Hello' &#125;, computed: &#123; getMessage: function () &#123; console.log(this); // this 指向 vm 实例 &#125; &#125;, methods: &#123; prompt: function() &#123; console.log(this); // this 指向 vm 实例 &#125; &#125;&#125;) 範例2 箭頭函數123456var vm = new Vue(&#123; el: "#app", methods: &#123; test: () =&gt; console.log(this), //window &#125;,&#125;); 範例3 若是 vue的建立是包在 函數 裡面時，使用 箭頭函數 ，則this要看外層函數的this。 12345678910function init() &#123; //this &lt;= 外層函式的this，規則參考「一般函式的this」 var vm = new Vue(&#123; el: "#app", methods: &#123; test: () =&gt; console.log(this), //&lt;= 依據外層函式的this &#125; &#125;);&#125; 如果在vue裡，寫箭頭函式要使用this的話，因為vue是物件，而不是函式，此時箭頭函式裡的this會指向外層函式的this，所以在vue要使用this的話，建議使用 一般函式 寫法。 bind/apply/call 的 this 一般函式使用 bind/apply/call 時，this 就是所傳入的物件 箭頭函式使用 bind/apply/call 時，this 不會有變化，規則一樣是 依據外層函式(function)裡的this 是什麼就跟著是什麼。 範例1 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 一般函式123456789function add(x, y)&#123; console.log(this);&#125;const b = add.bind(btn);b(3, 5);add.apply(btn, [3, 5]);add.call(btn, 3, 5); 範例2 DOM1&lt;button id='btn'&gt;btn&lt;/button&gt; 箭頭函式123456789const add = (x, y) =&gt; &#123; console.log(this);&#125;const b = add.bind(btn);b(3, 5);add.apply(btn, [3, 5]);add.call(btn, 3, 5);]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-箭頭函式 (Arrow functions)]]></title>
    <url>%2F2018%2F01%2F23%2FES6-Arrowfunctions%2F</url>
    <content type="text"><![CDATA[箭頭函式 () =&gt; {} 簡短的語法一般使用箭頭函式與 function 的用法大致一致，可以傳入參數、也有大括號包起來，除此之外箭頭函式也有更簡短的寫法如下： 1234567891011121314151617// 正常寫法var callSomeone = (someone) =&gt; &#123; return someone + '上工了'&#125;console.log(callSomeone('伙計'))// 縮寫，單一行陳述不需要 &#123;&#125;var callSomeone = (someone) =&gt; someone + '上工了'console.log(callSomeone('伙計'))// 只有一個參數可以不加括號var callSomeone = someone =&gt; someone + '上工了'console.log(callSomeone('伙計'))// 沒有參數時，一定要有括號var callSomeone = () =&gt; '伙計' + '上工了'console.log(callSomeone('伙計')) 注意不過這個上述有個小地方也要注意一下，在大括號內的 {} 是需要自行加入 return，如果沒有傳入值則會出現 undefined。 12var callSomeone = (someone) =&gt; &#123; someone + '上工了' &#125;console.log(callSomeone('伙計')) // undefined 綁定的 this 不同口訣： 箭頭函式裡面的this 等於 外面的this 白話文： 箭頭函式裡的this 主要是依據 外層函式(function)裡的this 是什麼就跟著是什麼。 規則 123456function x()&#123; this &lt;= 外層函式的this，規則參考「一般函式的this」 const a = () =&gt; &#123; this &lt;= 依據外層函式的this &#125;&#125; 範例 callName 是使用 一般函式callName2 是使用 箭頭函式 1234567891011121314151617181920212223var name = '全域阿婆'var auntie = &#123; name: '漂亮阿姨', callName: function () &#123; // 注意，這裡是 function，以此為基準產生一個作用域 console.log('1', this.name); // 1 漂亮阿姨(外層函式) setTimeout(() =&gt; &#123; console.log('2', this.name); // 2 漂亮阿姨(依據外層函式的this) console.log('3', this); // 3 auntie 這個物件(依據外層函式的this) &#125;, 10); &#125;, callName2: () =&gt; &#123; // 注意，如果使用箭頭函式，this 依然指向 window console.log('4', this.name); // 4 全域阿婆(依據外層函式的this) setTimeout(() =&gt; &#123; console.log('5', this.name); // 5 全域阿婆(依據外層函式的this) console.log('6', this); // 6 window 物件(依據外層函式的this) &#125;, 10); &#125;&#125;auntie.callName();auntie.callName2(); 補充：因為 callName2 的 4 使用箭頭函式，所以 依據外層函式的this 的規則，就指向最外層window。 沒有 arguments 參數注意:箭頭函數裡沒有argument物件，可使用 其餘參數(Rest Operator) 替代 12const other = (...others) =&gt; others;console.log(other(10, 20, 30, 40, 50)) // [10, 20, 30, 40, 50] apply, call, bind 無效this 在 Arrow function 中是被綁定的，所以套用 apply, call, bind 的方法時是無法修改 this。 不能用在建構式由於 this 的是在物件下建立，所以箭頭函式不能像 function 一樣作為建構式的函式，如果嘗試使用此方法則會出現錯誤 (… is not a constructor)。 參考來源邁向 JavaScript 勇者之路]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>箭頭函式</tag>
        <tag>Arrow functions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-立即被呼叫的函式 (IIFE)]]></title>
    <url>%2F2018%2F01%2F16%2FJS-IIFE%2F</url>
    <content type="text"><![CDATA[立即被呼叫的函式 (Immediately Invoked Function Expression, IIFE) 前言在 2018 iT 邦幫忙鐵人賽，看到Kuro大的重新認識 JavaScript 系列文，仔細的閱讀後，紀錄自己觀念不足的部份，也非常推薦給大家觀看此系列文。 Kuro-重新認識 JavaScript 系列 立即被呼叫的函式 (IIFE)IIFE 的好處，就是可以減少「全域變數」的產生，同時也避免了變數名稱衝突的機會。 如果你有去看過 jQuery 的原始碼，就會發現 jQuery 也用了相同的手法將 window 與 undefined 保留起來： 12345(function( window, undefined ) &#123; // 略...&#125;)( window ); 當迴圈遇到 function題目：假設想透過迴圈 + setTimeout 來做到，在五秒之內，每秒鐘依序透過console.log印出：0 1 2 3 4 12345678// 假設想透過迴圈 + setTimeout 來做到// 每秒鐘將 i 的值 console 出來for( var i = 0; i &lt; 5; i++ ) &#123; window.setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125; 真的是這樣嗎？ 我們來看看執行的結果。 執行的結果是， console.log() 會在「一秒鐘之後」同時印出「五次 5」。 1234555555 「切分變數有效範圍的最小單位是 “function” 」「切分變數有效範圍的最小單位是 “function” 」「切分變數有效範圍的最小單位是 “function” 」 很重要，所以要再講三次。 所以我們利用 IIFE 稍微修改一下： IIFE12345678910for( var i = 0; i &lt; 5; i++ ) &#123; (function(x)&#123; // 將原本的 1000 改成 1000 * x window.setTimeout(function() &#123; console.log(x); &#125;, 1000 * x); &#125;)(i);&#125; 像這樣，就可以依序印出我們要的結果囉！ ES6-let、constES6 以後新增了 let 與 const，且改以 { } 作為它的 Scope。 換句話說，將範例中的 for 改為 let 就可以做到保留 i 在執行迴圈當下的「值」的效果： 12345for( let i = 0; i &lt; 5; i++ ) &#123; window.setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125;]]></content>
      <categories>
        <category>JS</category>
        <category>重新認識 JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>重新認識 JavaScript</tag>
        <tag>IIFE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-Callback Function]]></title>
    <url>%2F2018%2F01%2F16%2FJS-CallbackFunction%2F</url>
    <content type="text"><![CDATA[Callback Function &amp; Promise 前言在 2018 iT 邦幫忙鐵人賽，看到Kuro大的重新認識 JavaScript 系列文，仔細的閱讀後，紀錄自己觀念不足的部份，也非常推薦給大家觀看此系列文。 Kuro-重新認識 JavaScript 系列 Callback Function概念就如同： 辦公室電話響了 (事件被觸發 Event fired) -&gt; 接電話 (處理事件 Event Handler) 而寫成程式碼就類似： 12// 註：這裡只是比喻，並沒有電話響這個事件 XDOffice.addEventListener( '電話響', function()&#123; /* 接電話 */ &#125;, false); 可以看到，Office 透過 addEventListener 方法註冊了一個事件，當這個事件被觸發時，它會去執行我們所指定的第二個參數，也就是某個「函式」(接電話)。 換句話說，這個函式只會在滿足了某個條件才會被動地去執行，我們就可以說這是一個 Callback function。 波動拳 (a.k.a. “Callback Hell”)除了事件以外，還有另一個會需要用到 Callback function 的場景，就是「控制多個函式間執行的順序」。 下面舉例從簡單的事情慢慢演變成複雜時，會發生什麼情形 這裡定義了兩個 function： 12345678910var funcA = function()&#123; console.log('function A');&#125;;var funcB = function()&#123; console.log('function B');&#125;;funcA();funcB(); 因為 funcA 與 funcB 都會立即執行，所以執行結果必定為： 12"function A""function B" 但是，假設我們改成這樣，加上一個隨機生成的等待時間： 12345678910111213141516171819var funcA = function()&#123; var i = Math.random() + 1; window.setTimeout(function()&#123; console.log('function A'); &#125;, i * 1000);&#125;;var funcB = function()&#123; var i = Math.random() + 1; window.setTimeout(function()&#123; console.log('function B'); &#125;, i * 1000);&#125;;funcA();funcB(); 這時候就沒辦法確定是 “function A” 會先出現還是 “function B” 會先出現了對吧？ 像這種時候，為了確保執行的順序，就會透過 Callback function 的形式來處理： 1234567891011121314151617181920212223242526// 為了確保先執行 funcA 再執行 funcB// 我們在 funcA 加上 callback 參數var funcA = function(callback)&#123; var i = Math.random() + 1; window.setTimeout(function()&#123; console.log('function A'); // 如果 callback 是個函式就呼叫它 if( typeof callback === 'function' )&#123; callback(); &#125; &#125;, i * 1000);&#125;;var funcB = function()&#123; var i = Math.random() + 1; window.setTimeout(function()&#123; console.log('function B'); &#125;, i * 1000);&#125;;// 將 funcB 作為參數帶入 funcA()funcA( funcB ); 像這樣，無論 funcA 在執行的時候要等多久， funcB 都會等到 console.log(‘function A’); 之後才執行。 不過需要注意的是，當函式之間的相依過深，callback 多層之後產生的「波動拳」維護起來就會很可怕！ 1234567891011getData(function (a) &#123; getMoreData(a, function (b) &#123; getMoreData(b, function (c) &#123; getMoreData(c, function (d) &#123; getMoreData(d, function (e) &#123; ... &#125;); &#125;); &#125;); &#125;);&#125;); 再見 Callback Hell執行順序的問題是一個，還有另一個常見的狀況是這樣，再回到 「Overcooked」 的場景。 用 Overcooked (遊戲名稱：煮過頭) 比喻 同步(Synchronous)的概念假設邊緣人如我，只能自己一人玩 Overcooked，在領完食材原料之後，一樣會有青菜、番茄需要處理。因為只有一個廚師，所以要嘛先處理青菜、要嘛先處理番茄，必須先弄完一項之後再去處理另一項，整個流程會被前一個步驟卡住。像這樣「先完成 A 才能做 B、C、D …」的運作方式我們就會把它稱作「同步」(Synchronous) 。 當我要確保「切青菜、切番茄、擺盤」三個動作都完成之後，我才能繼續「上菜」這個動作。 在面臨這種問題的時候，我要怎麼確保三個動作都完成之後，才繼續執行後面的程式呢？ 最直覺的方式是新增一個變數來管理狀態： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var result = []; //紀錄已完成的事件var step = 3; //全部完成的總數量// 假設 funcA、funcB、funcC 分別代表「切青菜、切番茄、擺盤」function funcA()&#123; window.setTimeout(function()&#123; result.push('A'); //紀錄 A 完成 console.log('A'); if( result.length === step )&#123; funcD(); &#125; &#125;, (Math.random() + 1) * 1000);&#125;function funcB()&#123; window.setTimeout(function()&#123; result.push('B'); //紀錄 B 完成 console.log('B'); if( result.length === step )&#123; funcD(); &#125; &#125;, (Math.random() + 1) * 1000);&#125;function funcC()&#123; window.setTimeout(function()&#123; result.push('C'); //紀錄 C 完成 console.log('C'); if( result.length === step )&#123; funcD(); &#125; &#125;, (Math.random() + 1) * 1000);&#125;function funcD()&#123; console.log('上菜！'); result = [];&#125;funcA();funcB();funcC(); 像上面這樣，當我們依序執行了 funcA()、funcB()、funcC()，由於內部 setTimeout 會等待亂數時間的關係，我們無法得知誰先誰後。 但可以確定的是，當這三個函式執行的時候就會去檢查 result.length === step ，如果成立，就表示三個任務都已經完成，那麼就可以再去呼叫 funcD 執行後續的事情。 如果不希望使用全域變數來污染執行環境的話，甚至可以包裝成一個通用的函式： 閉包的概念12345678910111213141516function serials(tasks, callback) &#123; var step = tasks.length; var result = []; // 檢查的邏輯寫在這裡 function check(r) &#123; result.push(r); if( result.length === step )&#123; callback(); &#125; &#125; tasks.forEach(function(f) &#123; f(check); &#125;);&#125; 那麼改寫一下 funcA()、funcB()、funcC(): 123456789101112131415161718192021222324function funcA(check)&#123; window.setTimeout(function()&#123; console.log('A'); check('A'); &#125;, (Math.random() + 1) * 1000);&#125;function funcB(check)&#123; window.setTimeout(function()&#123; console.log('B'); check('B'); &#125;, (Math.random() + 1) * 1000);&#125;function funcC(check)&#123; window.setTimeout(function()&#123; console.log('C'); check('C'); &#125;, (Math.random() + 1) * 1000);&#125;function funcD()&#123; console.log('上菜！');&#125; 最後呼叫的時候，我們就可以透過這樣呼叫 serials() ： 1serials([funcA, funcB, funcC], funcD); 把想要提前執行的函式以陣列的方式傳進 serials() 作為第一個參數，當陣列中的函式都執行完畢後，才會呼叫第二個參數的 funcD()。 Promise 物件為了解決同步/非同步的問題，自從 ES6 開始新增了一個叫做 Promise 的特殊物件。 簡單來說，Promise 按字面上的翻譯就是「承諾、約定」之意，回傳的結果要嘛是「完成」，要嘛是「拒絕」。 實際寫成 Promise 的程式碼大概像這樣： 1234const myFirstPromise = new Promise((resolve, reject) =&gt; &#123; resolve(someValue); // 完成 reject("failure reason"); // 拒絕&#125;); 要提供一個函式 promise 功能，讓它回傳一個 promise 物件即可： 12345function myAsyncFunction(url) &#123; return new Promise((resolve, reject) =&gt; &#123; // resolve() or reject() &#125;);&#125;; 當 Promise 被完成的時候，我們就可以呼叫 resolve()，然後將取得的資料傳遞出去。 或是說想要拒絕 Promise ， 那麼就呼叫 reject() 來拒絕。 一般來說， Promise 物件會有這幾種狀態： pending: 初始狀態，不是 fulfilled 或 rejected。 fulfilled: 表示操作成功地完成。 rejected: 表示操作失敗。 整個 Promise 流程可以用這張圖表示： 如果我們需要依序串連執行多個 promise 功能的話，可以透過 .then() 來做到。 以剛剛的 funcA()、funcB()、funcC() 來當範例，我們將這三個函式分別透過 Promise 包裝： 1234567891011121314151617181920212223242526function funcA()&#123; return new Promise(function(resolve, reject)&#123; window.setTimeout(function()&#123; console.log('A'); resolve('A'); // 完成 &#125;, (Math.random() + 1) * 1000); &#125;);&#125;function funcB()&#123; return new Promise(function(resolve, reject)&#123; window.setTimeout(function()&#123; console.log('B'); resolve('B'); // 完成 &#125;, (Math.random() + 1) * 1000); &#125;);&#125;function funcC()&#123; return new Promise(function(resolve, reject)&#123; window.setTimeout(function()&#123; console.log('C'); resolve('C'); // 完成 &#125;, (Math.random() + 1) * 1000); &#125;);&#125; 最後透過呼叫 1funcA().then(funcB).then(funcC); 就可以做到等 funcA() 被 「resolve」之後再執行 funcB()，然後 resolve 再執行 funcC() 的順序了。 如果我們不在乎 funcA()、funcB()、funcC() 誰先誰後，只關心這三個是否已經完成呢？ 那就可以透過 Promise.all() 來做到： Promise.all()12345// funcA, funcB, funcC 的先後順序不重要// 直到這三個函式都回覆 resolve 或是「其中一個」 reject 才會繼續後續的行為Promise.all([funcA(), funcB(), funcC()]) .then(function()&#123; console.log('上菜'); &#125;);]]></content>
      <categories>
        <category>JS</category>
        <category>重新認識 JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>重新認識 JavaScript</tag>
        <tag>Callback Function</tag>
        <tag>Callback Hell</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-Events]]></title>
    <url>%2F2018%2F01%2F16%2FJS-Events%2F</url>
    <content type="text"><![CDATA[那些你知道與不知道的事件們 前言在 2018 iT 邦幫忙鐵人賽，看到Kuro大的重新認識 JavaScript 系列文，仔細的閱讀後，紀錄自己觀念不足的部份，也非常推薦給大家觀看此系列文。 Kuro-重新認識 JavaScript 系列 表單相關事件 input 事件： 當 input、 textarea 以及帶有 contenteditable 的元素內容被改變時，就會觸發 input 事件。 change 事件： 當 input、select、textarea、radio、checkbox 等表單元素被改變時觸發。 但與 input 事件不同的是，input 事件會在輸入框輸入內容的當下觸發，而 change 事件則是在目前焦點離開輸入框後才觸發。 submit 事件：當表單被送出時觸發，通常表單驗證都會在這一步處理，若驗證未通過則 return false;。 特殊事件透過 Composition Events 我們可以觀察使用者在輸入框內開啟輸入法 (Input Method Editor, IME) 時，組字或選字的狀態。 這個時候就需要透過 Composition Events 來為輸入框做增強。 compositionstart: 輸入框內開啟輸入法，且正在拼字時觸發。 compositionupdate: 輸入框內開啟輸入法，且正在拼字或選字時更改了內容時觸發。 compositionend: 輸入框內開啟輸入法，拼字或選字完成，正要送出至輸入框時觸發。 可以看到，如果要確認使用者輸入完成並送出文字時，就可以透過 compositionend來做最後確認。 執行的時候像這樣： 開啟console，在input輸入文字：event觸發時機 鍵盤相關事件鍵盤相關事件有下列三種，在大多數情況下會將鍵盤事件註冊在 input 的輸入框上。 keydown 事件: 「壓下」鍵盤按鍵時會觸發 keydown 事件。 keypress 事件: 除了 Shift, Fn, CapsLock 這三種按鍵外按住時會觸發，若按著不放則會連續觸發。 keyup 事件: 「放開」鍵盤按鍵時觸發。 透過 e.keyCode 就可以判斷使用者目前按下的是哪個按鈕 123456textBox.addEventListener('keydown', function(e)&#123; // enter 的 keyCode 是 13 if( e.keyCode === 13 )&#123; formSubmit(); &#125;&#125;, false); 註： keyCode 的對應表可以到這裡查看：https://gist.github.com/tylerbuchea/8011573 滑鼠相關事件 mousedown / mouseup 事件: 這兩個事件分別會在滑鼠點擊了某元素「按下」(mousedown) 按鈕，以及「放開」(mouseup) 按鈕時觸發。 click 事件: 當滑鼠「點擊」了某元素時觸發。 dblclick事件: 當滑鼠「連點兩次」了某元素時觸發。 mouseenter / mousemove / mouseleave 事件： 這三個事件要放在一起看 當滑鼠游標移入了某元素時，會先觸發 mouseenter 事件。 滑鼠游標在這個元素內「移動」時，會連續觸發 mousemove 事件。 直到滑鼠游標離開了這個元素，才觸發 mouseleave 事件。 這些滑鼠相關的事件，都可以透過 event.pageX 與 event.pageY 屬性去取得目前在網頁對應的座標。 介面相關事件 load 事件：註冊在 window 物件上，指的是網頁資源 (包括CSS、JS、圖片等) 全數載入完畢後觸發。如果是 img 元素的 load 事件，則表示是此圖片載入完畢後觸發。 unload 、 beforeunload 事件：與 load 事件相反，unload 與 beforeunload 事件分別會在離開頁面或重新整理時觸發，而 beforeunload 會跳出對話框詢問使用者是否要離開目前頁面。 resize 事件：當瀏覽器 (window) 或指定元素 (element) 的「尺寸變更」時觸發。 scroll 事件：當瀏覽器 (window) 或指定元素 (element) 的「捲軸被拉動」時觸發。 DOMContentLoaded 事件：類似於 load 事件，但不同的是，load 事件是在網頁「所有」資源都已經載入完成後才會觸發，而 DOMContentLoaded 事件是在 DOM 結構被完整的讀取跟解析後就會被觸發，不須等待外部資源讀取完成。 簡單來說， DOMContentLoaded 與 load 的時機可以用這張圖來解釋：]]></content>
      <categories>
        <category>JS</category>
        <category>重新認識 JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>重新認識 JavaScript</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-事件機制的原理]]></title>
    <url>%2F2018%2F01%2F15%2FJS-Bubbling-Capturing%2F</url>
    <content type="text"><![CDATA[事件冒泡 (Event Bubbling) &amp; 事件捕獲 (Event Capturing) 前言在 2018 iT 邦幫忙鐵人賽，看到Kuro大的重新認識 JavaScript 系列文，仔細的閱讀後，紀錄自己觀念不足的部份，也非常推薦給大家觀看此系列文。 Kuro-重新認識 JavaScript 系列 事件冒泡 (Event Bubbling) 圖片來源： Event Flow: capture, target, and bubbling 事件冒泡指的是「從啟動事件的元素節點開始，逐層往上傳遞」，直到整個網頁的根節點，也就是 document。 事件捕獲 (Event Capturing) 圖片來源： Event Flow: capture, target, and bubbling 剛剛說過「事件冒泡」機制是由下往上來傳遞，那麼「事件捕獲」(Event Capturing) 機制則正好相反。 事件傳遞順序既然事件傳遞順序有兩種機制，那我怎麼知道事件是依賴哪種機制執行的？ 答案是：兩種都會執行。 圖片來源: W3C, DOM event flow 開啟console，分別點擊父元素、子元素事件機制的原理 事件監聽 EventTarget.addEventListener()addEventListener() 基本上有三個參數，分別依序是 事件名稱 事件的處理器(事件觸發時執行的 function) Boolean，由這個 Boolean 決定事件是以「捕獲」或「冒泡」機制執行，若不指定則預設為「冒泡」。 1&lt;button id="btn"&gt;Click&lt;/button&gt; 綁定監聽動作12345var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; console.log('HI');&#125;, false); 使用這種方式來註冊事件的好處是可以重複指定多個「處理器」(handler) 給同一個元素的同一個事件： 123456789var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; console.log('HI');&#125;, false);btn.addEventListener('click', function()&#123; console.log('HELLO');&#125;, false); 點擊後 console 出現： 12"HI""HELLO" 若是要解除事件的註冊，則是透過 removeEventListener() 來取消。 removeEventListener() 的三個參數與 addEventListener() 一樣，分別是「事件名稱」、「事件的處理器」以及「捕獲」或「冒泡」的機制。 但是需要注意的是，由於 addEventListener() 可以同時針對某個事件綁定多個 handler，所以透過 removeEventListener() 解除事件的時候，第二個參數的 handler 必須要與先前在 addEventListener() 綁定的 handler 是同一個「實體(記憶體位址) 」。 二個function各自存在不同的記憶體位址12345678910var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; console.log('HI');&#125;, false);// 移除事件，但是沒用btn.removeEventListener('click', function()&#123; console.log('HI');&#125;, false); 像上面這樣，即使執行了 removeEventListener 來移除事件，但 click 時仍會出現 ‘HI’。 因為 addEventListener 與 removeEventListener 所移除的 handler 實際上是兩個不同實體(記憶體位址) 的 function 物件。 同一個function，同個記憶體位址1234567891011var btn = document.getElementById('btn');// 把 event handler 拉出來var clickHandler = function()&#123; console.log('HI');&#125;;btn.addEventListener('click', clickHandler, false);// 移除 clickHandler， ok!btn.removeEventListener('click', clickHandler, false);]]></content>
      <categories>
        <category>JS</category>
        <category>重新認識 JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>重新認識 JavaScript</tag>
        <tag>事件冒泡 (Event Bubbling)</tag>
        <tag>事件捕獲 (Event Capturing)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-Pass by sharing]]></title>
    <url>%2F2018%2F01%2F15%2FJS-Passbysharing%2F</url>
    <content type="text"><![CDATA[JavaScript 是「傳值」或「傳址」？ 前言在 2018 iT 邦幫忙鐵人賽，看到Kuro大的重新認識 JavaScript 系列文，仔細的閱讀後，紀錄自己觀念不足的部份，也非常推薦給大家觀看此系列文。 Kuro-重新認識 JavaScript 系列 「傳值」或「傳址」？所以我說那個 JavaScript 是「傳值」或「傳址」呢？ 在大多數的情況下，基本型別是「傳值」，而物件型別會是「傳址」的方式，但凡事都有例外。 我們來看看下面這個例子： 12345678var coin1 = &#123; value: 10 &#125;;function changeValue(obj) &#123; obj = &#123; value: 123 &#125;;&#125;changeValue(coin1);console.log(coin1); // ？ 猜猜看，經過 changeValue(coin1) 操作後的 coin1 會是什麼？ 答案仍是 { value: 10 } 。 剛剛說過，物件型別會是「傳址」的方式來更新資料，那應該會是 { value: 123 } 才對，為什麼依然不變？ 事實上，JavaScript 不屬於單純的傳值或傳址。更準確一點來說，JavaScript 應該屬於透過 pass by sharing 來傳遞資料。 「傳值」或「傳址」對大多數的開發者來說應該都不陌生，那麼「pass by sharing」又是什麼呢？ Pass by sharing「Pass by sharing」的特點在於，當 function 的參數，如 function changeValue(obj){ … } 中的 obj 被重新賦值的時候，外部變數的內容是不會被影響的。 function裡，重新賦值12345678var coin1 = &#123; value: 10 &#125;;function changeValue(obj) &#123; obj = &#123; value: 123 &#125;;&#125;changeValue(coin1);console.log(coin1); // 此時 coin1 仍是 &#123; value: 10 &#125; 如果不是重新賦值的情況，則又會回到大家所熟悉的狀況： function裡，無 重新賦值123456789var coin1 = &#123; value: 10 &#125;;function changeValue(obj) &#123; // 僅更新 obj.value，並未重新賦值 obj.value = 123;&#125;changeValue(coin1);console.log(coin1); // 此時 coin1 則會變成 &#123; value: 123 &#125; JS中是 pass by value 还是 pass by reference]]></content>
      <categories>
        <category>JS</category>
        <category>重新認識 JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>重新認識 JavaScript</tag>
        <tag>Pass by sharing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-物件、陣列以及型別判斷]]></title>
    <url>%2F2018%2F01%2F15%2FJS-Typejudgment%2F</url>
    <content type="text"><![CDATA[物件、陣列以及型別判斷。 前言在 2018 iT 邦幫忙鐵人賽，看到Kuro大的重新認識 JavaScript 系列文，仔細的閱讀後，紀錄自己觀念不足的部份，也非常推薦給大家觀看此系列文。 Kuro-重新認識 JavaScript 系列 基本型別與物件型別JavaScript 內建的型別主要可以分成基本型別 (Primitives) 與物件型別 (Object) 兩大類。而基本型別又分成 string、number、boolean、null、undefined 幾種，除了以上幾種之外，其他都可以歸類至 物件型別 (Object)物件型別 (Object)物件型別 (Object) 判斷屬性是否存在方法1：物件中不存在的屬性，此時會回傳 undefined方法2：hasOwnProperty() 方法不會往上檢查物件的原型鏈(prototype chain)，而 in 運算子，則會繼續往物件原型鏈上檢查。 方法1 物件中不存在的屬性，此時會回傳 undefined 123var obj = &#123;&#125;;console.log( obj.name ); // undefined 但這麼做會有個例外，就是當該屬性剛好就是 undefined 時，這招就沒用了。 除了檢查 undefined 之外，還有 in 運算子 與 hasOwnProperty() 方法。 方法2 雖然兩者都可以檢查物件的屬性是否存在，但hasOwnProperty() 方法不會往上檢查物件的原型鏈(prototype chain)，，只會檢查物件本身是否存在這個屬性，而 in 運算子，則會繼續往物件原型鏈上檢查。 範例11234567891011var obj = &#123; name: 'Object'&#125;;// 透過 in 檢查屬性console.log( 'name' in obj ); // trueconsole.log( 'value' in obj ); // false// 透過 hasOwnProperty() 方法檢查obj.hasOwnProperty('name'); // trueobj.hasOwnProperty('value'); // false 上述範例1，雖然二種檢查結果都一樣，但我們可看下列的範例2，當檢查某一屬性是在原型鋉上時，會有什麼不一樣 範例21234567//toString 為 原型鍊上的 屬性// 透過 in 檢查屬性console.log( 'toString' in obj ); // true// 透過 hasOwnProperty() 方法檢查obj.hasOwnProperty('toString'); // false typeof: 型別判斷檢查變數型別 (正確來講應該是值，變數沒有型別，值才有)，可以透過 typeof 運算子來處理： 12345678910typeof true; // 'boolean'typeof 'Kanboo'; // 'string'typeof 123; // 'number'typeof NaN; // 'number'typeof &#123; &#125;; // 'object'typeof [ ]; // 'object'typeof undefined; // 'undefined'typeof window.alert; // 'function'typeof null; // 'object' 要注意的是，透過 typeof 運算子回傳的東西都是「字串」。 typeof null 為什麼是 “object” ?其實這只是一個 Bug ，所以小心使用 null 。 參考1: Null and typeof參考2: The history of “typeof null” 如何判別是否為陣列當我們利用 typeof 去檢查一個「陣列」時，會得到 “object“ 的結果， typeof [ ]; // &#39;object&#39; 但如果在實務上仍會有需要判斷某變數是否為一個陣列而非物件的時候，可用 isArray() 方法， 12345678Array.isArray([]); // trueArray.isArray([1]); // trueArray.isArray(new Array()); // trueArray.isArray(); // falseArray.isArray(&#123;&#125;); // falseArray.isArray(null); // falseArray.isArray(undefined); // false]]></content>
      <categories>
        <category>JS</category>
        <category>重新認識 JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>重新認識 JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-各種迴圈的用法]]></title>
    <url>%2F2018%2F01%2F09%2FJS-Traverse%2F</url>
    <content type="text"><![CDATA[紀錄各種迴圈的用法。 前言JS常常需要針對 陣列(Array)、物件(Object) 這二種資料進行分析及修改，故整理下列幾種方法， 單純遍歷陣列元素 for forin forEach 判斷是否符合資格 every：遍歷每個元素判斷是否皆符合條件，若其一不符，就回傳 false some： 遍歷每個元素判斷是否皆符合條件，若其一符合，就回傳 true 產生新的陣列 map：遍歷每個元素，進行 加工、校正 filter：遍歷每個元素，保留符合條件(true)的值，不符合，則去除掉。 reduce：遍歷每個元素，依序組合、加總，然後丟給下個元素，最終會回傳一個結果。 for最常見的用法，不多加說明。 範例 12345let arr = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];for (let i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]);&#125; forin可傳入 objec 或 array 型態的資料。 範例 Array型態12345var arr = ["zero","one","two"];for (var key in arr) &#123; console.log(arr[key]);&#125; Object型態12345var obj = &#123;a: 1, b: 2, c: 3&#125;; for (const item in obj) &#123; console.log(obj[item]);&#125; MDN-for…in forEach可用來取代 for 的寫法，讓程式碼更簡短，省略掉定義 i、arr.length…等動作。 語法 123arr.forEach( callback(currentValue, index, array)&#123; /* your code */&#125;); callback currentValue(常用)：原陣列目前所迭代處理中的元素。 index(選用)：原陣列目前處理中的元素之索引。 array(選用)：呼叫 forEach() 方法的陣列。 範例 ES512345const arr = ['a', 'b', 'c'];arr.forEach(function(element) &#123; console.log(element);&#125;); ES612345const arr = ['a', 'b', 'c'];arr.forEach((element) =&gt; &#123; console.log(element);&#125;); MDN-forEach() every對每個陣列元素判斷是否皆符合條件，若其一不符，就回傳 false 語法 123arr.every( callback(currentValue, index, array)&#123; /* your code */&#125;); callback currentValue(常用)：原陣列目前所迭代處理中的元素。 index(選用)：原陣列目前處理中的元素之索引。 array(選用)：呼叫 every() 方法的陣列。 範例 12345678910function isBigEnough(element, index, array) &#123; //是否大於10 return element &gt;= 10;&#125;// 其中 5 沒有大於 10[12, 5, 8, 130, 44].every(isBigEnough); // false// 皆符合大於 10[12, 54, 18, 130, 44].every(isBigEnough); // true MDN-every() some對每個陣列元素判斷是否皆符合條件，若其一符合，就回傳 true 語法 123arr.some( callback(currentValue, index, array)&#123; /* your code */&#125;); callback currentValue(常用)：原陣列目前所迭代處理中的元素。 index(選用)：原陣列目前處理中的元素之索引。 array(選用)：呼叫 some() 方法的陣列。 範例 12345678910function isBiggerThan10(element, index, array) &#123; //是否大於10 return element &gt; 10;&#125;// 全部都無 大於10[2, 5, 8, 1, 4].some(isBiggerThan10); // false// 其中 12 有大於10[12, 5, 8, 1, 4].some(isBiggerThan10); // true MDN-some() map可對每個陣列元素進行 加工、校正 的處理，最後回傳一個 新的陣列。 原先的陣列與後來新產生出的陣列，個數(Array.length) 會一樣多。 語法 123arr.map( callback(currentValue, index, array)&#123; /* your code */&#125;); callback currentValue(常用)：原陣列目前所迭代處理中的元素。 index(選用)：原陣列目前處理中的元素之索引。 array(選用)：呼叫 map() 方法的陣列。 範例1 加工12345678var myArr = [ 1, 2, 3 ];var newArr = myArr.map(function(element) &#123; // 每個數都加1 return element + 1;&#125;);console.log(newArr); // [ 2, 3, 4 ] 範例2 校正123456789101112var myArr = [ 1, 20, 3, 40, 50, 6, 7, 80, 9, 10 ];var newArr = myArr.map(function(element) &#123; // 校正大於10的數字，統一變100 if (element &lt; 10)&#123; return element; &#125;else&#123; return 100; &#125; &#125;);console.log(newArr); // [1, 100, 3, 100, 100, 6, 7, 100, 9, 100] MDN-map() filter遍歷每個元素，保留符合條件(true)的值，不符合，則去除掉。 原先的陣列與後來新產生出的陣列，個數(Array.length)可能不一樣多。 語法 123arr.filter( callback(currentValue, index, array)&#123; /* your code */&#125;); callback currentValue(常用)：原陣列目前所迭代處理中的元素。 index(選用)：原陣列目前處理中的元素之索引。 array(選用)：呼叫 filter() 方法的陣列。 範例 12345678var myArr = [ 1, 20, 3, 40, 50, 6, 7, 80, 9, 10 ];var newArr = myArr.filter(function(element) &#123; // 取得大於50的數 return element &gt;= 50;&#125;);console.log(newArr); // [50, 80] MDN-filter() reduce遍歷每個元素，依序組合、加總，然後丟給下個元素，最終會回傳一個結果。 語法 123arr.reduce( callback(accumlator, currentValue, index, array)&#123; /* your code */&#125;, initialValue) callback accumulator(常用)：用來累積回呼函式回傳值的累加器。 currentValue(常用)：原陣列目前所迭代處理中的元素。 index(選用)：原陣列目前所迭代處理中的元素之索引。 array(選用)：呼叫 reduce() 方法的陣列。 initialValue(常用)：於第一次呼叫 callback 時要傳入的累加器初始值。 範例1 注意reduce第二個參數 0 , 代表的意思是開始執行遍歷前的初始值。 有設定初始值1234567891011121314151617181920var myArr = [ 1, 2, 3 ];// 處理每個元素後等待回傳結果，第一次處理時代入初始值 0var result = myArr.reduce(function(prev, element) &#123; console.log(prev,element); // 與之前的數值加總，回傳後代入下一輪的處理 return prev + element;&#125;, 0);/* prev,element 的執行log，共執行三次第一次：0 1第二次：1 2第三次：3 3*/// 最終結果console.log(result); // 6 範例2 注意此次沒有設定reduce第二個參數, 此時就會自動抓取陣列第一個元素當作初始值。 無初始值12345678910111213141516171819var myArr = [ 1, 2, 3 ];// 處理每個元素後等待回傳結果，第一次處理時代入初始值 0var result = myArr.reduce(function(prev, element) &#123; console.log(prev,element); // 與之前的數值加總，回傳後代入下一輪的處理 return prev + element;&#125;);/* prev,element 的執行log，共執行二次第一次：1 2第二次：3 3*/// 最終結果console.log(result); // 6 範例3 除了一般數字的加總，也可配合判斷式，最終產出一個新的陣列。 1234567891011121314151617181920212223let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];let result_04 = source.reduce((p, c) =&gt; &#123; //includes 判斷是否已存在 if (!p.includes(c)) p.push(c); console.log("p", p); return p;&#125;, []);/*迴圈的執行log，共執行七次p ["Kanboo"]p ["Kanboo", "Jack"]p ["Kanboo", "Jack", "Rabbit"]p ["Kanboo", "Jack", "Rabbit", "Lucas"]p ["Kanboo", "Jack", "Rabbit", "Lucas"]p ["Kanboo", "Jack", "Rabbit", "Lucas"]p ["Kanboo", "Jack", "Rabbit", "Lucas"] *///最終結果console.log("result_04", result_04); // ["Kanboo", "Jack", "Rabbit", "Lucas"] MDN-Reduce()fred-Map、Reduce]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>for</tag>
        <tag>forin</tag>
        <tag>forEach</tag>
        <tag>every</tag>
        <tag>some</tag>
        <tag>map</tag>
        <tag>filter</tag>
        <tag>reduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-ArrayUnique]]></title>
    <url>%2F2018%2F01%2F08%2FJS-ArrayUnique%2F</url>
    <content type="text"><![CDATA[紀錄 ArrayUnique 從早期indexOf的方式到現今各種優化的寫法。 前言下列的各種範例，統一使用的 Array資料，如下 ArrayData1let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"]; forloop + indexOf早期使用的 for迴圈 + indexOf 判斷是否已存在的值。 indexOf123456789let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];let result_01 = [];for (let i = 0; i &lt; source.length; i++) &#123; let el = source[i]; if (result_01.indexOf(el) === -1) result_01.push(el);&#125;console.log("result_01", result_01); // ["Kanboo", "Jack", "Rabbit", "Lucas"] includes在ES6提供了一個新方法：Array.prototype.includes()，判斷陣列中是否已有相同的值？ 有相同的值，回傳 true 無相同的值，回傳 false 123456789let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];let result_02 = [];for (let i = 0; i &lt; source.length; i++) &#123; let el = source[i]; if (!result_02.includes(el)) result_02.push(el);&#125;console.log("result_02", result_02); // ["Kanboo", "Jack", "Rabbit", "Lucas"] MDN-Array.prototype.includes() forEach將原本使用的 for迴圈 ，改使用 forEach 執行，省略掉定義 i、source.length…等動作。 12345678let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];let result_03 = [];source.forEach((el) =&gt; &#123; if (!result_03.includes(el)) result_03.push(el);&#125;);console.log("result_03", result_03); // ["Kanboo", "Jack", "Rabbit", "Lucas"] MDN-arr.forEach reduce()遍歷每個元素，依序組合、加總，然後丟給下個元素，最終會回傳一個結果 12345678910let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];let result_04 = source.reduce((p, c) =&gt; &#123; //includes 判斷是否已存在 if (!p.includes(c)) p.push(c); return p;&#125;, []);console.log("result_04", result_04); // ["Kanboo", "Jack", "Rabbit", "Lucas"] MDN-reduce() Set() + Array.from()Set 對象允許你存儲任何類型的唯一值，無論是原始值或者是對象引用。 Array.from() 會從類陣列(array-like)或是可迭代的物件建立一個新的陣列。 根據上述二種方法的特性，快速達成產生一個 已去除重覆值的新陣列 1234567let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];//1. 將 source資料 丟進 new set，使其產生一個新的 set集合 ，並且已去除重覆的值//2. 然後再將 set集合 丟進 Array.from，將 set集合的資料 轉化成 Array型態。(註：產生新陣列，不影響舊資料)let result_05 = Array.from(new Set(source));console.log("result_05", result_05); // ["Kanboo", "Jack", "Rabbit", "Lucas"] MDN-Array.from()MDN-Set()阮一峰-Set() Set() + Spread... 為 ES6的展開運算子（spread operator），把一個陣列展開(expand)成個別數值 簡寫1234567let source = ["Kanboo", "Jack", "Rabbit", "Lucas", "Jack", "Lucas", "Rabbit"];//1. 將 source資料 丟進 new set，使其產生一個新的 set集合 ，並且已去除重覆的值//2. 用 ...(展開運算子)，將 Set 轉換為 Array(註：...set外圈有個 中框號[]，用來轉換陣列型態)let result_06 = [...new Set(source)];console.log("result_06", result_06); // ["Kanboo", "Jack", "Rabbit", "Lucas"] 補充說明 ... 只是將 陣列、set 的值拆解一個一個的值，並無額外產生新陣列。 12345let number = [1,2,3,4,5];let mySet = new Set([1,2,3,4]);console.log(...number); // 1,2,3,4,5console.log(...mySet); // 1,2,3,4 PJ-…eddy-…]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Array</tag>
        <tag>Unique</tag>
        <tag>Reduce</tag>
        <tag>Set</tag>
        <tag>Spread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS-Nodemailer]]></title>
    <url>%2F2018%2F01%2F03%2FNodeJS-Nodemailer%2F</url>
    <content type="text"><![CDATA[NodeJS如何實現寄信 前言Mail寄送功能使用 Gmail 當作郵件伺服器，所以需先開通權限，開通後，就可以慢慢新增寄信的功能，以及額外優化的部份。 Gmail-低安全性應用程式 nodemailer - 發信功能的介接安裝 1$ npm install nodemailer --save 範例 實現基本寄信的功能，步驟如下 載入 Mail模組 設定 SMTP 相關資料 撰寫Mail相關內容 發送郵件 不過在實際寄信的過程，有出現錯誤訊息為 self signed certificate in certificate chain，此錯誤訊息，將在後面小節額外說明。 起手式1234567891011121314151617181920212223242526272829303132333435363738var express = require('express');var router = express.Router();var nodemailer = require('nodemailer'); // Mail模組//設定 SMTP 相關資料var transporter = nodemailer.createTransport(&#123; service: 'Gmail', secureConnection: true, // 使用SSL方式（安全方式，防止被竊取信息） auth: &#123; user: 'Gmail帳號', // generated ethereal user pass: 'Gmail密碼' // generated ethereal password &#125;, tls: &#123; // 不得檢查服務器所發送的憑證 rejectUnauthorized: false &#125;&#125;);//撰寫Mail相關內容var mailOptions = &#123; from: '"王康寶" &lt;wang.kanboo@gmail.com&gt;', // sender address to: 'wang.kanboo@gmail.com', // list of receivers subject: 'Node測試寄信', // Subject line text: '測試寄信內容', // plain text body html: '&lt;p&gt;HTML version of the message&lt;/p&gt;'&#125;;//發送郵件transporter.sendMail(mailOptions, function (error, info) &#123; if (error) &#123; return console.log(error); &#125; //轉址 res.redirect('/contact/review');&#125;) Nodemailer TLS - 傳輸層安全性協定在實際寄信的過程，有出現錯誤訊息為 self signed certificate in certificate chain，原因為Gmail為HTTPS協定，會發送的 CA 簽名的證書，而Node.js 客戶機驗證CA 簽名的證書，方法是根據CA 的公用證書檢查CA 簽名的證書，不過因為我們沒有 CA 的公用證書，所以我們需增加一個參數 rejectUnauthorized ，去忽略此驗證的動作。 新增 tls 的 rejectUnauthorized12345678910111213//設定 SMTP 相關資料var transporter = nodemailer.createTransport(&#123; service: 'Gmail', secureConnection: true, // 使用SSL方式（安全方式，防止被竊取信息） auth: &#123; user: 'Gmail帳號', // generated ethereal user pass: 'Gmail密碼' // generated ethereal password &#125;,+ tls: &#123;+ // 不得檢查服務器所發送的憑證+ rejectUnauthorized: false+ &#125;&#125;); self signed certificate in certificate chain node js? Allow self-signed certificates nodemailer 新增附件擷取 撰寫Mail相關內容 這一部份，新增 attachments 參數，並且該如何正確取得伺服器電腦上的附件。 注意的點： 附件路徑需設定 完整路徑 可透過 process.cwd() 取得目前專案的目錄，在延伸至放附件的路徑，如：path: process.cwd() + &#39;/public/attach/image.png&#39; 另外可新增 cid 的值，可供 郵件html 渲染出附件檔案。 新增附件12345678910111213141516171819//撰寫Mail相關內容var mailOptions = &#123; from: '"王康寶" &lt;wang.kanboo@gmail.com&gt;', // sender address to: 'wang.kanboo@gmail.com', // list of receivers subject: 'Node測試寄信', // Subject line html: req.body.description + '&lt;br/&gt;&lt;br/&gt;' ++ '&lt;img src="cid:image_001"/&gt;' + // 引用attachments的cid '&lt;br/&gt;' + '來自電子郵件：' + req.body.email, // plain text body+ attachments: [&#123;+ filename: 'text.txt',+ content: '軍整風綠業新！'+ &#125;, &#123;+ filename: 'image.png',+ path: process.cwd() + '/public/attach/image.png', // 附件路徑+ cid: 'image_001' //cid可被郵件使用+ &#125;]&#125;; 結果 What is the right way to set attachments path in nodeMailer? Nodemailer-Attachments CSURF - 阻擋跨站攻擊為了預防 跨站請求偽造 的攻擊，所以我們使用 CSURF模組 來協助我們驗證是否為本伺服器所發出的請求，簡單來說，就是利用 後端session 和 前端cookie 的配合，達成此驗證功能。 安裝 1$ npm install csurf --save 範例 載入模組後，建立CSURF驗證 在 get、post 之前，都需新增 middlewares 的卡控判斷。 在前端表單，新增一段 在 csrfToken的HTML，供驗證使用。 後端.js1234567891011121314151617181920212223242526272829var express = require('express');var router = express.Router();var nodemailer = require('nodemailer'); // Mail模組var csrf = require('csurf'); // 阻擋跨站攻擊(CSURF)// 建立一個cookie供CSURF驗證 - setup route middlewaresvar csrfProtection = csrf(&#123; cookie: true&#125;);//傳入CSURF的驗證router.get('/', csrfProtection, function (req, res) &#123; res.render('contact', &#123; csrfToken: req.csrfToken() //傳入csrfToken驗證資料 &#125;);&#125;);//接收資料時，驗證csrfToken是否正確router.post('/post', csrfProtection, function (req, res) &#123; /* your code */ res.redirect('/contact/review');&#125;); 前端表單：紀錄由後端提供的csrfToken123456789101112&lt;form action="/contact/post" method="post"&gt;+ &lt;input type="hidden" name="_csrf" value="&lt;%= csrfToken %&gt;"&gt; &lt;h1&gt;聯絡我們&lt;/h1&gt; &lt;div&gt; &lt;label for="email"&gt;電子郵件：&lt;/label&gt; &lt;input type="text" name="email" id="email"/&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="submit" value="送出" /&gt; &lt;/div&gt; &lt;/form&gt; CSURF dotenv - 環境變數設定可以將一些比較機密性的資料(帳號、密碼…等)，設置在環境變數裡，這樣的話，就算我們將專案上傳至github等公共環境，也不會將重要的資訊曝露在外。 安裝 1$ npm install dotenv --save 範例 在專案根目錄新增檔案 .env，並在將機密資料設定於此。 修改後端app.js，機密資料 改取自 dotenv環境變數。 .env檔案12gmailUser = Gmail帳號gmailPass = Gmail密碼 後端.js1234567891011121314151617181920var express = require('express');var router = express.Router();var nodemailer = require('nodemailer'); // Mail模組var csrf = require('csurf'); // 阻擋跨站攻擊(CSURF)+require('dotenv').config(); // 環境變數設定//設定 SMTP 相關資料var transporter = nodemailer.createTransport(&#123; service: 'Gmail', secureConnection: true, // 使用SSL方式（安全方式，防止被竊取信息） auth: &#123;+ // 帳密取自 dotenv環境變數+ user: process.env.gmailUser, // generated ethereal user+ pass: process.env.gmailPass // generated ethereal password &#125;, tls: &#123; // do not fail on invalid certs rejectUnauthorized: false &#125;&#125;); dotenv connect-flash - message的暫存器簡單來說，flash是一個暫存器，而且暫存器裡面的值使用過一次即被清空，這樣的特性很方面用來做網站的提示信息。 安裝 1$ npm install connect-flash --save 範例 注意：flash要配合session使用 後端app.js1234567891011121314var express = require('express');var session = require("express-session");var flash = require('connect-flash'); // message的暫存器var app = express();//使用connect-flash前，需先設定session相關設定，才能使用app.use(session(&#123; secret: 'iamkanboo', resave: true, saveUninitialized: true&#125;));app.use(flash()); // 啟用 message的暫存器(session設定完，才use) 驗證欄位是否有填寫，若有卡控訊息，則紀錄在 flash 內，並傳入 render ，供前端渲染畫面。 後端contact.js1234567891011121314151617181920212223router.get('/', csrfProtection, function (req, res) &#123; res.render('contact', &#123; csrfToken: req.csrfToken(), errors: req.flash('errors') //傳入 卡控訊息 &#125;);&#125;);router.post('/post', csrfProtection, function (req, res) &#123; //欄位卡控 if (req.body.username == '') &#123; console.log('username是空的'); req.flash('errors', 'username是空的'); // 紀錄 卡控訊息 res.redirect('/contact'); return; &#125; /* your code */ //轉址 res.redirect('/contact/review');&#125;); 前端：顯示卡控訊息123456789101112131415161718&lt;form action="/contact/post" method="post"&gt; &lt;input type="hidden" name="_csrf" value="&lt;%= csrfToken %&gt;"&gt;+ &lt;%= errors %&gt; &lt;h1&gt;聯絡我們&lt;/h1&gt; &lt;div&gt; &lt;label for="username"&gt;姓 名：&lt;/label&gt; &lt;input type="text" name="username" id="username"/&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="email"&gt;電子郵件：&lt;/label&gt; &lt;input type="text" name="email" id="email"/&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="submit" value="送出訊息" /&gt; &lt;/div&gt;&lt;/form&gt; express4.0之後使用connect-flash應該注意的問題 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Nodemailer</tag>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS-Cookie、Session]]></title>
    <url>%2F2018%2F01%2F02%2FNodeJS-CookieSession%2F</url>
    <content type="text"><![CDATA[紀錄Cookie、Session的差異，以及如何搭配使用。 COOKIE 與 SESSION 的比較與區別 Cookie-數據存放在客戶的瀏覽器上-用戶端的限制約4K-不存放機密資料，避免被他人解析，故僅存放 session id Session-數據放在伺服器上-session資料是 暫存 前端 Cookie寫入 Cookiedocument.cookie = &quot;myName=tom&quot;; 寫入 Cookie，並加入過期時間，document.cookie=&quot;username=bob; expires=Mon, 04 Dec 2017 08:18:32 GMT; path=/&quot;; GMT 時間new Date().toGMTString() 寫入 Cookie，設定 10 秒後失效document.cookie=&quot;username=bob; max-age=10; path=/&quot;; 後端 讀取Cookie、寫入Cookie安裝語法 1$ npm install cookie-parser --save cookie-parser 範例 app.js引用cookie-parser模組12345var express = require('express')var cookieParser = require('cookie-parser') // 解析cookie模組var app = express()app.use(cookieParser()) //解析前端cookie 「讀取」是用 req(Request) 「寫入」是用 res(Response) routes/index.js1234567891011121314151617181920212223242526var express = require('express');var router = express.Router();router.get('/', function (req, res, next) &#123; // 「讀取」是用 req(Request) // 讀取前端的cookies(全部) console.log(req.cookies); // 讀取前端的cookies(單個) console.log(req.cookies.userName); // 「寫入」是用 res(Response) // 後端寫入前端Cookies res.cookie('name', 'lulu', &#123; maxAge: 10000, // 只存在n秒，n秒後自動消失 httpOnly: true // 僅限後端存取，無法使用前端document.cookie取得 &#125;) res.render('index', &#123;title: 'Express'&#125;);&#125;);module.exports = router; 補充：Response.cookie(寫入) res.cookie(name, value [, options]) 參數： name: 設定cookie的名字 value: 設定其值，可能是字串或是轉成JSON格式的物件。 options: 選項參數是一個物件，所以，其屬性放在{}裡，以逗號分隔。 屬性： domain (字串) 適用此cookie的domain name encode (函式) 用於cookie編碼的同步函式，預設encodeURIComponent. expires (日期) cookie的到期日，超過此日期，即失效。 httpOnly (布林) 標記此cookie只能從web server 訪問，以避免不正確的進入來取得竄改。 maxAge (數字) 設定此cookie的生存時間(毫秒為單位)，比方60000(10分鐘後到期，必須重新訪問) path (字串) 適用此cookie的路徑，預設： “/”. secure (布林) 設定此cookie是否只在https使用。 signed (布林) 此cookie是否要設簽章。(如果是true，必須使用cookie-parser設定簽章 ) 官方-req.cookies(讀取)官方-res.cookie(寫入)Cookie在express上的應用 後端 session 儲存在伺服器的暫存資料，此暫存可放在記憶體或資料庫上 session可在cookie上儲存一筆辨識你是誰的 session id 安裝語法 1$ npm install express-session --save express-session session 常用參數 name：設置cookie中，保存session的字段名稱。(預設：connect.sid) store： session 的存儲方式。(預設：存放在內存(記憶體)中，也可以使用redis，mongodb 等) secret(必要選項)： 通過設置的 secret 字符串，來計算hash值並放在cookie 中，使產生的 signedCookie 防篡改。 genid：產生一個新的 session_id 時，所使用的函數。(預設：使用uid2這個npm包) rolling： 每個請求都重新設置一個cookie。(預設：false) resave： 即使 session 沒有被修改，也保存session 值。(預設：true) saveUninitialized：強制將未初始化的session存回 session store，未初始化的意思是它是新的而且未被修改。(預設：true) cookie： 設置存放 session id 的 cookie 的相關選項。 httpOnly：為設置true時，將不允許的 JavaScript 通過 document.cookie 訪問取得資料。 maxAge： number（毫秒），用於指定Set-Cookie的Expires屬性。設置後，Cookie將在指定時間後失效。 path： 用於指定Set-Cookie的Path屬性。默認會被設置為’/‘，即當前域名的根路徑。 secure： 設置為true時，使用非HTTPS連接時，當客戶端將不會回傳的Cookie。 cookie預設值123456default: &#123; path: '/', httpOnly: true, secure: false, maxAge: null &#125; 範例 當User登入後，伺服器先提供一組session id給你，並紀錄在 客戶的瀏覽器的cookie app.js1234567891011121314var express = require('express')var session = require('express-session')var app = express()//提供一組session idapp.use(session(&#123; secret: 'iamkanboo', // resave: true, saveUninitialized: true, cookie:&#123; maxAge: 100*1000 //100秒後過期 &#125;&#125;)) 表單點擊送出後，會將User資料 post 至後端 html架構12345678910111213&lt;body&gt; &lt;!-- 顯示user資料 --&gt; &lt;h1&gt;&lt;%= userName %&gt; &lt;%= email %&gt;&lt;/h1&gt; &lt;!-- 表單填寫區 --&gt; &lt;form method="post" action="/"&gt; &lt;input type="text" name="username" value=""&gt; &lt;input type="text" name="email" value=""&gt; &lt;input type="submit" value="送出"&gt; &lt;/form&gt;&lt;/body&gt; 前端post資料後，會先將user資料寫入 session暫存，再將網址導回index，並且傳入資料供渲染畫面。 index.js12345678910111213141516171819202122232425var express = require('express');var router = express.Router();/* GET home page. */router.get('/', function(req, res, next) &#123; //將user資料傳入index.ejs供渲染畫面 res.render('index', &#123; userName: req.session.username, email: req.session.email &#125;);&#125;);//接收前端傳入的資料router.post('/',function(req,res)&#123; //取得前端資料，並寫入至後端session暫存 req.session.username = req.body.username; req.session.email = req.body.email; //轉址至首頁 res.redirect('/');&#125;)module.exports = router; session 在 express 上的應用 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS-Express+Firebase]]></title>
    <url>%2F2018%2F01%2F01%2FNodeJS-Express-Firebase%2F</url>
    <content type="text"><![CDATA[紀錄如何使用 express + Firebase 設計 RESTful API Todoist 取得Firebase Admin SDK 開啟 專案設定 → 服務帳號 設定方法 安裝NPM npm install firebase-admin --save 複製Admin SDK 設定程式碼片段，貼至 app.js 下載Firebase金鑰(json檔案)，並修改Firebase金鑰路徑 完成設定 once、set 讀取、寫入雖然之前介紹firebase讀取的方式有 once、on 二種，不過在後端的話，只能使用 once 方式，因為 on 在後端並不會有同步更新的效果。 讀取 once12345var fireData = admin.database(); //取得Firebase的databasefireData.ref('todos').once('value', function (snapshot) &#123; console.log(snapshot.val());&#125;) 寫入方式一樣可以使用 set、push 二種。 寫入 set、push123456789var fireData = admin.database(); //取得Firebase的database// 寫法1fireData.ref('todos').set(&#123;title: '待辦清單'&#125;)// 寫法2fireData.ref('todos').push(&#123; content: '要去看電影'&#125;) then 設計思維將資料新增至firebase後，可用 then 接著查看firebase的資料是否有成功新增。 12345678910var fireData = admin.database(); //取得Firebase的database//將資料新增至firebase後，可用 then 接著查看firebase的資料是否有成功新增。fireData.ref('todos').push(&#123;content: '要去看電影'&#125;).then(function () &#123; //讀取todos，查看資料是否有寫入？ fireData.ref('todos').once('value', function (snapshot) &#123; console.log(snapshot.val()); &#125;)&#125;) EJS 整合 Firebase用 todolist 為例，說明如何將firebase上的待辦事項與後端整合，並呈現於網頁上。 範例 firebase資料 取得Firebase的todos資料，並將資料傳入index。 res.render 要放進 firebase function裡面，因為是用AJAX取得資料，所以要確保取得資料後，才進行傳遞參數的動作。 app.js1234567891011121314var fireData = admin.database(); //取得Firebase的database//路由app.get('/', function (req, res) &#123; fireData.ref('todos').once('value', function (snapshot) &#123; // console.log(snapshot.val()); var data = snapshot.val(); //render 要放進firebase function裡面，因為是用AJAX取得資料，所以要確保取得資料後，才進行傳遞參數的動作。 res.render('index', &#123; "todolist": data &#125;); &#125;)&#125;) 取得傳入的資料 todolist，使用ejs的forloop寫法，將資料渲染成HTML。 index.ejs12345678910111213&lt;h1&gt;待辦清單&lt;/h1&gt;&lt;input type="text" id="content" value=""&gt;&lt;input type="submit" id="send" value="送出"&gt;&lt;ul id="list"&gt; &lt;!-- forloop寫法 --&gt; &lt;% for(item in todolist)&#123; %&gt; &lt;li&gt; &lt;%- todolist[item].content %&gt; &lt;input type="button" data-id="&lt;%- item %&gt;" name="" value="刪除"&gt; &lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt; 新增資料API前端畫面輸入 待辦事項 後，點擊 送出 按鈕，此時會將資料 post 給 addTodo 路由，後端處理完後，再將結果傳送給前端更新畫面。 範例 後端app.js1234567891011121314151617181920var fireData = admin.database(); //取得Firebase的database// 新增邏輯app.post('/addTodo', function (req, res) &#123; var content = req.body.content; // 取得前端的content欄位資料 var contentRef = fireData.ref('todos').push(); //先設定寫入的方法為push // 當資料寫入成功後，並使用 then 回傳資料，送至前端渲染畫面 contentRef.set(&#123;"content": content&#125;).then(function () &#123; fireData.ref('todos').once('value', function (snapshot) &#123; // console.log(snapshot.val()); res.send(&#123; "succes": true, "result": snapshot.val(), //todos的資料 "message": "資料新增成功" &#125;); &#125;) &#125;)&#125;) 官方：先設定push的寫法 HTML架構1234567891011121314151617&lt;body&gt; &lt;h1&gt;待辦清單&lt;/h1&gt; &lt;input type="text" id="content" value=""&gt; &lt;input type="submit" id="send" value="送出"&gt; &lt;ul id="list"&gt; &lt;!-- forloop寫法 --&gt; &lt;% for(item in todolist)&#123; %&gt; &lt;li&gt; &lt;%- todolist[item].content %&gt; &lt;input type="button" data-id="&lt;%- item %&gt;" name="" value="刪除"&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;script src="/js/all.js"&gt;&lt;/script&gt;&lt;/body&gt; 前端all.js123456789101112131415161718192021222324252627282930313233343536373839404142434445var send = document.querySelector('#send');var content = document.querySelector('#content');var list = document.querySelector('#list');//新增APIsend.addEventListener('click', function (e) &#123; e.preventDefault(); var xhr = new XMLHttpRequest(); xhr.open('post', '/addTodo'); // 新增資料API xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8'); //取得輸入 待辦事項 var str = content.value; content.value = ""; var todo = JSON.stringify(&#123;"content": str&#125;); // 轉換成字串 xhr.send(todo); //AJAX回傳後的結果 xhr.onload = function () &#123; var originData = JSON.parse(xhr.responseText); // console.log(originData); //重載todoList reloadList(originData); &#125;&#125;)//Reload todoListfunction reloadList(originData) &#123; if (originData.success === false) &#123; alert(originData.message); return; &#125; var data = originData.result; var str = ''; for (item in data) &#123; str += '&lt;li&gt;' + data[item].content + '&lt;input type="button" data-id="' + item + '" name="" value="刪除"&gt;' + '&lt;/li&gt;' &#125; list.innerHTML = str;&#125; 刪除資料API前端點擊 刪除 按鈕，此時會將刪除按鈕的 data-id 資料 post 給 removeTodo 路由，後端處理完後，再將結果傳送給前端更新畫面。 範例 後端app.js12345678910111213141516// 刪除邏輯app.post("/removeTodo", function (req, res) &#123; var _id = req.body.id; // 取得刪除按鈕的 data-id //刪除todos的資料成功後，並使用 then 回傳資料，送至前端渲染畫面 fireData.ref('todos').child(_id).remove().then(function () &#123; fireData.ref('todos').once('value', function (snapshot) &#123; // console.log(snapshot.val()); res.send(&#123; "succes": true, "result": snapshot.val(), "message": "資料刪除成功" &#125;); &#125;) &#125;)&#125;) 在每一個的INPUT(刪除按鈕)上，新增data-id屬性，紀錄firebase的Key值。 HTML架構1234567891011121314151617&lt;body&gt; &lt;h1&gt;待辦清單&lt;/h1&gt; &lt;input type="text" id="content" value=""&gt; &lt;input type="submit" id="send" value="送出"&gt; &lt;ul id="list"&gt; &lt;!-- forloop寫法 --&gt; &lt;% for(item in todolist)&#123; %&gt; &lt;li&gt; &lt;%- todolist[item].content %&gt; &lt;input type="button" data-id="&lt;%- item %&gt;" name="" value="刪除"&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;script src="/js/all.js"&gt;&lt;/script&gt;&lt;/body&gt; 下例 前端all.js ，是針對 ul 進行監聽，進而判斷點擊的元素是否為INPUT(刪除按鈕)，這樣就不用針對 n個的刪除按鈕 建立監聽事件，以達到優化的效果。 前端all.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var send = document.querySelector('#send');var content = document.querySelector('#content');var list = document.querySelector('#list');//刪除APIlist.addEventListener('click', function (e) &#123; //判斷元素是否為 INPUT(刪除按鈕) if (e.target.nodeName !== "INPUT") &#123; return; &#125; var xhr = new XMLHttpRequest(); xhr.open('post', '/removeTodo'); // 刪除API xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8'); //取得輸入 data-id 資料 var id = e.target.dataset.id; var todo = JSON.stringify(&#123;"id": id&#125;); // 轉成字串 xhr.send(todo); //AJAX回傳後的結果 xhr.onload = function () &#123; var originData = JSON.parse(xhr.responseText); // console.log(originData); //重載todoList reloadList(originData); &#125;&#125;)//Reload todoListfunction reloadList(originData) &#123; if (originData.success === false) &#123; alert(originData.message); return; &#125; var data = originData.result; var str = ''; for (item in data) &#123; str += '&lt;li&gt;' + data[item].content + '&lt;input type="button" data-id="' + item + '" name="" value="刪除"&gt;' + '&lt;/li&gt;' &#125; list.innerHTML = str;&#125; 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Firebase</tag>
        <tag>Express</tag>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-基礎用法]]></title>
    <url>%2F2017%2F12%2F30%2FJS-studynotes%2F</url>
    <content type="text"><![CDATA[Selector - 選擇元素 element = document.querySelector(selectors); element 是元素物件。 selectors 是以逗號分隔，包含一個或多個 CSS 選擇器的字串。 選擇單一元素 querySelector12//回傳第一個符合條件的元素var el = document.querySelector('#titleId'); 選擇多個元素 querySelectorAll12//回傳符合條件的元素var el = document.querySelectorAll('.titleClass'); Attribute - 增加標籤屬性 setAttribute 設定 設定 標籤屬性12var el = document.querySelector('.titleClass a');el.setAttribute('href','http://www.yahoo.com.tw'); getAttribute 取得 取得 標籤屬性12var el3 = document.querySelector('.titleClass a').getAttribute('href');console.log(el3); innerHTML - 插入HTML將元素內的html重新覆蓋寫入新的html。 插入HTML123var el = document.getElementById('main');var str = '&lt;h1 class="blue"&gt;1234&lt;/h1&gt;'el.innerHTML = str; createElement - 插入dom元素建立一個新的DOM元素，然後再使用 appendChild 新增子節點，並不會覆蓋原有的DOM元素。 新增dom元素1234567891011121314&lt;h1 class="title"&gt; &lt;em&gt;titile&lt;/em&gt;&lt;/h1&gt;&lt;script &gt; // 建立元素 var sonElement = document.createElement("a"); sonElement.setAttribute('href','www.facebook.com'); sonElement.textContent = '前往Facebook'; // 增加子節點 var fatherElement = document.querySelector('.title'); fatherElement.appendChild(sonElement);&lt;/script&gt; 更新後結果1234&lt;h1 class="title"&gt; &lt;em&gt;titile&lt;/em&gt;+ &lt;a href="www.facebook.com"&gt;前往Facebook&lt;/a&gt;&lt;/h1&gt; 使用 appendChild 要注意的小細節：要留意的是 如果 appendChild 使用時，append 上去的是一個已存在的 node 時，它會做的是搬移，而非複製，所以 appendChild 使用時要複製而非搬移，記得先使用 Node.cloneNode() 這個方法複製 Node Element。參考：PJ - Node Element 在 appendChild 後消失（disappear）!? addEventListener - 事件氣泡、事件捕捉基本語法 element.addEventListener(event, function, useCapture) 第三個參數：可省略，預設為 false。 範例 可試試將第三個參數分別改成 true 、 false，各執行一次，會有什麼不一樣的結果。 html123&lt;div class="warp"&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/div&gt; 預設：事件氣泡-從指定元素往外找12345678910111213var el = document.querySelector('.box');el.addEventListener('click',function()&#123; alert('box'); console.log('box');&#125;,false);var elBody = document.querySelector('.body');elBody.addEventListener('click',function()&#123; alert('body'); console.log('body');&#125;,false);// false (事件氣泡 - event Bubbling) - 從指定元素往外找// true (事件捕捉 - event capturing) - 從最外面找到指定元素 See the Pen addEventListener - 事件氣泡、事件捕捉 by Kanboo (@Kanboo) on CodePen. stopPropagation - 中止冒泡行為依上例 addEventListener-事件氣泡 因素，有時只是想單純針對單一元素監聽，不想因為事件冒泡的行為，而去觸發到其他元素，這時就可利用 stopPropagation 來達成此需求。 123456var el = document.querySelector('.box');el.addEventListener('click',function(e)&#123;+ e.stopPropagation(); // 中止冒泡行為 alert('box'); console.log('box');&#125;,false); 事件監聽優化 &amp; e.target有時子元素可能要上千個，每個都要綁上監聽的話，效能不是很優，這時可從父節點下手，使用 e.target.nodeName 判斷是否為 想監聽的子元素，若是為想監聽的子元素，可再用 e.target.value 或是 e.target.textContent 取得 值。 e.target.nodeName 取得點擊元素的標籤名稱，如：UL、LI、INPUT… e.target.value 取得選取元素的值 範例 當有一個 ul 底下有多個 li 都要監聽的話，這時我們可以利用 addEventListener-事件氣泡 的原理，只要針對 ul 監聽，讓他往上冒泡，當到達 li 時，這時我們就可以針對 li 做事了。 原始寫法1234567891011//取得ul底下的所有li元素var list = document.querySelectorAll('.list li');//forloop，將每個li元素綁上監聽事件(N次)var len = list.length;for(var i = 0;len&gt;i;i++)&#123; list[i].addEventListener('click',checkName,false)&#125;function checkName(e)&#123; console.log(e.target.textContent);&#125; 優化寫法123456789//取得ul元素var list = document.querySelector('.list');//將ul元素綁上監事件(一次)list.addEventListener('click',checkName,false)function checkName(e)&#123; if(e.target.nodeName !== 'LI')&#123;return&#125;; // 判斷是否為li元素 console.log(e.target.textContent);&#125; preventDefault - 取消預設觸發行為比較常用在 a連結的href、Form表單的submit 上，有時可能只是想觸發呼叫Function，而不想使用到原生附與的功能的話，就可利用 preventDefault 達成此需求。 取消預設觸發行為123456var list = document.querySelector('a');list.addEventListener('click',function(e)&#123; e.preventDefault(); //取消預設觸發行為 /* 撰寫你的Code */&#125;) localStorage - 灠瀏器資料儲存基本語法 儲存1localStorage.setItem('countryItem',countryString); 讀取1localStorage.getItem('countryItem'); 範例 localstorage 只能保存 string 資料，所以當資料非字串型態的話，記得轉為字串string。 JSON.stringify() 將 array 轉為 stringJSON.parse() 將 string 轉為 array 1234567891011121314var country = [ &#123;farmer:'王農夫'&#125;];//儲存var countryString= JSON.stringify(country); // 轉字串console.log(countryString);localStorage.setItem('countryItem',countryString);//讀取var getData = localStorage.getItem('countryItem');var getDataAry = JSON.parse(getData); // 轉arrayconsole.log(getDataAry[0].farmer); 補充小知識var data = listData;var data2 = listData || []; //(建議寫法)console.log(‘沒有 []’, data); // 有可能取得資料或 undefinedconsole.log(‘加上 []’, data2); // 有可能 data-* - 透過 dataset 讀取自訂資料 名字絕對不能以 xml 起頭，無論是否用於 xml、 名字絕對不能包含分號（U+003A）、 名字絕對不能包含大寫 A 到大小 Z 的拉丁字母。 可透過 HTMLElement.dataset.testValue 或 HTMLElement.dataset[“testValue”] 訪問 1234567891011121314&lt;div id="user" data-id="1234567890" data-user="johndoe" data-date-of-birth&gt;John Doe&lt;/div&gt;let el = document.querySelector('#user');// el.id == 'user'// el.dataset.id === '1234567890'// el.dataset.user === 'johndoe'// el.dataset.dateOfBirth === ''el.dataset.dateOfBirth = '1960-10-03'; // set the DOB.// 'someDataAttr' in el.dataset === falseel.dataset.someDataAttr = 'mydata';// 'someDataAttr' in el.dataset === true AjAX屬性 readyState: ０：尚未讀取 １：讀取中 ２：已下載完畢 ３：資訊交換中 ４：處理完畢 Status:即HTTP協定的狀態碼 當 readyState == 4，代表有執行完成，但不一定是有正確撈到資料，要配合HTTP status == 200，才代表是正確撈到資料。 範例 利用AJAX傳送(POST)帳號、密碼資料至後端註冊會員帳號。 POST資料123456789101112131415161718192021222324252627282930313233343536373839var send = document.querySelector('.send');send.addEventListener('click',signup,false);function signup()&#123; var emailStr = document.querySelector('.account').value; var passwordStr = document.querySelector('.password').value; //資料丟到物件 var account = &#123;&#125;; account.email = emailStr; account.password = passwordStr; var xhr = new XMLHttpRequest(); xhr.open('post','https://hexschool-tutorial.herokuapp.com/api/signup',true); xhr.setRequestHeader('Content-type','application/json'); //宣告json格式 var data = JSON.stringify(account); //轉成字串 xhr.send(data); // 送出 //ajax完成後，執行此event xhr.onload = function()&#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // 萬事具備 var callbackData = JSON.parse(xhr.responseText); //接收回傳後資料 console.log(callbackData); var veriStr = callbackData.message; if(veriStr =="帳號註冊成功")&#123; alert('帳號註冊成功！！'); &#125;else&#123; alert("帳號註冊失敗！"); &#125; &#125; else &#123; // 似乎有點問題。 // 或許伺服器傳回了 404（查無此頁） // 或者 500（內部錯誤）什麼的。 alert ("伺服器處理錯誤"); &#125; &#125;&#125; ajax回傳的格式12345&#123; "success": true, "result": &#123;'結果'&#125;, "message": "登入成功"&#125; Asynchronous JavaScript And XML]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS-Express]]></title>
    <url>%2F2017%2F12%2F27%2FNodeJS-Express%2F</url>
    <content type="text"><![CDATA[基本語法下列語法為 express 的起手式，後面會慢慢新增功能。 後端app.js123456789101112131415161718192021var express = require('express'); //引用express模組var app = express();/* app.get參數說明 req 是 Request 物件，存放這此請求的所有資訊res 是 Response 物件，用來回應該請求*/// 路由 routeapp.get('/',function(req,res)&#123; // res.send('1234'); res.send('&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hi!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;')&#125;)// 監聽 portvar port = process.env.PORT || 3000;app.listen(port); //執行 node app.js//網頁連結 http://127.0.0.1:3000/ params - 取得指定路徑透過 :name 這個變數，再配合 req.params 搭配使用，可取得路由的值。 PS：設定為變數的重點為前面加個冒號。 後端app.js1234567891011121314//http://127.0.0.1:3000/user/kanbooapp.get('/user/:name', function (req, res) &#123; console.log(req.params); var myName = req.params.name; console.log(myName); if ( myName !== 'kanboo')&#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;'+'查無此人'+'&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'); &#125;else&#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;'+myName+'&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'); &#125;&#125;) 下列範例為可設多個變數(:name、:data)，取得路由的值。 後端app.js12345678910//http://127.0.0.1:3000/user/kanboo/abcdapp.get('/user/:name/:data', function (req, res) &#123; console.log(req.params); var myName = req.params.name; // kanboo var myData = req.params.data; // abcd console.log(myName,myData); res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + myName + '&lt;br&gt;' + myData + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;) query - 取得網址參數以 http://127.0.0.1:3000/user/kanboo?limit=100&amp;q=張惠妹 這段網址為例，我要用從?(問號)切開，前段網址：http://127.0.0.1:3000/user/kanboo後段網址：limit=100&amp;q=張惠妹 要取得前段網址的資料可用 params ，若要取後段網址的資料就要用 query。 下列示範利用 req.query 取得 後段 網址的參數 後端app.js12345678910111213141516171819202122//網址：http://127.0.0.1:3000/user/kanboo?limit=100&amp;q=張惠妹app.get('/user/:name', function (req, res) &#123; console.log(req.params); console.log(req.query); var myName = req.params.name; var limit = req.query.limit; // limit = 100 var q = req.query.q; //q = 張惠妹 console.log(myName); console.log(limit); console.log(q); res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + 'myName:' + myName + '&lt;br&gt;' + '搜尋:' + q + '&lt;br&gt;' + '筆數：' + limit + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//http://127.0.0.1:3000/user/kanboo?limit=100&amp;q=張惠妹 Middleware - 中介層簡單來說，Middleware的功能就有點像卡控機制，例如：我要進去會員頁面時，Middleware可以幫我先確認是否已登入，再看要不要放行？ 範例 當我網址要切換至 http://127.0.0.1:3000/user 頁面時，此時可利用 app.use 先確認是否已登入，再決定是否使用 next() 放行，可讀取到 app.get。 後端app.js12345678910111213141516171819202122232425262728293031//網址：http://127.0.0.1:3000/user/* app.use參數說明 req 是 Request 物件，存放這此請求的所有資訊res 是 Response 物件，用來回應該請求next 用來控制流程，是否可繼續執行*/app.use(function (req, res, next) &#123; //這裡可以撰寫 驗證的Code var isVerification = true; if (isVerification === true) &#123; console.log('驗證成功!!'); next(); &#125;&#125;)/* 注意：使用 app.use 的話，要放在 app.get 的前面，否則就沒有作用！*/app.get('/user', function (req, res) &#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + 'user' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//http://127.0.0.1:3000/user 注意：使用 app.use 的話，要放在 app.get 的前面，否則就沒有作用！ Middleware - 404頁面假設user開到一個錯誤的網址 http://127.0.0.1:3000/alskdjlasdjf，而根本無此網頁的話，這時會客制一個404頁面回應給user知道無此網頁。 範例 利用 res.status(404) 判斷當無此頁面時，回應 抱歉，你的頁面找不到 的訊息給User知道。 後端app.js123456789// 網址：http://127.0.0.1:3000/alskdjlasdjf// 404頁面 app.use(function (req, res, next) &#123; res.status(404).send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + '抱歉，你的頁面找不到' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//http://127.0.0.1:3000/alskdjlasdjf Middleware - 錯誤頁面另一種情形是當user要進入某個頁面時，有可能是程式碼執行有誤，這時我們可以先將畫面切換至一個客制的錯誤頁面，告知User待修復，稍後嘗試。 範例 程式碼執行 cc() 這個Function出錯了，這時利用 app.use 的新參數 err ,接收程式碼的錯誤訊息，並回應User系統有誤待修復。 後端app.js12345678910111213141516// 錯誤程式碼的狀況app.use(function (req, res, next) &#123; cc(); // 執行不存在的Function next(); // 放人通行..&#125;)// 錯誤頁面 app.use(function (err, req, res, next) &#123; console.log(err.stack); res.status(500).send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + '程式有些問題，請稍後嘗試。' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;) Middleware - 中介function呼叫假設我們有很多頁面要進入時，都需要先確認user是否已登入，才能進入頁面的話，這時我們可以將 確認登入程式碼(isLogin) 包成一個 Function，然後在 app.get 插入 isLogin 進行確認。 範例 下列重點為 isLogin 插入的位置，app.get(‘/‘, isLogin, function (req, res){ 程式碼 }) 後端app.js12345678910111213141516171819202122232425262728293031323334353637383940var isLogin = function (req, res, next) &#123; //這裡可以撰寫 驗證的Code var _url = req.url; console.log(_url); console.log(_url !== '/'); if (_url === '/') &#123; console.log('登入成功!!'); next(); &#125; else &#123; console.log('登入失敗!!'); res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + '登入失敗' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'); &#125;&#125;// 開啟頁面前，先驗證 isLogin 是否成功app.get('/', isLogin, function (req, res) &#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + 'Hello' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)// 開啟頁面前，先驗證 isLogin 是否成功app.get('/user', isLogin, function (req, res) &#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + 'Hello' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//http://127.0.0.1:3000///http://127.0.0.1:3000/user static - 載入靜態檔案若我們在頁面需要提供「圖片、txt檔…」等檔案，如下列範例需使用到 img圖檔，我們要先利用 express.static 指定我們的目錄起點在哪，這樣img圖檔的路徑才能使用相對路徑取得資源。 範例 後端app.js12345678910111213141516171819202122var express = require('express');var app = express();//增加靜態檔案的路徑app.use(express.static('public')); // 設定 目錄起點位置app.get('/', function (req, res) &#123; res.send('&lt;html&gt;&lt;body&gt;&lt;h1&gt;' + '&lt;img src="/img/logo.png" &gt;'+ 'Hello' + '&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');&#125;)//監聽portvar port = process.env.PORT || 3000;console.log(port);app.listen(port);//執行 node app.js//網頁連結 http://127.0.0.1:3000/ 示意圖 EJS - 樣板語言安裝語法1$ npm install ejs-locals --save 使用方法 宣告 樣板語言 使用 res.render 讀取哪個ejs檔案，如：res.render(‘index‘) 後端app.js1234567891011121314151617var express = require('express');var app = express();//增加靜態檔案的路徑app.use(express.static('public')); // 設定 目錄起點位置//宣告 樣板語言var engine = require('ejs-locals');app.engine('ejs',engine);app.set('views','./views'); // 設定「樣板程式碼」放在哪裡app.set('view engine','ejs'); // 設定「樣板語言」是用哪種？ejs、pug、handlebarsapp.get('/', function (req, res) &#123; res.render('index'); //渲染 index.ejs 的檔案&#125;)//http://127.0.0.1:3000/ 示意圖 EJS - 參數導入除了一般將.ejs檔案渲染成HTML外，有時也會因為條件的不同，要渲染出不一樣的HTML格式，這時就可以透過參數的傳遞，來達成此需求。 範例 下列範例示範 res.render，如何傳送參數以及ejs接收參數的寫法 傳送 參數12345678910app.get('/', function (req, res) &#123; res.render('index', &#123; 'title': '我是傳入的值', 'dog': '狗狗', 'html': '&lt;h1&gt;我是HTML&lt;/h1&gt;', 'show': true, 'course': ['html','js','css'], &#125;);&#125;)//http://127.0.0.1:3000/ ejs接收參數的寫法123456789101112131415161718192021222324&lt;!-- = 是 渲染成字串- 是 渲染成HTML--&gt;&lt;%= html %&gt;=&gt; &lt;h1&gt;我是HTML&lt;/h1&gt;&lt;%- html %&gt;=&gt; 我是HTML&lt;!-- if寫法 --&gt;&lt;% if(show)&#123; %&gt;&lt;h1&gt;條件成立，顯示222!!&lt;/h1&gt;&lt;% &#125; %&gt;&lt;!-- forloop寫法 --&gt;&lt;ul&gt; &lt;% for(var i=0;course.length&gt;i;i++)&#123; %&gt; &lt;li&gt; &lt;%- course[i] %&gt; &lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt; EJS - 設定layout當有很多頁面都有用到共同的元素(如：表頭、表尾…等)，這時我們可以將會一直重覆的區塊取出，撰寫在 layout.ejs，若有其他頁面需要表頭、表尾的部份，我只要將layout.ejs include在頁面即可。 範例 layout.ejs 將共用的部份撰寫在 layout.ejs 新增 &lt;%- body %&gt; 這段語法，代表要放置不同頁面各自的內容。 layout.ejs1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; 表頭共用的部份(logo、navbar...等) &lt;/header&gt; &lt;%- body %&gt; &lt;footer&gt; 表尾共用的部份(作者、版權信息或者相關鏈接...等) &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; search.ejs 在頁面寫入 &lt;% layout(&#39;layout&#39;) %&gt; 這段語法，代表載入共用HTML部份。 接著開始撰寫HTML內容，而撰寫好的HTML，就會放置在layout.ejs檔案裡的&lt;%- body %&gt;位置。 search.ejs搜尋頁面12345678910&lt;!-- 共用元素 --&gt;&lt;% layout('layout') %&gt;&lt;!-- 表單內容 --&gt;&lt;form action="/searchList" method="post" &gt; &lt;input type="text" name="content" id="content" value=""&gt; &lt;input type="submit" id="send" value="送出"&gt;&lt;/form&gt;&lt;script src="/js/all.js"&gt;&lt;/script&gt; body-parser - 取得表單資料(傳統表單)安裝語法 1$ npm install body-parser --save 範例 在search搜尋頁面的 searchText 輸入搜尋文字後，點擊送出按鈕 此時會將表單資料傳送(post)給/searchList 再透過後端 req.body 取得到表單資料，進行後續解析。 search搜尋頁面123456789&lt;form action="/searchList" method="post" &gt; &lt;input type="text" name="searchText" value=""&gt; &lt;input type="submit" value="送出"&gt; &lt;!-- 只有id的話，body-parser無法解析 --&gt; &lt;!-- &lt;input type="text" id="idflied" value=""&gt; --&gt;&lt;/form&gt; 後端app.js123456789101112131415161718192021222324var bodyParser = require('body-parser');// 增加 body 解析app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false&#125;))//搜尋頁面app.get('/search', function (req, res) &#123; res.render('search');&#125;)//http://127.0.0.1:3000/search//傳統表單app.post('/searchList', function (req, res) &#123; //所有body欄位資料 console.log(req.body); //取得某欄位資料 console.log(req.body.searchText); //轉址 res.redirect('search'); // 將畫面導回搜尋頁面&#125;) 搜尋頁面(search) 是使用 app.get接收表單頁面(searchList) 是使用 app.post在searchList處理完資料後，最後記得將畫面導回搜尋畫面 res.redirect(‘search’); body-parser - 取得表單資料(AJAX)若達到頁面不跳轉，就可回應相關訊息，此時就需要透過AJAX的方式，達到此需求。 範例 新增一路由 searchAJAX，用來處理搜尋的相關資料，最後回傳給前端。 後端app.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var express = require('express');var app = express();var bodyParser = require('body-parser');//增加靜態檔案的路徑app.use(express.static('public'));//宣告 樣板語言var engine = require('ejs-locals');app.engine('ejs', engine);app.set('views', './views'); // 樣板放在哪裡？app.set('view engine', 'ejs'); // 宣告樣板是用哪種語言？ejs、pug、handlebars// 增加 body 解析app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false&#125;))//搜尋頁面app.get('/search', function (req, res) &#123; res.render('search');&#125;)//http://127.0.0.1:3000/search//AJAXapp.post('/searchAJAX', function (req, res) &#123; //所有body欄位資料 console.log(req.body); console.log(req.body.list[1]); /* 這裡撰寫程式碼 */ //回傳結果 res.send('Hello!');&#125;)//監聽portvar port = process.env.PORT || 3000;console.log(port);app.listen(port);//執行 node app.js//網頁連結 http://127.0.0.1:3000/ 重點在於我們將原本在搜尋頁面的 send按鈕 要Submit的動作取消 e.preventDefault();，改用 AJAX 方式，將表單的內容資料，利用 post 給 searchAJAX。 前端all.js123456789101112131415161718192021222324252627282930313233var send = document.querySelector('#send');var content = document.querySelector('#content');send.addEventListener('click', function (e) &#123; e.preventDefault(); var str = content.value; console.log(str); var xhr = new XMLHttpRequest(); xhr.open('post', '/searchAJAX'); //發送給哪個路由 //組合表單資料(文字型態) // xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); // var data = 'content=' + str; // content=123&amp;title=abc //組合表單資料(json型態) xhr.setRequestHeader("Content-type", "application/json"); var searchlist = &#123; "content": str, "list": [1, 2, 3] &#125;; var data = JSON.stringify(searchlist); //轉成字串 //發送表單資料給後端app.js處理 xhr.send(data); //取得後端app.js回傳的資料 xhr.onload = function () &#123; console.log(xhr.responseText); &#125;&#125;) Router - 進階設定當我們網站有越來越多頁面的話，不可能把所有網頁的路由判斷在寫app.js裡，這樣會造成程式碼雜亂，導致後續維護不便，所以我們可以將同類型頁面分別包裝在不同js檔裡，並且使用 module(模組) 輸出，可供 app.js 分別載入，以達到程式碼的簡潔易懂。 範例 app.js 分別載入 user模組(個人資料)、cart模組(購物車) ，讓整個app.js變得簡潔易懂。 後端app.js1234567891011121314151617181920var express = require('express');var user = require('./routes/user.js') // 載入 user模組(個人資料)var user = require('./routes/cart.js') // 載入 cart模組(購物車)var app = express();//網址若為 http://127.0.0.1:3000/user/... 之類的話，就會進去user模組執行。app.use('/user',user);//網址若為 http://127.0.0.1:3000/cart/... 之類的話，就會進去cart模組執行。app.use('/cart',cart);//監聽portvar port = process.env.PORT || 3000;app.listen(port);//執行 node app.js//網頁連結 http://127.0.0.1:3000/ 以user模組(個人資料)為例，因外部引用此模組，語法設定為 app.use(‘/user‘,user);所以網址起頭從 http://127.0.0.1:3000//user/ 開始 user.js12345678910111213141516171819202122232425262728293031var express = require('express');var router = express.Router(); // 路由器//因外部引用此模組，語法為 app.use('/user',user);//所以網址起頭從 http://127.0.0.1:3000/user/ 開始router.get('/edit-porfile', function (req, res) &#123; //若網址為 http://127.0.0.1:3000/user/edit-porfile 進行此function console.log('porfile頁面'); res.send('porfile');&#125;)router.get('/photo', function (req, res) &#123; //若網址為 http://127.0.0.1:3000/user/photo 進行此function console.log('photo頁面'); res.send('photo');&#125;)router.get('/card', function (req, res) &#123; //若網址為 http://127.0.0.1:3000/user/card 進行此function console.log('card頁面'); res.send('card');&#125;)/* 原先都是使用 app.get ，要改用成 router.get*/module.exports = router; 注意 user.js，原先都是使用 app.get ，要改用成 router.get express-generator - 應用程式產生器經過上述種種的介紹，了解express各種的使用方式後，之後我們可以利用 Express應用程式產生器 ，自動幫我們生成一個專案的基本架構，就無須從頭到尾慢慢建構。 安裝語法 1$ npm install express-generator -g 建立語法 建立 express 專案資料 1$ express -e project 切換至專案目錄，並安裝 NPM 套件 12$ cd project$ npm install 運行專案 1$ npm start 專案網址：http://127.0.0.1:3000/ 專案初始化 下列為 專案初始化 之程式碼，後面可在依據需求新增其他功能模組，如：express-session、nodemailer(寄信)、csurf(阻擋跨站攻擊)、connect-flash(message暫存器)、dotenv(環境變數設定)、firebase-admin(資料庫)…等 後端app.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var express = require('express');var path = require('path'); // 抓取目錄路徑var favicon = require('serve-favicon'); // 設定iconvar logger = require('morgan'); // 日誌var cookieParser = require('cookie-parser'); // 解析前端cookievar bodyParser = require('body-parser'); // 取得前端表單資料// 自行撰寫頁面部份var index = require('./routes/index'); // 載入 index模組(首頁)var users = require('./routes/users'); // 載入 user模組(個人資料)var app = express();// view engine setup - 樣版語言設定app.set('views', path.join(__dirname, 'views'));app.set('view engine', 'ejs');// uncomment after placing your favicon in /public//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico'))); // 設定icon的路徑app.use(logger('dev'));app.use(bodyParser.json()); // 解析表單資料-jsonapp.use(bodyParser.urlencoded(&#123; extended: false &#125;)); // 解析表單資料-URL-encoded格式app.use(cookieParser()); // 解析前端cookieapp.use(express.static(path.join(__dirname, 'public'))); // 設定 靜態檔案的目錄起點位置// 路由區塊----Startapp.use('/', index); //網址若為 http://127.0.0.1:3000/... ，就會進去 index模組 執行。app.use('/users', users); //網址若為 http://127.0.0.1:3000/user/...，就會進去 user模組 執行。// 路由區塊----End// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; var err = new Error('Not Found'); err.status = 404; next(err);&#125;);// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render('error');&#125;);module.exports = app; 官方：Express應用程式產生器 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Firebase-基礎用法]]></title>
    <url>%2F2017%2F12%2F26%2FFirebase-studynotes%2F</url>
    <content type="text"><![CDATA[ref(路徑)、set(新增)ref()：尋找資料庫路徑(預設：根目錄)set()：新增資料(寫入方式：覆蓋) 新增資料：範例11firebase.database().ref().set('hi'); 結果 新增資料：範例2(物件)1234567891011121314// firebase 全部物件格式，不能陣列內容// 一個班級有兩個學生var school = &#123; student1: &#123; name: 'tom', num: '1' &#125;, student2: &#123; name: 'john', num: '2' &#125;&#125;firebase.database().ref().set(school); 結果 補充 延續範例2，若要再新增 student3 的話，因為 set 寫入的方式是 覆蓋，所以要注意 ref 是否有指定到正確的新增位置，不然有可能會覆蓋到原來的資料。 新增student31234567var student3= &#123; name: 'kanboo', num: '3'&#125;// ref 要先指定到 新增的路徑firebase.database().ref('student3').set(student3); 新增資料：範例3(階層式)123456//寫入資料firebase.database().ref('myName').set('kanboo');firebase.database().ref('yourName').set('alice');firebase.database().ref('allName/name01').set('aa');firebase.database().ref('allName/name02').set('bb');firebase.database().ref('allName/nameList/name01').set('cc'); 結果 once、on 讀取資料 once(讀取一次資料庫的資料) 僅向firebase取得一次性資料，所以當firebase資料有異動，需要再一次呼叫，才會取得更新後的資料。 123456var myNameRef = firebase.database().ref('allName/nameList/name01');// 快照myNameRef.once('value', function (snapshot) &#123; console.log(snapshot.val()); document.getElementById('title').textContent = snapshot.val();&#125;) on(隨時監聽) 當firebase資料有異動時，會即時回傳更新資料。 123456var myNameRef = firebase.database().ref('allName/nameList/name01');//on 隨時監聽myNameRef.on('value', function (snapshot) &#123; console.log(snapshot.val()); document.getElementById('title').textContent = snapshot.val();&#125;) push - 新增資料以 Todolist 為例，因為資料隨時會新增，不可能一次就能把所有資料打齊上傳至database，所以就需要借用 push 功能，將 新資料 加在 現有資料 裡。 Todolist：新增待辦123var todos = firebase.database().ref('todos');todos.push(&#123;content:'要去看電影'&#125;);todos.push(&#123;content:'要去看跑步'&#125;); 結果 push 會自動給一個亂數編號，如果不想產生隨機編號的話，就使用set方式。set 可以給固定的編號，但要注意新增的位置是否指定正確，要小心覆蓋掉已有的資料。 child 子路徑、remove 移除以 Todolist 為例，當完成某項事件時，就要將它從待辦清單 移除。 Todolist：移除待辦123456// child 子路徑：移至根目錄下的 todos var todos = firebase.database().ref().child('todos');// remove 移除：移除todos下的 -L1H5cAAQnE9y72dCpJ7(要去看電影)todos.child('-L1H5cAAQnE9y72dCpJ7').remove(); 結果 在網頁即時顯示firebase資料可以用 on(隨時監聽) 的特性，隨時將firebase最新的資料回傳更新，這樣在開發時，就不用特地再開firebase的網頁觀看資料，節省切換頁面的時間。 HTML1&lt;pre id="content"&gt;&lt;/pre&gt; js12345// 在網頁即時顯示firebase資料var ref = firebase.database().ref();ref.on('value', function (snapshot) &#123; document.getElementById('content').textContent = JSON.stringify(snapshot.val(), null, 3);&#125;) JSON.stringify補充說明 orderbyForeach 排序從firebase取得有 排序 過後的資料，實作語法需要利用 orderByChild 和 forEach 二個函數搭配使用。 people物件資料1234567891011121314151617var people = &#123; "bob": &#123; "height": 178, "old": 18, "weight": 70 &#125;, "casper": &#123; "height": 180, "old": 13, "weight": 80 &#125;, "mike": &#123; "height": 162, "old": 15, "weight": 55 &#125;&#125;; 依「體重」排序12345678var peopleRef = firebase.database().ref('people');// 路徑&gt;&gt;排序('屬性')&gt;&gt;讀取&gt; forEach 依序撈出資料peopleRef.orderByChild('height').once('value', function (snapshot) &#123; // console.log(snapshot.val()); snapshot.forEach(function (item) &#123; console.log(item.val()); &#125;)&#125;) 延伸問題 firebase 只提供一種排序方式，並無 反向 排序的設定，所以若要達成反向排序，需借用 Array.reverse() 的幫忙。 反向範例123456789101112 var peopleRef = firebase.database().ref('people'); // 路徑&gt;&gt;排序('屬性')&gt;&gt;讀取&gt; forEach 依序撈出資料 peopleRef.orderByChild('height').once('value', function (snapshot) &#123; // console.log(snapshot.val());+ var dataArr = []; snapshot.forEach(function (item) &#123; console.log(item.val());+ dataArr.push(item.val()); &#125;) //反向排序+ console.log(dataArr.reverse()); &#125;) firebase排序規則Array.reverse() startAt、endAt、equalTo 過濾條件 過濾條件： startAt() 多少以上 endAt() 多少以下 equalTo() 相等 使用 過濾條件 時，一定要先 排序(orderByChild) 過資料 一個 過濾條件123456789var peopleRef = firebase.database().ref('people');// 將 重量 排序後，篩選出 4500 以上的資料peopleRef.orderByChild('weight').startAt(4500).once('value', function (snapshot) &#123; snapshot.forEach(function (item) &#123; console.log(item.key); console.log(item.val()); &#125;) // console.log(snapshot.val());&#125;) 多個 過濾條件123456789var peopleRef = firebase.database().ref('people');// 將 重量 排序後，篩選出 2500 ~ 3500 之間的資料peopleRef.orderByChild('weight').startAt(2500).endAt(3500).once('value', function (snapshot) &#123; snapshot.forEach(function (item) &#123; console.log(item.key); console.log(item.val()); &#125;) // console.log(snapshot.val());&#125;) limitToFirst、limitToLast 限制筆數 限制筆數： limitToFirst(n) 從 頭 取得 n 筆資料 limitToLast(n) 從 尾 取得 n 筆資料 取得第 1 筆資料12345678var peopleRef = firebase.database().ref('people');peopleRef.orderByChild('weight').limitToFirst(1).once('value', function (snapshot) &#123; snapshot.forEach(function (item) &#123; console.log(item.key); console.log(item.val()); &#125;) // console.log(snapshot.val());&#125;) 取得倒數 5 筆資料12345678var peopleRef = firebase.database().ref('people');peopleRef.orderByChild('weight').limitToLast(5).once('value', function (snapshot) &#123; snapshot.forEach(function (item) &#123; console.log(item.key); console.log(item.val()); &#125;) // console.log(snapshot.val());&#125;) 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>Firebase</category>
      </categories>
      <tags>
        <tag>Firebase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SASS-基礎用法]]></title>
    <url>%2F2017%2F12%2F25%2FSASS-studynotes%2F</url>
    <content type="text"><![CDATA[變數命名(前面加個 $ 字號)123456789101112131415//變數$font-color: bule;$font-m: 16px;$font-l: $font-m * 1.2;$font-s: $font-m * 0.8;.box01 &#123; color: $font-color; font-size: $font-l;&#125;.box02 &#123; color: $font-color; font-size: $font-s;&#125; @import常見的分類123@import mixin //放置所有Sass全域變數與Mixin@import reset //reset.css@import layout //共同框架(如：表頭、表尾) @mixin + @include建立：@mixin + 名稱 { 語法內容} ; 插入：@include + 名稱 ; 建立1234567//圓角效果@mixin circle($size,$bgcolor)&#123; border-radius: 50%; width: $size; height: $size; background-color: $bgcolor;&#125;// @mixin可搭配變數應用 插入123.circlebox&#123; @include circle(100px,red)&#125; @mixin + @content各種載具斷點123456789101112131415161718192021222324252627282930//iPad - 768px@mixin pad &#123; @media(max-width: 768px)&#123; @content; &#125;&#125;//iPad以下 - 767px@mixin mobile &#123; @media(max-width: 767px)&#123; @content; &#125;&#125;//iPhone 6 Plus - 414px (視專案族群)@mixin i6plue &#123; @media(max-width: 414px)&#123; @content; &#125;&#125;//iPhone 6 - 375px (視專案族群)@mixin i6 &#123; @media(max-width: 768px)&#123; @content; &#125;&#125;//iPhone 5、SE - 320px@mixin i5 &#123; @media(max-width: 320px)&#123; @content; &#125;&#125; 使用方式123456789.header&#123; width: 100px; height: 100px; //iPad - 768px @include pad()&#123; height: auto; &#125;&#125; Sass顏色函數常用函數12345678910111213$bg-color: #ff0000;.darken:hover &#123; background: darken($bg-color, 20%); //將紅色調暗10%&#125;.lighten:hover &#123; background: lighten($bg-color, 20%); //將紅色調亮10%&#125;.invert:hover &#123; background: invert($bg-color); //返回一個反相色&#125; 範例 See the Pen Sass-顏色函數 by Kanboo (@Kanboo) on CodePen. 參考文章30天掌握Sass語法SassMe顏色函數]]></content>
      <categories>
        <category>SASS</category>
      </categories>
      <tags>
        <tag>SASS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS-基礎觀念]]></title>
    <url>%2F2017%2F12%2F24%2FNodeJS-studynotes%2F</url>
    <content type="text"><![CDATA[node全域物件：global node的全域物件為 global ，就像網頁的全域物件為 window。 如下圖，在node環境下，不同js檔之間是區隔的，使用到相同的變數名稱是不會互相影響。 require、module exports由於node環境下，不同js檔之間是區隔的，所以若想要在js檔之間達到資料的傳遞的話，方法如下 app.js 引用語法12345//引用 模組var content = require('./data'); //設定預引用的js檔路徑，不用加副檔名console.log(content.data);console.log(content.bark()); 輸出語法有二種，可任意選擇喜歡的寫法，但不能二種寫法同時在同一個js檔裡，因為會互相覆蓋掉。 data.js 輸出語法1234567891011121314151617//第一種：輸出資料var data = 2;//輸出的資料module.exports = &#123; content: data, title: 'big'&#125;;//第二種：輸出資料exports.data = 2;exports.bark = function()&#123; return 'bark!!';&#125; Node核心模組-createServercreateServer的參數： request：接收User的行為，如：request.url 可取得目前網頁網址response：回應User的結果 123456789101112131415var http = require('http');http.createServer(function (request, response) &#123; // 輸出 純文字 // response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); //文字格式 // response.write('hello word!!'); //輸出 HTML response.writeHead(200, &#123;"Content-Type": "text/html"&#125;); //HTML格式 response.write('&lt;h1&gt;hello word!!&lt;/h1&gt;'); response.end();&#125;).listen(8080); //監聽 8080 port 常見的port：21 FTP80 http3389 遠端桌面 Node模組-Path__dirname：取得目前js檔的目錄路徑，如：/Users/kanboo/Desktop/project __filename：取得目前js檔的檔案路徑，如：/Users/kanboo/Desktop/project/app.js 123456789101112131415161718192021var path = require('path');//抓目錄路徑console.log(path.dirname('/xx/yy/zz.js'));//=&gt; /xx/yy//路徑合併console.log(path.join(__dirname,'/xx'));//=&gt; /Users/kanboo/Desktop/project/xx//抓檔名console.log(path.basename('xx/yy/zz.js'));//=&gt; zz.js//抓副檔名console.log(path.extname('xx/yy/zz.js'));//=&gt; .js//分析路徑console.log(path.parse('xx/yy/zz.js'));//=&gt; &#123; root: '', dir: 'xx/yy', base: 'zz.js', ext: '.js', name: 'zz' &#125; Node.js PATH API文件 NPM-nodemonnodemon是一個專為Node.js設計的模組，它的作用是持續監視著你的程式碼，一旦你修改後保存了，nodemon就會重新啟動你的Node.js程式，這樣你只要刷新你的瀏覽器就能看到改動。 安裝語法1npm install -g nodemon 啟動語法12345//原先啟動server的方法node index.js//改用此方法nodemon index.js nodemon 參考來源NodeJS 前後端開發實戰六角學院]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-IcoMoon]]></title>
    <url>%2F2017%2F12%2F23%2FCSS-icomoon%2F</url>
    <content type="text"><![CDATA[IcoMoon 下載icons 挑選好想要的icons 修改部份設定 產生sass的css檔 修改引用的html語法預設語法為&lt;span class=&quot;icon-book&quot;&gt;&lt;/span&gt;，修改為&lt;i class=&quot;icon-book&quot;&gt;&lt;/i&gt; 下載字體 引入專案 將下載好檔案解壓縮，複製 fonts資料夾 和 style.scss、variables.scss 複製到專案的source資料夾底下 修改sass的檔名和內容 修改variables.scss內容，並更改檔名為 _icomoon_variables.scss 123 //第一行- $icomoon-font-path: "fonts" !default;+ $icomoon-font-path: "../fonts" !default; //fonts資料夾不是在css資料夾底下，所以需回上一層 修改style.scss內容，並更改檔名為 _icomoon.scss 123 //第一行- @import "variables";+ @import "_icomoon_variables"; 主頁 all.css 引入 _icomoon.scss 123 @import "bootstrap"; @import "font-awesome";+ @import "icomoon"; 使用icons語法 123&lt;i class="icon-music"&gt;&lt;/i&gt;&lt;i class="icon-mic"&gt;&lt;/i&gt;&lt;i class="icon-coin-dollar"&gt;&lt;/i&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>icon</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-webfont 字體]]></title>
    <url>%2F2017%2F12%2F22%2FCSS-Webfont%2F</url>
    <content type="text"><![CDATA[使用方法12345//引入字體@import url(//fonts.googleapis.com/earlyaccess/notosansscsliced.css);//設定字體font-family: 'Noto Sans SC Sliced', sans-serif; 範例See the Pen Webfont - 思源體 by Kanboo (@Kanboo) on CodePen. 問題紀錄雖然已有在css設定 font-family: ‘Noto Sans SC Sliced’, sans-serif; ，不過還是沒套用到新的 font-family ，因為CSS權重的問題，還是使用預設的 微體正黑體， 可能是因為 codepen 有額外加 font-family 設定，導致 &lt;style&gt;的CSS權限 大於在 CSS檔裡面的屬性設定 所以若要強制轉換的話，就需要加 !important 1font-family: 'Noto Sans SC Sliced', sans-serif !important; 參考文章谷歌提出字体切片方案Noto Sans SC Sliced]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>webfont</tag>
        <tag>字體</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-Animation 動畫]]></title>
    <url>%2F2017%2F12%2F21%2FCSS-Animation%2F</url>
    <content type="text"><![CDATA[CSS的Animation分為兩個部分，一個是決定動畫該如何跑的 Keyframe，另一個是將動畫載入元素的 Animation。 Keyframes 語法123456789101112//第一種寫法@keyframes 自訂的name &#123; from &#123; ... &#125; to &#123; ... &#125;&#125;//第二種寫法@keyframes 自訂的name &#123; 0% &#123; ... &#125; 50% &#123; ... &#125; 100% &#123; ... &#125;&#125; Animation 屬性1234567//完整語法animation: 自訂的name duration timing-function delay iteration-count direction fill-mode play-state;//常用寫法animation: 自訂的name duration timing-function iteration-count;animation: time 3s linear infinite; Name：@keyframes 動畫名稱。 Duration：動畫時間。 Timing Function：動畫進行的速度曲線。 ease：是預設的。慢進 → 加速 → 減速到結束。 ease-in：慢進 → 加速到結束。 ease-out：快進 → 減速到結束。 ease-in-out：開始跟結束都是慢的狀態。 linear：以相同速度前進。 steps()：無連續的動作，直接跳至各步 ( step ) 的指定 css。 cubic-bezier()：指定動畫滑動的曲線。 Delay：延遲動畫開始的時間。 Iteration Count：動畫重複次數(預設一次)。 infinite(無限) | 次數 Direction：動畫播放方向。 normal ：每次播放都是從 0% 至 100% reverse ：每次播放都是從 100% 至 0% alternate ：播放兩次以上的話，會從 0% 至 100% ，再從 100% 回到 0% ，以此類推 alternate-reverse ：跟 alternate 相反，會先從 100% 開始播放 Fill Mode：控制動畫播放完後的最終狀態。 none ：回到未播放動畫效果前的狀態 forwards ：停在動畫的最後一個狀態上 backwards ：停在動畫的第一個狀態上 (實測不出來) both ：視 animation-direction 來決定停在哪一個狀態上。 Play State：指定動畫播放或暫停。 可以的選項有 running|pause，與影片的播放、暫停是同樣的意思；這在與 JS 搭配時，可妥善控制動畫。 範例翻轉效果 See the Pen CSS Animation-範例1 by Kanboo (@Kanboo) on CodePen. 滾動效果 See the Pen CSS Animation-範例2 by Kanboo (@Kanboo) on CodePen. 參考文章CSS3 動畫基礎CSS3 AnimationAnimation動畫效果]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>動畫</tag>
        <tag>animattion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-練習-自刻時鐘]]></title>
    <url>%2F2017%2F12%2F20%2FCSS-Exercise-Clock%2F</url>
    <content type="text"><![CDATA[練習-自刻時鐘 步驟 先建立骨架(HTML) 12345678&lt;div class="warp"&gt; &lt;div class="clock"&gt; &lt;div class="centerpoint"&gt;&lt;/div&gt; &lt;div class="hour"&gt;&lt;/div&gt; &lt;div class="minute"&gt;&lt;/div&gt; &lt;div class="second"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 將時鐘元件垂直置中 將「圓點、時針、分針、秒針」移至時鐘的中心點。 123456position: absolute;top: 0;bottom: 0;left: 0;right: 0;margin: auto; 修改transform-origin與position位置 下列說明以 時針 為例(分針、秒針比照辦理)： 垂直置中後的 時針 css 12345678910111213$handwidth: 7px;.hour &#123; width: $handwidth; height: 80px; background-color: blue; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;&#125; 先修改 transform-origin 的軸心 12345678910111213.hour &#123; width: $handwidth; height: 80px; background-color: blue;+ //將軸心變更到 中下方 的位置+ transform-origin: 50% 80%; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;&#125; 加上旋轉的動畫效果 123456789101112131415161718192021.hour &#123; width: $handwidth; height: 80px; background-color: blue; //將軸心變更到 中下方 的位置 transform-origin: 50% 80%; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;+ animation: time 25s infinite linear;&#125;+ //旋轉的動畫效果+ @keyframes time &#123;+ to &#123;+ transform: rotate(360deg);+ &#125;+ &#125; 修改 position 位置 此時可以開啟Chrome的開發者工具，先利用工具微調好 時針 的position位置，讓他旋轉效果有繞著時鐘的中心點旋轉後，再將程式碼複製貼回去。 1234567891011121314151617181920212223.hour &#123; width: $handwidth; height: 80px; background-color: blue; //將軸心變更到 中下方 的位置 transform-origin: 50% 80%; position: absolute;- top: 0;+ top: -49px; bottom: 0;- left: 0;+ left: -1px; right: 0; margin: auto; animation: time 25s infinite linear;&#125;//旋轉的動畫效果@keyframes time &#123; to &#123; transform: rotate(360deg); &#125;&#125; 範例See the Pen 練習-自刻時鐘 by Kanboo (@Kanboo) on CodePen.]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>練習</tag>
        <tag>時鐘</tag>
        <tag>clock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 - 語義元素]]></title>
    <url>%2F2017%2F12%2F18%2FHTML5-Semantics%2F</url>
    <content type="text"><![CDATA[重新認識HTML5的語義元素 常用元素&lt;header&gt;區塊標題，不要把它只用來取代 &lt;div class=”header”&gt;它也可以是文章的標題，一頁可以有好多個 &lt;header&gt;，&lt;header&gt; 裡面至少要有一個 h1~h6。 &lt;nav&gt;導覽列。裡面裝的東西應該只有 主要 的navigation links，不要把各種link都丟到&lt;nav&gt;裡面。舉例來說，footer裡面常常會有一排link，那個就不需要包進&lt;nav&gt;。 &lt;main&gt;一個頁面只有一個! 任何 global 都不能放在 main 裡面( e.g. &lt;header&gt; &lt;footer&gt; logo) &lt;section&gt;通常用來把一些相關的元素組合在一起，一般來說，裡面都會包含heading。如果這個區塊的內容可以分成幾個部分的話，那應該使用article。 1234&lt;section&gt; &lt;h2&gt;Section title&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec viverra nec nulla vitae mollis.&lt;/p&gt;&lt;/section&gt; &lt;article&gt;文章中可以脫離其他部分，獨立出來而又完整，甚至可以復用的一部分，通常有自己的標題，當article內嵌article時，裡外層的內容應該是相關的，比如一篇文章和它的留言，而section雖然也具有獨立表達內容的能力，但是對外層有一定的相依性，例如這篇文章中的一個章節。 123456789101112131415&lt;article&gt; &lt;header&gt; &lt;h3&gt; &lt;a href="/my-blog-post"&gt;My blog post&lt;/a&gt; &lt;/h3&gt; &lt;/header&gt; &lt;section&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec viverra nec nulla vitae mollis.&lt;/p&gt; &lt;/section&gt; &lt;footer&gt; &lt;small&gt; Posted on &lt;time datetime="2017-04-29T19:00"&gt;Apr 29&lt;/time&gt; in &lt;a href="/category/code"&gt;Code&lt;/a&gt; &lt;/small&gt; &lt;/footer&gt;&lt;/article&gt; &lt;aside&gt;通常用來包含一些和當前頁面內容有關的額外信息，比如廣告、個人資料信息或相關連結。 &lt;footer&gt;通常包含作者、版權信息或者相關鏈接等。 簡易分辦 &lt;section&gt;&lt;article&gt;&lt;article&gt;: 就算脫離了整體也是一個可以獨立存在、具有完整內容的區塊，例如這篇文章。&lt;section&gt;: 具有獨立表達內容的能力，但是對外層有一定的相依性，例如這篇文章中的一個章節。 下面是簡單的問題，讓我們決定要用 &lt;section&gt; / &lt;article&gt; / &lt;div&gt; 具有完整內容的區塊，而且可以出現在你的閱讀器內嗎? 是的話就是 &lt;article&gt; 跟主要內容是有相關並且列入 outline 裡不會奇怪的? 是的話就是 &lt;section&gt; 跟內容無關或只用來 styling 的? 是的話就是 &lt;div&gt; 建議的架構範例 參考文章结构性元素HTML5 Semantic ElementsHTML5 SemanticsSemantic in HTML5]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>語義架構</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-垂直置中的方法]]></title>
    <url>%2F2017%2F12%2F17%2FCSS-vertical-align%2F</url>
    <content type="text"><![CDATA[整理常用CSS常用的 垂直置中 的方法。 文字的垂直置中方法此方法適用 單行，因為是行高，所以會在行內元素的上下都加上行高的 1/2 ，如果多行，第二行與第一行的間距會變超大，就會導致沒有垂直置中的效果。 123456789// height 和 line-height 要一樣高.div0,.div1 &#123; width: 300px;+ height: 250px;+ line-height: 250px; text-align: center; border: 1px solid #000;&#125; See the Pen 垂直置中 - line-height by Kanboo (@Kanboo) on CodePen. calc &amp; transform使用 calc 動態計算的能力，讓要置中的 div 的 top 屬性，與上方的距離是「50% 的外框高度 + 50% 的 div 高度」，就可以做到垂直置中。 範例1：設定top：50%，再扣掉 div 的 高度/2 方法1：top: calc( 50% - (高度/2) ) 方法2：top: 50%; margin-top: -(高度/2); 方法3：top: 50%; transform: translateY(-50%); 自行計算50%的div高度 1234567891011121314151617181920212223242526272829.redbox &#123; background: #c00; float: left;+ position: relative; //要宣告position，才能使用 top、left width: 30px;- //計算方法1+ height: 30px;+ top: calc(50% - 15px); //高：30/2=15 &#125; .greenbox &#123; background: #0c0; float: left; position: relative; width: 30px;- //計算方法2+ height: 80px;+ top: 50%;+ margin-top: -40px; //高：80/2=40 &#125; .bluebox &#123; background: #00f; float: left; position: relative; width: 30px; height: 50px;- //計算方法3+ top:50%;+ transform: translateY(-50%); &#125; See the Pen 垂直置中 - calc 動態計算1 by Kanboo (@Kanboo) on CodePen. 範例2：將三個div設定寬高各30px，將滑鼠移到黑框內，可觀看效果。 See the Pen 垂直置中 - calc 動態計算2 by Kanboo (@Kanboo) on CodePen. 絕對定位利用絕對位置來指定，要將 上下 的數值都設為 0，再搭配一個 margin:auto，就可以辦到垂直置中。 邏輯：這個方法同時設定top和bottom為0，使得這個div完全不可能符合，最後再透過margin這個指令，讓它達到垂直置中的效果 123456789101112131415161718 .redbox &#123;- // 垂直置中 background: #c00; position: absolute; //要宣告，才能使用 top、left+ top: 0;+ bottom: 0;+ margin: auto; &#125; .bluebox &#123;- // 垂直置中 + 水平置中 background: blue; position: absolute; //要宣告，才能使用 top、left top: 0; bottom: 0;+ left: 0;+ right: 0; margin: auto; &#125; See the Pen 垂直置中 - 絕對定位 by Kanboo (@Kanboo) on CodePen. FlexboxCSS3 最威的盒子模型：Flexbox，使用 align-items 或 align-content 的屬性， 輕輕鬆鬆就可以做到垂直置中的效果喔，Bootstrap 4 也有用喔。 1234567891011121314.div0 &#123;+ display: flex;+ align-items: center;+ justify-content: center; width: 150px; height: 150px; border: 1px solid #000; .redbox &#123; width: 30px; height: 30px; background: #c00; &#125;&#125; See the Pen 垂直置中 - Flexbox by Kanboo (@Kanboo) on CodePen. 參考文章CSS 垂直置中的七個方法CSS垂直置中的方法]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>vertical-align</tag>
        <tag>垂直置中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-transform 2D]]></title>
    <url>%2F2017%2F12%2F16%2FCSS-transform-2D%2F</url>
    <content type="text"><![CDATA[利用 transform 將元素加入 位移、旋轉、縮放和傾斜 的效果。 基本語法transform 屬性可以設定 一個 或 多個 的參數，若設定多個參數的話，中間的區隔使用 空白 即可。 123transform: 第一個參數 第二個參數 ...transform: translate(100px) rotate(20deg); 常用的參數如下列 位移 - translate()、translateX()、translateY() 旋轉 - rotate() 縮放 - scale()、scaleX()、scaleY() 傾斜 - skew()、skewX()、skewY() 位移translate語法 若設定二個，用 逗號 區隔 translate(tx) → 若僅設定一個參數，代表只 位移X translate(tx, ty) 設定 X軸 位移 translateX() 設定 Y軸 位移 translateY() 範例 位移 X軸 50px,位移 Y軸 50px 12345.moved &#123; transform: translate( 50px, 50px); // 上下二段語法，結果一樣 transform: translateX( 50px) translateY( 50px);&#125; See the Pen transform-translate by Kanboo (@Kanboo) on CodePen. 旋轉rotate語法 rotate( 旋轉角度 ) =&gt; rotate( 20deg ) 旋轉30度角 = 30deg旋轉90度角 = 90deg 範例 旋轉45度角 123.rotate &#123; transform: rotate( 45deg);&#125; See the Pen transform-rotate by Kanboo (@Kanboo) on CodePen. 縮放scale語法 參數預設大小為 1 ，若設定 小於 1 就是 縮小，大於 1 就是 放大。 若設定二個，用 逗號 區隔 scale(sx) → 若僅設定一個參數，代表同時縮放 X 和 Y scale(sx, sy) 縮放 X軸 scaleX() 縮放 Y軸 scaleY() 範例 縮小至0.7倍 12345.scaled &#123; transform: scale(0.7); // 上下二段語法，結果一樣 transform: scaleX(0.7) scaleY(0.7);&#125; See the Pen transform-scale by Kanboo (@Kanboo) on CodePen. 傾斜skew語法 若設定二個，用 逗號 區隔 skew(ax) → 若僅設定一個參數，代表只 傾斜X skew(ax, ay) 傾斜 X軸 skewX() 傾斜 Y軸 skewY() 範例 skewed1 傾斜 X , skewed1 傾斜 X 和 Y 1234567891011 .skewed1 &#123; transform: skew(10deg); // 等同 skewX(10deg) transform: skewX(10deg);&#125;.skewed2 &#123; transform: skew(10deg, 10deg); // 等同 skewX(10deg) skewY(10deg) transform: skewX(10deg) skewY(10deg);&#125; See the Pen transform-skew by Kanboo (@Kanboo) on CodePen.]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>transform</tag>
        <tag>2D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-transform-origin 軸心]]></title>
    <url>%2F2017%2F12%2F15%2FCSS-transform-origin%2F</url>
    <content type="text"><![CDATA[在學習 transform 之前，先了解 transform-origin 軸心 怎麼變化？ 說明在撰寫CSS transform 時，預設的 軸心 是在Box的正中央位置(如下圖)， 所以要製作一些比較特別的效果的話，如：時間、開門 …等 就利用變更軸心的位置，再配合 transform 來達成。 1transform-origin: x y; 範例：利用 transform: rotate(90deg) 旋轉 90度，呈現因 軸心位置不同 ，而旋轉的結果有何不一樣。 C 軸心： 正中間(預設) F 軸心： 右下角 E 軸心： 左邊中間 See the Pen transform-origin 更改軸心 by Kanboo (@Kanboo) on CodePen. 其他範例teaching transform-originTransform Origin Examples 參考文章CSS沒有極限 - CSS transform-origin]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>transform</tag>
        <tag>transform-origin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Browsersync]]></title>
    <url>%2F2017%2F12%2F15%2FHexo-Browsersync%2F</url>
    <content type="text"><![CDATA[實現撰寫文章時，可自動刷新頁面預覽，不用再手動F5了。 前言實現刷新功能，需要完成的事情有： 安裝套件 Hexo-Browsersync 解決文章太長-渲染失敗Bug 執行 hexo server，即可。 操作步骤1.安裝套件1$ npm install hexo-browsersync --save 2.修正Bug 安裝 hexo-renderer-jade 插件 1$ npm install hexo-renderer-jade --save 在你的 node_modules 文件夾裡找到 hexo-renderer-pug 的文件夾，然後將裡面 lib/renderer.js 的其中一行代碼 註解 掉： 1//pugRenderer.compile = pugCompile; 新增 _config.yml 的設定。 參考：issue 新增路徑：~/blog/_config.yml12server: compress: true #開啟壓縮 3.執行1$ hexo s 啟動 hexo server 後，你會看到下列的訊息 12345678INFO Start processing[Browsersync] Access URLs: -------------------------------------- UI: http://localhost:3001 -------------------------------------- UI External: http://192.168.1.135:3001 --------------------------------------INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. port:3001 可修改 browsersync 相關設定。port:4000 Blog的預覽畫面。 參考文章Hexo 实现实时预览编辑Hexo不重新生成也可预览修正渲染不全問題]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Browsersync</tag>
        <tag>頁面自動刷新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-複製功能]]></title>
    <url>%2F2017%2F12%2F15%2FHexo-clipboard%2F</url>
    <content type="text"><![CDATA[實現程式碼區塊，可進行 Ctrl + C 前言實現複製功能，需要完成的事情有： 下载插件clipboard.js 插入JavaScript 插入主题中 操作步骤1.下載插件clipboard.js將下載好的 clipboard.js 放置下列路徑， 目錄zclip 為此次 新增 。 ~blog/themes/next/source/lib/zclip/clipboard.min.js clipboard.js下載位址：GitHub 2.新增JavaScript新增 文件 custom.js ，目錄如下： 新增JS文件位置：~/blog/themes/next/source/js/src/custom.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//此函数用于创建复制按钮function createCopyBtns() &#123; var $codeArea = $("figure table"); //查看页面是否具有代码区域，没有代码块则不创建 复制按钮 if ($codeArea.length &gt; 0) &#123; //复制成功后将要干的事情 function changeToSuccess(item) &#123; $imgOK = $("#copyBtn").find("#imgSuccess"); if ($imgOK.css("display") == "none") &#123; $imgOK.css(&#123; opacity: 0, display: "block" &#125;); $imgOK.animate(&#123; opacity: 1 &#125;, 1000); setTimeout(function() &#123; $imgOK.animate(&#123; opacity: 0 &#125;, 2000); &#125;, 2000); setTimeout(function() &#123; $imgOK.css("display", "none"); &#125;, 4000); &#125;; &#125;; //创建 全局复制按钮，仅有一组。包含：复制按钮，复制成功响应按钮 //值得注意的是：1.按钮默认隐藏，2.位置使用绝对位置 position: absolute; (position: fixed 也可以，需要修改代码) $(".post-body").before('&lt;div id="copyBtn" style="opacity: 0; position: absolute;top:0px;display: none;line-height: 1; font-size:1.5em"&gt;&lt;span id="imgCopy" &gt;&lt;i class="fa fa-paste fa-fw"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span id="imgSuccess" style="display: none;"&gt;&lt;i class="fa fa-check-circle fa-fw" aria-hidden="true"&gt;&lt;/i&gt;&lt;/span&gt;'); //创建 复制 插件，绑定单机时间到 指定元素，支持JQuery var clipboard = new Clipboard('#copyBtn', &#123; target: function() &#123; //返回需要复制的元素内容 return document.querySelector("[copyFlag]"); &#125;, isSupported: function() &#123; //支持复制内容 return document.querySelector("[copyFlag]"); &#125; &#125;); //复制成功事件绑定 clipboard.on('success', function(e) &#123; //清除内容被选择状态 e.clearSelection(); changeToSuccess(e); &#125;); //复制失败绑定事件 clipboard.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger); &#125;); //鼠标 在复制按钮上滑动和离开后渐变显示/隐藏效果 $("#copyBtn").hover( function() &#123; $(this).stop(); $(this).css("opacity", 1); &#125;, function() &#123; $(this).animate(&#123; opacity: 0 &#125;, 2000); &#125; ); &#125;&#125;//感应鼠标是否在代码区$("figure").hover( function() &#123; //-------鼠标活动在代码块内 //移除之前含有复制标志代码块的 copyFlag $("[copyFlag]").removeAttr("copyFlag"); //在新的（当前鼠标所在代码区）代码块插入标志：copyFlag $(this).find(".code").attr("copyFlag", 1); //获取复制按钮 $copyBtn = $("#copyBtn"); if ($copyBtn.lenght != 0) &#123; //获取到按钮的前提下进行一下操作 //停止按钮动画效果 //设置为 显示状态 //修改 复制按钮 位置到 当前代码块开始部位 //设置代码块 左侧位置 $copyBtn.stop(); $copyBtn.css("opacity", 0.8); $copyBtn.css("display", "block"); $copyBtn.css("top", parseInt($copyBtn.css("top")) + $(this).offset().top - $copyBtn.offset().top + 2); // $copyBtn.css("right", -$copyBtn.width() - 3); $copyBtn.css("right", 0); &#125; &#125;, function() &#123; //-------鼠标离开代码块 //设置复制按钮可见度 2秒内到 0 $("#copyBtn").animate(&#123; opacity: 0 &#125;, 2000); &#125;);//页面载入完成后，创建复制按钮$(document).ready(function() &#123; createCopyBtns();&#125;); 3.更新主题新增 文件custom.swig，目錄如下： 新增位置：~/blog/themes/next/layout/_custom/custom .swig12&lt; script type = "text/javascript" src = "/lib/zclip/clipboard.min.js" &gt;&lt;/ script &gt; &lt; script type = "text/javascript" src = "/js/src/custom.js" &gt;&lt;/ script &gt; 修改 文件_layout.swig，目錄如下： 修改位置：~/blog/themes/next/layout/ _layout .swig12345678910111213141516&lt;!doctype html&gt;...&lt; html class = "&#123;&#123; html_class | lower &#125;&#125;" lang = "&#123;&#123; config.language &#125;&#125;" &gt;&lt; head &gt; ...&lt;/ head &gt;&lt; body itemscope itemtype = "http://schema.org/WebPage" lang = "&#123;&#123; page.lang || page.language || config.language &#125;&#125;" &gt; ... ... &#123;% include '_third-party/mathjax.swig' %&#125; &#123;% include '_third-party/scroll-cookie.swig' %&#125; &#123;% include '_third-party/exturl.swig' %&#125;+ &#123;% include '_custom/custom.swig' %&#125;&lt;/ body &gt;&lt;/ html &gt; 在文件中前一行插入文件引用，如第15行效果。1&#123;% include &apos;_custom/custom.swig&apos; %&#125; 參考文章HEXO優化之（二）—-添加複制功能]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>clipboard</tag>
        <tag>複製</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-留言版]]></title>
    <url>%2F2017%2F12%2F13%2FHexo-Comment%2F</url>
    <content type="text"><![CDATA[前言 新增 Hexo 的留言版，需要完成的事情有： 註冊 Disqus 的帳號 新建 Disqus 的 website 配置 Hexo 操作步骤1.註冊 Disqus 的帳號Disqus網址：https://disqus.com/ 打開鏈接後， 可以直接用Facebook，Twitter以及Google 登錄，也可以用郵箱註冊後登錄。 2.建立 Disqus website 點擊 GET STARTED 開始建立 website 點擊下面 I want to install Disqus on my site 填寫 Website Name，這是 短名稱，用於和 Hexo連結的 Key值。 直接點擊 Configure Disqus 填寫 Website URL ，這是你 Blog的網址 建立完成畫面 3.配置 Hexo主題配置主題 下面的 config.yml 文件，路徑： ~blog/themes/next/_config.yml 將 Disqus下的 enable 設定為 true 。 同時填寫您的 shortname(短名稱)。 count 用於指定是否顯示評論數量。 12345# Disqusdisqus: enable: true shortname: kanbooBlog count: true 上述步驟設置完成後，更新Blog 123$ hexo clean$ hexo g$ hexo d 參考資料Hexo 集成Disqus 評論Hexo搭建博客系列：（六）Hexo添加Disqus評論Next-评论系统]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Comment</tag>
        <tag>Disqus</tag>
        <tag>留言版</tag>
        <tag>評論</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-文章置頂]]></title>
    <url>%2F2017%2F12%2F13%2FHexo-Topfeatures%2F</url>
    <content type="text"><![CDATA[前言解決Hexo置頂問題，需要完成的事情有： 將目前 node_modules/hexo-generator-index/lib/generator.js 程式碼替換 在需要置頂的文章的前事中添加頂值，值越大越置頂。 操作步骤 替換 generator.js 程式碼 12345678910111213141516171819202122232425'use strict';var pagination = require('hexo-pagination');module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if (a.top &amp;&amp; b.top) &#123; // 兩篇文章top都有定義 if (a.top == b.top) return b.date - a.date; // 若top值一样則按照文章日期降序排 else return b.top - a.top; // 否則按照top值降序排 &#125; else if (a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定義，那麼将有top的排在前面 return -1; &#125; else if (!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都沒定義按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 若找不到 node_modules/hexo-generator-index/lib/generator.js 的話，請先安裝 hexo-generator-index。 指令： npm i --save hexo-generator-index 在需要置顶的文章的中添加 top 值，值越大越置顶。 123title: Hexo-文章置頂date: 2017-12-13 09:29:37top: 100 參考資料hexo置顶功能Hexo文章置顶]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Top</tag>
        <tag>置頂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-transition 轉場效果]]></title>
    <url>%2F2017%2F12%2F12%2FCSS-Transition%2F</url>
    <content type="text"><![CDATA[轉場是從 A 狀態，轉變成 B 狀態，中間的過程，就叫轉場，在 CSS 中叫做 transition。 語法1234567891011transition: property duration timing-function delay;transition: 套用的屬性 花費時間 時間速率 等待時間;transition: all 2s ease-out 1s;// 等同於：transition-property: all; // default: alltransition-duration: 2s; // default: 0；2s 表示 2 秒；2ms 表示 2 毫秒。transition-timing-function: ease-out;transition-delay: 1s; // 開始進行轉場效果之前，所要等待的時間。 transition-timing-function 時間速率 See the Pen transition 各種速率 by Kanboo (@Kanboo) on CodePen. 範例範例 1：hoverSee the Pen Transition - hover by Kanboo (@Kanboo) on CodePen. 範例 2：設定Two CSS propertiesSee the Pen Transition - 設定Two CSS properties by Kanboo (@Kanboo) on CodePen. 特別的點：12//設定二個 CSS屬性，設定不同 時間、速率..等transition: background .2s linear, border-radius 1s ease-in 1s; 上面案例，特別於在 :hover 時，有改變 背景色 和 圓角 效果，不過在 transition 的設定，分別針對 二個屬性設定不同的時間、速率…等 參考資料[CSS][Transition] 轉場效果 CSS3轉場效果(transitions) CSS transition 各種速率]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>transition</tag>
        <tag>動畫</tag>
        <tag>轉場效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-切版練習]]></title>
    <url>%2F2017%2F12%2F11%2FCSS-RWDlayout%2F</url>
    <content type="text"><![CDATA[紀錄練習切版時，遇到卡卡的問題 icon 利用 position 位移示意圖 重點 row 的 position 設置 relative; icon 的 position 設置 absolute; 移動 icon 的位置， top 、 left 將 icon 移進去在 input 時，input 需增加 左邊padding，保留位置給 icon。 HTML 程式碼123456&lt;div class="row"&gt; &lt;label for="email"&gt;Email Address*&lt;/label&gt; &lt;label for="email" class="icon"&gt;&lt;i class="fa fa-envelope-o" aria-hidden="true"&gt;&lt;/i&gt;&lt;/label&gt; &lt;input type="email" name="email" id="email"&gt;&lt;/div&gt; SCSS 程式碼12345678910111213141516171819//記得input的左邊要留padding,保留一些位置給iconinput &#123; padding: 6px 0 6px 28px;&#125;//位移 icon 至 input 裡.row &#123; position: relative; .icon &#123; position: absolute; top: 26px; left: 9px; font-size: 16px; z-index: 10; color: rgba(61, 17, 1, 0.5); &#125;&#125; codepen範例: LoginForm 緞帶效果 重點 .tag-wrap 為 藍色框線 .tag 為 紅色框線(熱賣) .tag-wrap 的 position 設置 absolute ，並且位移要超出原有的框架，才能做出緞帶效果; 新增 .tag 的 width、background-color…等屬性 利用 transform ，位移翻轉 .tag 移動好 .tag 後，在 .tag-wrap 新增 overflow: hidden;， 將多餘的部份隱藏 利用 .tag 的偽元素 :before、:after，新增 小三角 ▲ html 程式碼123456789101112&lt;div class="card"&gt; &lt;!-- 不影響結構 --&gt; &lt;div class="tag-wrap"&gt; &lt;div class="tag"&gt; 熱賣!! &lt;/div&gt; &lt;/div&gt; &lt;!-- 主要結構 --&gt; &lt;div class="card-block"&gt; &lt;/div&gt;&lt;/div&gt; SCSS 程式碼1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.card &#123; width: 230px; height: 200px; position: relative;&#125;//緞帶效果.tag-wrap &#123; $p: 5px; $size: 80px; position: absolute; //位移要超出原有的框架，才能做出緞帶效果 top: -$p; right: -$p; //超出的部份隱藏 overflow: hidden; width: $size * 2; height: $size * 2; //查看位置 border: 1px solid blue; .tag &#123; position: relative; width: $size*2; background-color: orange; padding-top: 0.25rem; padding-bottom: 0.25rem; text-align: center; margin-top: -$p * 2; color: white; //rotate為旋轉、translate為移動、skew為傾斜、scale為縮放 transform: translateX(50%) rotate(45deg) translateY(150%); //查看位置 border: 1px solid red; &amp;:before &#123; content: ""; position: absolute; //利用 加粗邊框 + 邊框上方顏色，達到小三角的效果 border: $p solid transparent; border-top-color: darken(orange, 15%); bottom: -10px; left: 6px; &#125; &amp;:after &#123; content: ""; position: absolute; //利用 加粗邊框 + 邊框上方顏色，達到小三角的效果 border: $p solid transparent; border-top-color: darken(orange, 15%); bottom: -10px; right: 14px; &#125; &#125;&#125; codepen範例: CSS-緞帶效果(乾淨版本)codepen範例: CSS-緞帶效果 觀念補充六角範例從 Sketch 設計到 CSS 切版 本日範例：https://codepen.io/Wcc723/pen/zEYXdN 本日設計參考：https://codepen.io/Wcc723/pen/pWzxXO transform CSS 程式碼123456789101112/* rotate為旋轉skew為傾斜scale為縮放translate為移動 *//* 範例1：移動X軸 → 旋轉 → 移動Y軸 */transform: translateX(150%) rotate(45deg) translateY(50%);/* 範例2：旋轉 → 移動X軸 → 移動Y軸 */transform: rotate(45deg) translateX(150%) translateY(50%); 上列 CSS程式碼 「範例1 、 範例2」，雖然同樣都做了「移動X軸、移動Y軸、旋轉」的動作，但是因為 執行順序 不同，所以二個範例呈現出來的結果也會不一樣。 上述程式碼範例： transform_執行順序 transform基本介紹1.CSS transform 概觀2.CSS transform 軸線的謊言3.CSS transform-origin4.CSS transform-3D的透視 SCSS顏色函數範例123456789.box&#123; background: rgba(#000,.5); //變半透明 background: invert(#f00); //變反向色彩 background: lighten(#06C, 30%); //變亮 background: darken(#06C,15%); //變暗 background: saturate(#06C,50%); //提高飽和度 background: desaturate(#06C,50%); //降低飽和度 background: grayscale(#06C); //灰階&#125; SCSS相關 linear-gradient讓顏色有漸層效果 CSS 程式碼1background-image: linear-gradient(165deg, white, white 50%, $bg-color 50%); background: linear-gradient( 方向, 第一個顏色, 第二個顏色, … ); 背景色 — 线性渐变背景色 — 漸層效果 繪製幾何圖形(支援度不高) 1clip-path: polygon(0 0, 280px 0, 370px 100%, 0% 100%); CSS clip-path 生成器利用CSS繪製更多形狀不可思议的CSS之CLIP-PATH]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>transform</tag>
        <tag>translateX</tag>
        <tag>rotate</tag>
        <tag>translateY</tag>
        <tag>SCSS</tag>
        <tag>linear-gradient</tag>
        <tag>clip-path</tag>
        <tag>position</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS - 常用筆記]]></title>
    <url>%2F2017%2F11%2F13%2FCSS-ForgetfulNotes%2F</url>
    <content type="text"><![CDATA[背景圖123456789101112131415/* 圖片滿版 */.img-cover &#123; background-image: url(./bg.png); background-position: center; background-size: cover; background-repeat: no-repeat;&#125;/* 圖片居中 */.img-contain &#123; background-image: url(./bg.png); background-position: center; background-size: contain; background-repeat: no-repeat;&#125; 其他背景圖範例：固定、滿版、置中background-attachment是背景固定模式的屬性註：作为背景的圖片是撑不起元素的，須額外需要给div新增「寬、高」 圓角123456div.circle&#123; width:80px; height:80px; border-radius:50%; background-color:blue;&#125; 2個重點： 圓的直徑，長寬 一定要等長 border-radius:50% 參考網址： 圓角詳解、CSS3技巧之形狀 區塊陰影、文字立體感12345678/* 外層的陰影 */box-shadow: 1px 1px 5px rgba(0,0,0,0.3);/* 內層的陰影(多加 inset) */box-shadow: inset 1px 1px 5px rgba(0,0,0,0.3);/* 文字的陰影 */text-shadow: 1px 1px 1px rgba(0,0,0,0.5); 參考網址： 玩转box-shadow、文字立體感 a 連結取消 a 連結下底線123a &#123; text-decoration: none;&#125; :hover 移至 a 連結的效果123a:hover &#123; border-bottom: 3px solid #00cc99;&#125; 註：a 連結 預設display為inline，但為了讓 User有更好的操作體驗，會變更成 block，增加「寬、高」範圍，讓 User較易點擊到目標連結。 斷點123456@media (max-width: 768px) &#123; //iPad&#125;@media (max-width: 767px) &#123; //iPhone&#125; 新單位：高度vh、寬度vwvh 代表的是view height，也就是螢幕可視範圍高度的百分比；vw 表示的是view width，也就是螢幕可是範圍寬度的百分比。 ul ol list-style取消樣式ol,ul {list-style: none;} 設定樣式list-style: circle; 其他樣式參考：CSS list-style 指定滑鼠游標的型態cursor: pointer; /*手型，表示超連結*/ 參考網址： 游標的型態]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>筆記</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Search]]></title>
    <url>%2F2017%2F10%2F18%2FHexo-Search%2F</url>
    <content type="text"><![CDATA[前言在新增 Hexo 的 Local Search 時，參考下列的連結文章，跟著步驟安裝及設定即可，不過剛裝好後，發現搜尋功能無法正常使用，後來有查到原因，在此紀錄一下Debug過程。 Local SearchHexo博客添加站內搜索 安裝順序安裝hexo-generator-searchdb在站點的根目錄下執行以下命令 1$ npm install hexo-generator-searchdb --save 編輯站點配置文件(Hexo)新增以下內容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 編輯主題配置文件(Next)啟用本地搜索功能： 123# Local searchlocal_search: enable: true 問題紀錄 點了搜尋後，畫面一直轉圈圈沒停止，查看Console也沒出現Error 查看XHR，目前我有10篇文章，卻只產生三筆entry，且其中一筆entry的content內容沒產生 並且有此錯誤訊息 後來針對有問題那篇文章複製內容，貼到 notepad++ 看看，發現有一亂碼，將亂碼刪除後，Local Search就可以正常運作了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC-讓終端機變好看]]></title>
    <url>%2F2017%2F10%2F15%2FMAC-iTerm2-Zsh%2F</url>
    <content type="text"><![CDATA[前言在安裝 MAC終端機高亮的過程，主要是參考下列的文章，跟著步驟安裝及設定即可，不過安裝過程中，還是有遇到卡卡的地方，所以特別記一下 卡卡的歷程。 為 MAC 的 Terminal 上色 - 透過 iTerm 2 和 Oh My Zsh 高亮你的終端機 讓 MAC 終端機變好看 iterm2-solarized 原文 問題紀錄zsh指令失效安裝完zsh，在使用相關shell命令，出現了zsh: command not found Nodezsh: command not found: hexo等一系列error zsh 和bash 的環境變量bash的環境變量是.bash_profile文件。zsh的環境變量是.zshrc文件。 字面意思是相關命令沒有沒有找到，其實就是bash shell 以及 zsh shell是 兩種讀取系統環境變量，簡單來說就是說 node、Hexo…等套件 是在使用 bash 時候，安裝好的，所以會設定在 .bash_profile裡，後來改使用 zsh shell 的時候，你並沒有把相關的環境變量的配置設置到 .zshrc 中（功能上類似bash 的.bash_profile），所以 .zshrc 沒有配置相關環境變量設置，就把bash 中.bash_profile 全部環境變量加入 .zshrc 就好。 加入方法：123456#打開 zsh 的設定檔open ~/.zshrc# 最后一行加入下面指令# 解決OSX使用oh-my-zsh後.bash_profile自定義失效source ~/.bash_profile zsh: command not foundzsh: command not found解决OSX使用oh-my-zsh后.bash_profile自定义失效 安裝字型原先是跟著最上面文章教學，安裝 字型(Meslo LG M Regular for Powerline)，再修改相關設定後，此字型在 iTerm 上，顯示箭頭是正常的，不過在VScode上面，顯示 箭頭 卻還是有亂碼，所以去Google一下，結果如下 先安裝 字型 1234# 安裝字型$ git clone git://github.com/powerline/fonts ~/.powerline_fonts$ cd ~/.powerline_fonts$ ./install.sh iTerm設定 字型iTerm –&gt; Preferences –&gt; Profiles –&gt; Text –&gt; Change Font推薦使用 Source Code Pro (Adobe的）與 Ubuntu Mono，這兩個字型都相當適合寫程式使用。 VSCode設定 字型在設定參數裡，新增下列二行 12"terminal.integrated.fontFamily": "Source Code Pro for Powerline","terminal.integrated.fontSize": 14 安裝Powerline專屬字型美化你的終端機]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>iTerm2</tag>
        <tag>ZSH</tag>
        <tag>終端機</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-備份]]></title>
    <url>%2F2017%2F10%2F14%2FHexo-backup%2F</url>
    <content type="text"><![CDATA[前言簡單來說，實現備份方法就是利用 二個分支線 個別放我們要的檔案，一個分支線 放 發佈的文章，另一個分支線 放 備份的檔案， master: 利用 hexo deploy 直接推送，存放由 hexo 產生的靜態頁面 hexo: 利用 git command 推送，存放部落格原始碼 由於 Github Page 本身限制頁面主要分支必須為 master，因此考慮增設分支 hexo 用以存放部落格原始碼。 重點提醒當環境都設定好以後，日後不管是在哪一台電腦上撰寫文件、發佈文件、備份檔案，都是在 hexo 分支上hexo 分支上hexo 分支上 因為很重要，所以說三次。 初次備份環境建立此動作僅需在第一台撰寫Blog電腦上執行即可，如果日後換新電腦或要在不同台電腦撰寫Blog的話，請參考下面的 更換環境 的操作。 實作步驟 新建 hexo 分支 1$ git branch hexo 將檔案備份至 hexo 分支 1$ git push origin hexo github上設定 hexo 為 默認分支 日後不同電腦clone下來時，不用再特別切換 hexo 分支 確認 配置hexo deploy 的参数 確認 branch參數一定是設定 master 分支,因為日後操作都在 hexo 分支上， 至於要發佈文件的話，就靠指令 hexo d 幫我們建立發佈的文章。 1234deploy:type: gitrepository: https://github.com/用戶名/用戶名.github.io.gitbranch: master 更換環境執行步驟如果是第一次在新電腦的話，請先參考下列動作，先建立Blog的環境。 12345678910111213#1.克隆到本地$ git clone https://github.com/用户名/用户名.github.io.git Kanbooblog#2.切換到blog目錄;$ cd blog目錄#3.確認目前分支是否為hexo，若不是，則切換備份的分支分稱(hexo)$ git checkout Hexo#4.安装各种npm包$ npm install -g hexo-cli$ npm install$ npm install hexo-deployer-git --save 可能遇到的問題1.warning: LF will be replaced by CRLF在 Windows 中廣泛使用來標識一行的結束。而在Linux / UNIX系統中只有換行符。也就是說在Windows中的換行符為CRLF，而在linux的下的換行符為：LF，當執行 git指令 時，系統提示：LF將被轉換成CRLF。 解決方法： 1$ git config --global core.autocrlf false git提示警告：LF將被CRLF替換Hexo Git部署警告”warning： LF will be replaced by CRLF”的去除方法 部落格更新與部署新文章日後在不同電腦上要新增文件的話，就重覆下列的動作即可。 拉取遠端版本庫上的更新內容 1$ git pull 修改部落格配置或撰寫新文章 添加變更並推送 12345678910$ hexo clean# 產生發佈的文件$ hexo g # 發佈至github-master$ hexo d # 備份至github-Hexo$ git add .$ git commit -m "message"$ git push origin hexo 參考網站Hexo利用Github分支在不同电脑上写博客 實現不同電腦上 Hexo 部落格的同步 hexo备份小技巧]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>備份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-環境建置]]></title>
    <url>%2F2017%2F10%2F14%2FHexo-Create%2F</url>
    <content type="text"><![CDATA[前言建立Hexo環境，需要完成的事情有： 建置github空間 安裝 Node.js（如果還沒有的話） 安裝 Hexo 初始化 Hexo，並在目標資料夾建立所需檔案 安裝 hexo-deployer-git (很重要) 在_config.yml 中設定 Git 等資訊 空間：GitHub因為Blog需要上傳至雲端，所以這裡使用github的免費空間。 創建github page倉庫的名字 要和 你的帳號 一樣，如：用戶名.github.io 進入github page項目設置頁面選擇Settings 創建一個默認的頁面直接選擇Launch automatic -&gt; Continue to layouts page generator -&gt; Publish page,其他東西都不用修改。 查看效果至此，你的github page已經創建完成，你可以訪問自己的站點了。如：https://用戶名.github.io/ Hexo安裝安裝 Hexo 相當簡單；然而，在安裝前您必須先檢查下列您的電腦是否已經安裝下列軟體： Node.js Git 若您的電腦已經安裝上述的必備軟體，那麼恭喜您！只需要透過 npm 即可完成 Hexo 的安裝。 1$ npm install -g hexo-cli 建立123$ hexo init yourname # ( 初始化新的 Hexo )$ cd yourname # ( 進入您剛剛建立的 Hexo 資料夾當中 )$ npm install #（ 安裝 Hexo ) yourname 就是指在電腦裡的檔案名稱，可以隨意取，例如「myhexoblog」 設定進入您 Hexo 主目錄下之後，先找到 _config.yml 這個檔案！ 123456title: Kanboo Notes (輸入您的標題)subtitle: 健忘筆記本 （輸入您的至理名言）description:(輸入您的網站描述)author: Kanboo （輸入您的姓名）language: zh-TW （輸入您所使用的語言）timezone: (留空可以使用系統時間！) 同樣 _config.yml 這個檔案底下，找到 deploy 設定github 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/用戶名/用戶名.github.io.git branch: master 用戶名 就是指你自己的github帳號，記得改對，然後按存檔。 撰寫文件及常用指令撰寫文件至於內文採用的 Markdown 格式不難學，只需要記幾個常用的指令，遇到不懂的再上網查就好。 123456789斜體： *斜體* 粗體： **粗體** 粗斜體： ***粗斜體*** 刪除線：~~刪除~~ 引言： &gt; 引言 章節： # 章節 次級章節（以此類推）： ## 次級章節 表格（註1）：|一行|一行|疊| 插入超連結： [超連結文字](網址) 插入外部圖片： ![圖片描述](圖片網址) Markdown文件Markdown CheatsheetMarkdown 寫表格 指令1234567$ hexo new "postName" #新建文章$ hexo clean #清除快取$ hexo generate #生成靜態頁面至public目錄$ hexo server #開啟預覽訪問端口（默認端口4000，'ctrl + c'關閉server）$ hexo deploy #將.deploy目錄部署到GitHub$ hexo help #查看幫助$ hexo version #查看Hexo的版本 指令簡寫 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 更換Blog主題(NexT)主要完成的步驟如下： 安裝 Blog主題(NexT) _config.yml 修改theme:NexT NexT細項功能設定 如果啟用 分類、標籤 的話，並不會自動幫你建立，可參考下列協助產生 1234新建分類、標籤、關於頁面：$ hexo new page ‘categories’$ hexo new page ‘tags’$ hexo new page ‘about’ hexo-generator-category 產生分類頁$ npm install hexo-generator-category --save hexo-generator-tag 產生標籤頁$ npm install hexo-generator-tag --save 參考網站Hexo搭建GitHub博客 系列文章Github Pages + Hexo搭建博客當個部落客McK-Note Hexo 官網NexT 官網]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LiveCoding-切個垂直時間軸]]></title>
    <url>%2F2017%2F10%2F12%2Flivecoding-timeline%2F</url>
    <content type="text"><![CDATA[教學來源Youtube：直播 - 切個垂直時間軸 GitHub 分支：https://goo.gl/VEbWkm 參考版型：https://goo.gl/rqjErS 螢幕吸顏色 Sip：https://goo.gl/Vh6YIo LiveCoding 官方網站：https://goo.gl/weYx5q LiveCoding Youtube 頻道：https://goo.gl/Hyih3u LiveCoding 臉書粉絲專頁：https://goo.gl/yhDg0l 排版小技巧紀錄 切版過程中，可常利用新增「外層的紅框線」，先確認位置是否正確，事後再拿掉。 border: 1px solid rgba(255, 0, 0, .3) CSS之calc可做運算式運算 calc(50% — 10px / 2) z-index z-index 記得搭配 position : relative 、 absolute 使用 z-index 數字越大的在越上面，反之則在越下面 行高 1234H3&#123; height: 45px; line-height: 45px;&#125; 深入 CSS 之 line-height 應用 時間紀錄點頭像(10分開始) 頭像+白色圓外框+黑色的陰影(12分30秒) 時間軸的 垂直中線 位置的偏移(14分30秒開始) 按鈕(載入更多)(28分19秒開始) 時間軸的icon(38分30秒開始) 資訊卡之小箭頭(1時3分30秒) 使用 CSS Arrow Please，再修改部份css 將 資訊卡區塊 開始變 左右 排版(1時7分 開始) 可用的方法有： 針對左右給不同的 class 用 js 控制 用 nth-child 12345678910/* content底下的第一子元素是:&lt;i&gt;第二個是&lt;button&gt;第三個是&lt;div 資訊卡&gt; *//* 從content底下的子元素，從第3個元素開始並每次加2的倍數(奇數) */:nth-child(2n + 3)/* 從content底下的子元素，從第4個元素開始並每次加2的倍數(偶數) */:nth-child(2n + 4) 用 js 動態新增資訊卡(1h 15分 開始) 123456789101112// 在div底下// 新增img HTML$('&lt;div /&gt;').append ($('&lt;img /&gt;')// 新增 info 的Class$('&lt;div /&gt;').addClass ('info')// 新增 data-time 屬性$('&lt;div /&gt;').attr ('data-time', "2017-10-10")// 新增 純文字$('&lt;div /&gt;').text('我是單純顯示的文字') 資訊卡之圖片(1時28分 開始) 123456789101112131415.content &#123; content屬性設定 .img &#123; img屬性設定 +h3 &#123; h3屬性設定-特例 &#125; &#125; .h3 &#123; h3屬性設定 &#125;&#125; 注意： img 底下有加一個 +h3 的設定 另外 img 平行也有一個 h3 的設定 這裡的觀念為 CSS權重，下列有二個 h3 的設定 1234567img+h3&#123; 屬性設定-特例&#125;h3&#123; 屬性設定&#125; 雖然CSS通常都是 權重一樣大 的話，就是 後面 蓋掉 前面 的屬性，但是 img+h3 權重 &gt; h3 權重，所以 img+h3 不會被後面 單一個h3 屬性蓋掉。 CSS權重 改寫 RWD的格式(1時34分30秒) js 塞入html方式 改寫用 object(json格式)(1時50分 開始)]]></content>
      <categories>
        <category>切版</category>
      </categories>
      <tags>
        <tag>排版</tag>
        <tag>LiveCoding</tag>
        <tag>timeline</tag>
        <tag>切版</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tool-gulp]]></title>
    <url>%2F2017%2F10%2F09%2FTool-gulp%2F</url>
    <content type="text"><![CDATA[gulp環境安裝安裝 Global Gulp 環境npm install gulp -g 如果無法安裝 Global Gulp 環境，請用以下並輸入系統密碼sudo npm install gulp -g 有沒有加入 -g 差異在哪裡呢？ 有加入 “-g”：這是安裝全域的套件也就是安裝在目前的電腦上目的是啟用 “gulp” 這個指令 沒有加入：這是 local 套件安裝的指令是裝在目前的專案資料夾內目的是執行 gulp 時可以取用的套件 總結：只有 npm install gulp -g 才會使用到全域的指令，在教學中， -g 也只會出現一次喔～其餘 gulp 套件只會用到 “npm install –save”。 gulp設定 建立 npm 環境 (package.json用於紀錄安裝什麼套件) npm init 建立 專案用的gulp環境 npm install gulp --save-dev 註1：最後面加 –save 代表將安裝紀錄，記在 package.json註2：安裝完後，會產生node_modules 資料夾(裡面會有許多npm的相依套件) 新增一個檔案：gulpfile.js (用於撰寫預執行的任務) 可搭配 Bower 一起建置開發環境。 1234567npm install gulp-sass --save -&gt;給「正式環境」使用npm install gulp-sass --save-dev -&gt;給「開發環境」使用--save-dev是你開發時候依賴的東西，--save是你發布之後還依賴的東西。比如，你寫ES6代碼，如果你想編譯成ES5發布那麼babel就是devDependencies。如果你用了jQuery，由於發布之後還是依賴jQuery，所以是dependencies。 gulp+bower 設定範本已建置完成範本：gulp-setting 當上述都已設定好，只要將設定檔放置新專案資料夾後，依序執行下列指令即可 123bower installnmp installgulp]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS - float排版問題]]></title>
    <url>%2F2017%2F10%2F04%2FCSS-float%2F</url>
    <content type="text"><![CDATA[紀錄一下 float排版問題 問題：在練習Bootstrap3將表單驗證功能加進去，卻遇到畫面「跑版」的問題，目前是查到 「名稱」底下的&lt;div class=&quot;help-block with-errors&quot;&gt;&lt;/div&gt;所導致。 可能原因為 float？ margin？ 問題點：1.單點 「名稱」欄位，就會造成下方欄位跑版。2.若同時有驗證 左右二邊，欄位又有對齊了。 codepen：排版偏移程式碼解決： 如上圖所述，第一個「名稱」腳變長，造成第三個「Email」排不進去被往後推，導致第四個「聯絡電話」也被往後推擠，造成排版歪掉。 解法為 外層用 row 包起來，清除float的浮動(clearfix)。 codepen：修正後程式碼]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>排版</tag>
        <tag>float</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS - Flexbox]]></title>
    <url>%2F2017%2F09%2F30%2FCSS-Flexbox%2F</url>
    <content type="text"><![CDATA[常用屬性 概念圖 Flex 外容器屬性：flex-direction：決定 flex 主軸線 方向[ row | row-reverse | column | column-reverse ] justify-content：主要軸線(左右)的對齊[ flex-start | flex-end | center | space-between | space-around ] align-items：交錯軸線(上下)的對齊[ flex-start | flex-end | center | baseline | stretch ] Flex 內元件屬性：align-self：單一個物件的交錯軸對齊[ auto | flex-start | flex-end | center | baseline | stretch ] 參考網站圖解：CSS Flex 屬性一點也不難 CSS Flexbox Layout 學習心得筆記]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Flexbox</tag>
        <tag>排版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS - 排版重點整理]]></title>
    <url>%2F2017%2F09%2F30%2FCSS-Layout%2F</url>
    <content type="text"><![CDATA[[display屬性]每一個html標籤都有一個預設的display屬性，通常是block(區塊元素)或者是inline(行內元素)。 block：會從新的一行開始且在占據網頁的一整行，具自己個寬高。 inline：無法設定寬高，依照包含的內容先是寬度。 inline-block：可設定寬高，但又不占據一整行。 none：不顯示，可用來跟使用者互動。 [定位] position，設定區塊的座標方式。如下[position] left/top/right/bottom，設定區塊的左/上/右/下的座標。 z-index，設定區塊的重疊時的顯示優先權。 overflow，當內容超出區塊範圍時候的顯示方式。 [position] static:預設，各元素不用設定即是static，遵守網頁規則由左至右，由上至下。 relative:依照原來存在位置進行調整。absolute:會找上一層(找不到再往上找)有誰設定過 position，依照這個父元素進行位置調整，如果都沒有那就依body進行調整。 fixed:依目前看得網頁進行定位。若是要對齊容器內（div）的對位置，採用absolute比較方便。不用特別計算跟父容器的距離。 [float]設定區塊間的流動方式，像是doc當中的文繞圖。 left:往網頁左邊流動。 right:往網頁右邊流動。 clear:both ：清除流動關係。 [區塊] width，設定區塊寬度。width:1080px; height，設定區塊高度。height:500px; float，設定區塊流動方向。float:left; clear，解除區塊流動。 margin，設定區塊外間距離。如下[margin]。 padding，設定區塊內距。同margin。 [margin設定] margin:10px 20px 30px 40px; 依序為上 右 下 左 margin:10xp 20px 30px; 上 右 下 ?–&gt;找對面的來補,所以是找右的設定來補 margin:10px 20px; 依序為上下 左右 margin:10px; 全都一樣 [背景] background-color，背景顏色 background-image，背景圖案 background-attachment，背景是否固定不動 background-repeat，背景是否重複 background-position，背景位置 [邊框] border-color，四邊的顏色 border-style，四邊的樣式 border-width，四邊的寬度 border-top-color，上邊框的顏色，top可以置換成為right、bottom、left。 border-top-style，上邊框的樣式，top可以置換成為right、bottom、left。 border-top-width，上邊框的寬度，top可以置換成為right、bottom、left。 border-top，上邊框的顏色、樣式與寬度。top可以置換成為right、bottom、left。 border，寬度、樣式、顏色。 [文字] font-family，設定字型 font-size，字體大小 color，字體顏色 line-height，文字行高 font-weight，文字粗體 text-decoration，文字底線 word-spacing，間距 letter-spacing，間距 text-aling，水平對齊方向 text-indent，字首縮排]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>排版</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown常用寫法(置頂)]]></title>
    <url>%2F2017%2F09%2F30%2FMarkDownWrite%2F</url>
    <content type="text"><![CDATA[將常用的 MarkDown 紀錄在這， Ctrl + C 、 Ctrl + V 比較方便。 文字加顏色藍色字 1&lt;font color=&quot;blue&quot;&gt;藍色字&lt;/font&gt; 紅色的字 1&lt;font color=&quot;red&quot;&gt;紅色的字&lt;/font&gt; 20px的字 1&lt;font style=&quot;color:#f90;font-size:20px;&quot;&gt;20px的字&lt;/font&gt; MARKDOWN/HTML常用語法小結 文字增加背景色塊站点配置文件 主题配置文件 站点配置文件 主题配置文件 1234&lt;span id="inline-blue"&gt;站点配置文件&lt;/span&gt;&lt;span id="inline-purple"&gt;主题配置文件&lt;/span&gt;&lt;span id="inline-yellow"&gt;站点配置文件&lt;/span&gt;&lt;span id="inline-green"&gt;主题配置文件&lt;/span&gt; 自定義樣式下列 自定義樣式，參考 超深度优化 文本置中引用我不是一個偉大的程式設計師,我只是一個具有良好習慣的優秀程式設計師。 123&#123;% cq %&#125;我不是一個偉大的程式設計師,我只是一個具有良好習慣的優秀程式設計師。&#123;% endcq %&#125; 数字塊1.左邊是效果。2.我是第二行。 客制CSS文件位置：~/blog/themes/next/source/css/_custom/custom.styl12&lt;span id="inline-toc"&gt;1.&lt;/span&gt;&lt;span id="inline-toc"&gt;2.&lt;/span&gt; label標籤default 1&#123;% label default@default %&#125; primary 1&#123;% label primary@primary %&#125; success 1&#123;% label success@success %&#125; info 1&#123;% label info@info %&#125; warning 1&#123;% label warning@warning %&#125; danger 1&#123;% label danger@danger %&#125; note 標籤default no-icon 1&lt;div class="note default no-icon"&gt;default no-icon&lt;/div&gt; default 1&lt;div class="note default"&gt;default&lt;/div&gt; primary 1&lt;div class="note primary"&gt;primary&lt;/div&gt; success 1&lt;div class="note success"&gt;success&lt;/div&gt; info 1&lt;div class="note info"&gt;info&lt;/div&gt; warning 1&lt;div class="note warning"&gt;warning&lt;/div&gt; danger 1&lt;div class="note danger"&gt;danger&lt;/div&gt; 引用内容 客制CSS文件位置：~/blog/themes/next/source/css/_custom/custom.styl1&lt;blockquote class="question"&gt;内容&lt;/blockquote&gt; 程式碼行內height: 50px; 1`height: 50px;` 區段區段寫法12345``` [language] [title] [url] [link-text]- [language] 是代碼語言的名稱，用來設置代碼塊顏色高亮，非必須；- [title] 是頂部左邊的說明，非必須；- [url] 是頂部右邊的超鏈接地址，非必須；- [link text] 如它的字面意思，超鏈接的名稱，非必須。 上述4項應該是根據 空格 來分隔，而不是 []，故請不要加 []。除非如果你想寫後面兩個，但不想寫前面兩個，那麼就必須加 [] 了，要這樣寫： [] [] [url] [link text]。 MarkDown寫法： CSS12345678``` CSS.container &#123; max-width: 960px; margin: 0 auto; /* 起手式 */ margin-top: 10px;`&#125;``` js12345678910111213``` js.container &#123; function checkList(e) &#123; var num = e.target.dataset.num; // console.log(e.target.nodeName); if (e.target.nodeName !== &apos;LI&apos;) &#123; return &#125;; country.splice(num, 1); updateList(); &#125;&#125;``` 可支援的語法： 連結 插入圖片 內部圖片 1&#123;% asset_img logo.png logo %&#125; 外部圖片 1![Mario](https://goo.gl/2Dty9K) 文字超連結 More info: Writing Google連結：Google 123More info: [Writing](https://hexo.io/docs/writing.html)Google連結：[Google](https://www.google.com.tw/) 項目標籤 符號 序列1 序列2 序列3 123* 序列1* 序列2* 序列3 Check 序列1 序列2 序列3 序列4 1234- [ ] 序列1- [ ] 序列2- [ ] 序列3- [ ] 序列4 數字 序列1 序列2 序列3 序列4 12341. 序列12. 序列23. 序列34. 序列4 重點標示Strong emphasis, aka bold, with asterisks or underscores. Combined emphasis with asterisks and underscores. Strikethrough uses two tildes. Scratch this. 12345Strong emphasis, aka bold, with **asterisks** or __underscores__.Combined emphasis with **asterisks and _underscores_**.Strikethrough uses two tildes. ~~Scratch this.~~]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
</search>
